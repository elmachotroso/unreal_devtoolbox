// Copyright Epic Games, Inc. All Rights Reserved.

#define USE_HAIR_COMPLEX_TRANSMITTANCE 1

#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "../BRDF.ush"
#include "LumenScreenProbeCommon.ush"
#include "../MonteCarlo.ush"
#include "../ShadingModelsSampling.ush"
#include "../SHCommon.ush"
#include "../SceneTextureParameters.ush"
#include "../SphericalGaussian.ush"
#include "../FastMath.ush"
#include "../ClearCoatCommon.ush"
#include "LumenRadianceCacheMarkCommon.ush"
#include "../TextureSampling.ush"
#include "../MortonCode.ush"
#include "LumenScreenSpaceBentNormal.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

#ifndef INTEGRATE_TILE_CLASSIFICATION_MODE
#define INTEGRATE_TILE_CLASSIFICATION_MODE 0
#endif

RWTexture2D<float> RWOctahedralSolidAngleTexture;
uint OctahedralSolidAngleTextureSize;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void OctahedralSolidAngleCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	if (all(DispatchThreadId.xy < OctahedralSolidAngleTextureSize))
	{
		float2 ProbeTexelCenter = float2(0.5, 0.5);
		float2 ProbeUV = (DispatchThreadId.xy + ProbeTexelCenter) / (float)OctahedralSolidAngleTextureSize;
		float SolidAngle = OctahedralSolidAngle(ProbeUV, 1.0f / (float)OctahedralSolidAngleTextureSize);
		RWOctahedralSolidAngleTexture[DispatchThreadId.xy] = SolidAngle;
	}
}

RWTexture2D<float> RWDepth;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CopyDepthCS( 
	uint2 DispatchThreadId : SV_DispatchThreadID)
{
	float DeviceZ = SceneDepthTexture[DispatchThreadId].x;
	RWDepth[DispatchThreadId] = DeviceZ;
}

RWTexture2D<uint> RWScreenProbeSceneDepth;
RWTexture2D<uint> RWScreenProbeWorldSpeed;
RWTexture2D<UNORM float2> RWScreenProbeWorldNormal;
RWTexture2D<float3> RWScreenProbeTranslatedWorldPosition;

struct FScreenProbeGBuffer
{
	float3 WorldNormal;
	float SceneDepth;
	bool bLit;
	bool bTwoSidedFoliage;
};

FScreenProbeGBuffer GetScreenProbeGBuffer(FGBufferData GBufferData)
{ 
	FScreenProbeGBuffer ScreenProbeGBuffer;
	ScreenProbeGBuffer.WorldNormal = GBufferData.WorldNormal;
	ScreenProbeGBuffer.SceneDepth = GBufferData.Depth;
	ScreenProbeGBuffer.bLit = GBufferData.ShadingModelID != SHADINGMODELID_UNLIT;
	ScreenProbeGBuffer.bTwoSidedFoliage = GBufferData.ShadingModelID == SHADINGMODELID_TWOSIDED_FOLIAGE;
	return ScreenProbeGBuffer;
}

void WriteDownsampledProbeGBuffer(float2 ScreenUV, uint2 ScreenProbeAtlasCoord, FScreenProbeGBuffer ProbeGBuffer)
{
	float EncodedDepth = ProbeGBuffer.SceneDepth;

	if (!ProbeGBuffer.bLit)
	{
		// Store unlit in sign bit
		EncodedDepth *= -1.0f;
	}

	RWScreenProbeSceneDepth[ScreenProbeAtlasCoord] = asuint(EncodedDepth);

	RWScreenProbeWorldNormal[ScreenProbeAtlasCoord] = UnitVectorToOctahedron(ProbeGBuffer.WorldNormal) * 0.5 + 0.5;

	float3 ProbeWorldVelocity;
	float3 ProbeTranslatedWorldPosition;
	{
		float2 ProbeScreenPosition = (ScreenUV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;

		float ProbeDeviceZ = ConvertToDeviceZ(ProbeGBuffer.SceneDepth);
		float3 ProbeHistoryScreenPosition = GetHistoryScreenPositionIncludingTAAJitter(ProbeScreenPosition, ScreenUV, ProbeDeviceZ);

		ProbeTranslatedWorldPosition = mul(float4(ProbeScreenPosition * ProbeGBuffer.SceneDepth, ProbeGBuffer.SceneDepth, 1), View.ScreenToTranslatedWorld).xyz;
		ProbeWorldVelocity = ProbeTranslatedWorldPosition - GetPrevTranslatedWorldPosition(ProbeHistoryScreenPosition);
	}

	RWScreenProbeWorldSpeed[ScreenProbeAtlasCoord] = EncodeScreenProbeSpeed(length(ProbeWorldVelocity), ProbeGBuffer.bTwoSidedFoliage);

	RWScreenProbeTranslatedWorldPosition[ScreenProbeAtlasCoord] = ProbeTranslatedWorldPosition;
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeDownsampleDepthUniformCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy;

	if (all(ScreenProbeAtlasCoord < ScreenProbeAtlasViewSize))
	{
		uint2 ScreenJitter = GetScreenTileJitter(SCREEN_TEMPORAL_INDEX);
		uint2 ScreenProbeScreenPosition = min((uint2)(ScreenProbeAtlasCoord * ScreenProbeDownsampleFactor + ScreenJitter), (uint2)(View.ViewRectMin.xy + View.ViewSizeAndInvSize.xy) - 1);
		float2 ScreenUV = (ScreenProbeScreenPosition + .5f) * View.BufferSizeAndInvSize.zw;
		FGBufferData GBufferData = GetGBufferDataUint(ScreenProbeScreenPosition);
		
		WriteDownsampledProbeGBuffer(ScreenUV, ScreenProbeAtlasCoord, GetScreenProbeGBuffer(GBufferData));
	}
}

float GetScreenProbeDepthFromUAV(uint2 ScreenProbeAtlasCoord)
{
	return asfloat(RWScreenProbeSceneDepth[ScreenProbeAtlasCoord]);
}

void CalculateUniformUpsampleInterpolationWeights(
	float2 ScreenCoord, 
	float2 NoiseOffset, 
	float3 WorldPosition, 
	float SceneDepth, 
	float3 WorldNormal, 
	uniform bool bIsUpsamplePass,
	out uint2 ScreenTileCoord00, 
	out float4 InterpolationWeights)
{
	uint2 ScreenProbeFullResScreenCoord = clamp(ScreenCoord.xy - View.ViewRectMin.xy - GetScreenTileJitter(SCREEN_TEMPORAL_INDEX) + NoiseOffset, 0.0f, View.ViewSizeAndInvSize.xy - 1.0f);
	ScreenTileCoord00 = min(ScreenProbeFullResScreenCoord / ScreenProbeDownsampleFactor, (uint2)ScreenProbeViewSize - 2);

	uint BilinearExpand = 1;
	float2 BilinearWeights = (ScreenProbeFullResScreenCoord - ScreenTileCoord00 * ScreenProbeDownsampleFactor + BilinearExpand) / (float)(ScreenProbeDownsampleFactor + 2 * BilinearExpand);

	float4 CornerDepths;
	CornerDepths.x = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00) : GetScreenProbeDepthFromUAV(ScreenTileCoord00);
	CornerDepths.y = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00 + int2(1, 0)) : GetScreenProbeDepthFromUAV(ScreenTileCoord00 + int2(1, 0));
	CornerDepths.z = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00 + int2(0, 1)) : GetScreenProbeDepthFromUAV(ScreenTileCoord00 + int2(0, 1));
	CornerDepths.w = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00 + int2(1, 1)) : GetScreenProbeDepthFromUAV(ScreenTileCoord00 + int2(1, 1));

	InterpolationWeights = float4(
		(1 - BilinearWeights.y) * (1 - BilinearWeights.x),
		(1 - BilinearWeights.y) * BilinearWeights.x,
		BilinearWeights.y * (1 - BilinearWeights.x),
		BilinearWeights.y * BilinearWeights.x);

	float4 DepthWeights;

#define PLANE_WEIGHTING 1
#if PLANE_WEIGHTING
	{
		float4 ScenePlane = float4(WorldNormal, dot(WorldPosition, WorldNormal));

		float3 Position00 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00), CornerDepths.x);
		float3 Position10 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00 + uint2(1, 0)), CornerDepths.y);
		float3 Position01 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00 + uint2(0, 1)), CornerDepths.z);
		float3 Position11 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00 + uint2(1, 1)), CornerDepths.w);

		float4 PlaneDistances;
		PlaneDistances.x = abs(dot(float4(Position00, -1), ScenePlane));
		PlaneDistances.y = abs(dot(float4(Position10, -1), ScenePlane));
		PlaneDistances.z = abs(dot(float4(Position01, -1), ScenePlane));
		PlaneDistances.w = abs(dot(float4(Position11, -1), ScenePlane));
			
		float4 RelativeDepthDifference = PlaneDistances / SceneDepth;

		DepthWeights = CornerDepths > 0 ? exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference)) : 0;
	}
#else
	{
		float4 DepthDifference = abs(CornerDepths - SceneDepth.xxxx);
		float4 RelativeDepthDifference = DepthDifference / SceneDepth;
		DepthWeights = CornerDepths > 0 ? exp2(-100.0f * (RelativeDepthDifference * RelativeDepthDifference)) : 0;
	}
#endif

	InterpolationWeights *= DepthWeights;
}

RWTexture2D<uint> RWScreenTileAdaptiveProbeHeader;
RWTexture2D<uint> RWScreenTileAdaptiveProbeIndices;
RWStructuredBuffer<uint> RWAdaptiveScreenProbeData;

struct FScreenProbeSample
{
	uint2 AtlasCoord[4];
	float4 Weights;
};

void CalculateUpsampleInterpolationWeights(
	float2 ScreenCoord,
	float2 NoiseOffset,
	float3 WorldPosition,
	float SceneDepth,
	float3 WorldNormal,
	uniform bool bIsUpsamplePass,
	out FScreenProbeSample ScreenProbeSample)
{
	uint2 ScreenTileCoord00;
	CalculateUniformUpsampleInterpolationWeights(ScreenCoord, NoiseOffset, WorldPosition, SceneDepth, WorldNormal, bIsUpsamplePass, ScreenTileCoord00, ScreenProbeSample.Weights);

	ScreenProbeSample.AtlasCoord[0] = ScreenTileCoord00;
	ScreenProbeSample.AtlasCoord[1] = ScreenTileCoord00 + uint2(1, 0);
	ScreenProbeSample.AtlasCoord[2] = ScreenTileCoord00 + uint2(0, 1);
	ScreenProbeSample.AtlasCoord[3] = ScreenTileCoord00 + uint2(1, 1);

	bool bUseAdaptiveProbesForUpsample = true;

	if (bUseAdaptiveProbesForUpsample || !bIsUpsamplePass)
	{		
		float Epsilon = .01f;
		float4 ScenePlane = float4(WorldNormal, dot(WorldPosition, WorldNormal));

		UNROLL
		for (uint CornerIndex = 0; CornerIndex < 4; CornerIndex++)
		{
			if (ScreenProbeSample.Weights[CornerIndex] <= Epsilon)
			{
				uint2 ScreenTileCoord = ScreenTileCoord00 + uint2(CornerIndex % 2, CornerIndex / 2);
				uint NumAdaptiveProbes = bIsUpsamplePass ? ScreenTileAdaptiveProbeHeader[ScreenTileCoord] : RWScreenTileAdaptiveProbeHeader[ScreenTileCoord];

				for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
				{
					uint2 AdaptiveProbeCoord = GetAdaptiveProbeCoord(ScreenTileCoord, AdaptiveProbeListIndex);
					uint AdaptiveProbeIndex = bIsUpsamplePass ? ScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord] : RWScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord];
					uint ScreenProbeIndex = AdaptiveProbeIndex + NumUniformScreenProbes;

					uint2 ScreenProbeScreenPosition = bIsUpsamplePass ? GetScreenProbeScreenPosition(ScreenProbeIndex) : DecodeScreenProbeData(RWAdaptiveScreenProbeData[AdaptiveProbeIndex]);
					uint2 ScreenProbeAtlasCoord = uint2(ScreenProbeIndex % ScreenProbeAtlasViewSize.x, ScreenProbeIndex / ScreenProbeAtlasViewSize.x);
					float ProbeDepth = bIsUpsamplePass ? GetScreenProbeDepth(ScreenProbeAtlasCoord) : GetScreenProbeDepthFromUAV(ScreenProbeAtlasCoord);
					
					float NewDepthWeight = 0;
					bool bPlaneWeighting = true;
					if (bPlaneWeighting)
					{
						float3 ProbePosition = GetWorldPositionFromScreenUV(GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition), ProbeDepth);
						float PlaneDistance = abs(dot(float4(ProbePosition, -1), ScenePlane));
						float RelativeDepthDifference = PlaneDistance / SceneDepth;
						NewDepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));
					}
					else
					{
						float DepthDifference = abs(ProbeDepth - SceneDepth);
						float RelativeDepthDifference = DepthDifference / SceneDepth;
						NewDepthWeight = ProbeDepth > 0 ? exp2(-100.0f * (RelativeDepthDifference * RelativeDepthDifference)) : 0;
					}

					float2 DistanceToScreenProbe = abs(ScreenProbeScreenPosition - ScreenCoord);
					float NewCornerWeight = 1.0f - saturate(min(DistanceToScreenProbe.x, DistanceToScreenProbe.y) / (float)ScreenProbeDownsampleFactor);
					float NewInterpolationWeight = NewDepthWeight * NewCornerWeight;

					if (NewInterpolationWeight > ScreenProbeSample.Weights[CornerIndex])
					{
						ScreenProbeSample.Weights[CornerIndex] = NewInterpolationWeight;
						ScreenProbeSample.AtlasCoord[CornerIndex] = ScreenProbeAtlasCoord;
					}
				}
			}
		}
	}
}

RWStructuredBuffer<uint> RWNumAdaptiveScreenProbes;

groupshared uint SharedNumProbesToAllocate;
groupshared uint SharedAdaptiveProbeBaseIndex;
groupshared uint2 SharedProbeScreenPositionsToAllocate[THREADGROUP_SIZE * THREADGROUP_SIZE];
groupshared FScreenProbeGBuffer SharedScreenProbeGBuffer[THREADGROUP_SIZE * THREADGROUP_SIZE];

uint PlacementDownsampleFactor;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeAdaptivePlacementCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	if (ThreadIndex == 0)
	{
		SharedNumProbesToAllocate = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	{
		uint2 ScreenProbeScreenPosition = DispatchThreadId.xy * PlacementDownsampleFactor + GetScreenTileJitter(SCREEN_TEMPORAL_INDEX) + (uint2)View.ViewRectMin.xy;

		if (all(ScreenProbeScreenPosition < (uint2)(View.ViewRectMin.xy + View.ViewSizeAndInvSize.xy)) && any((DispatchThreadId.xy & 0x1) != 0))
		{
			FGBufferData GBufferData = GetGBufferDataUint(ScreenProbeScreenPosition);

			if (GBufferData.ShadingModelID != SHADINGMODELID_UNLIT)
			{
				float2 ScreenUV = (ScreenProbeScreenPosition + .5f) * View.BufferSizeAndInvSize.zw;
				float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, GBufferData.Depth);
				float2 NoiseOffset = 0.0f;

				FScreenProbeSample ScreenProbeSample = (FScreenProbeSample)0;

				CalculateUpsampleInterpolationWeights(
					ScreenProbeScreenPosition,
					NoiseOffset,
					WorldPosition,
					GBufferData.Depth,
					GBufferData.WorldNormal,
					false,
					ScreenProbeSample);

				float Epsilon = .01f;
				ScreenProbeSample.Weights /= max(dot(ScreenProbeSample.Weights, 1), Epsilon);

				float LightingIsValid = (dot(ScreenProbeSample.Weights, 1) < 1.0f - Epsilon) ? 0.0f : 1.0f;

				if (!LightingIsValid)
				{
					uint SharedListIndex;
					InterlockedAdd(SharedNumProbesToAllocate, 1, SharedListIndex);
					SharedProbeScreenPositionsToAllocate[SharedListIndex] = ScreenProbeScreenPosition;
					SharedScreenProbeGBuffer[SharedListIndex] = GetScreenProbeGBuffer(GBufferData);
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (ThreadIndex == 0)
	{
		InterlockedAdd(RWNumAdaptiveScreenProbes[0], SharedNumProbesToAllocate, SharedAdaptiveProbeBaseIndex);
	}

	GroupMemoryBarrierWithGroupSync();

	uint AdaptiveProbeIndex = ThreadIndex + SharedAdaptiveProbeBaseIndex;

	if (ThreadIndex < SharedNumProbesToAllocate && AdaptiveProbeIndex < MaxNumAdaptiveProbes)
	{
		uint2 ScreenProbeScreenPosition = SharedProbeScreenPositionsToAllocate[ThreadIndex];
		RWAdaptiveScreenProbeData[AdaptiveProbeIndex] = EncodeScreenProbeData(ScreenProbeScreenPosition);
		uint2 ScreenTileCoord = GetScreenTileCoord(ScreenProbeScreenPosition);

		uint TileProbeIndex;
		InterlockedAdd(RWScreenTileAdaptiveProbeHeader[ScreenTileCoord], 1, TileProbeIndex);
		uint2 AdaptiveProbeCoord = GetAdaptiveProbeCoord(ScreenTileCoord, TileProbeIndex);
		RWScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord] = AdaptiveProbeIndex;
		
		float2 ScreenUV = (ScreenProbeScreenPosition + .5f) * View.BufferSizeAndInvSize.zw;
		uint ScreenProbeIndex = NumUniformScreenProbes + AdaptiveProbeIndex;
		uint2 ScreenProbeAtlasCoord = uint2(ScreenProbeIndex % ScreenProbeAtlasViewSize.x, ScreenProbeIndex / ScreenProbeAtlasViewSize.x);
		WriteDownsampledProbeGBuffer(ScreenUV, ScreenProbeAtlasCoord, SharedScreenProbeGBuffer[ThreadIndex]);
	}
}

RWBuffer<uint> RWScreenProbeIndirectArgs;

void WriteArgs2D(uint Index, uint2 ThreadCount)
{
	RWScreenProbeIndirectArgs[Index * 3 + 0] = (ThreadCount.x +	PROBE_THREADGROUP_SIZE_2D - 1) / PROBE_THREADGROUP_SIZE_2D;
	RWScreenProbeIndirectArgs[Index * 3 + 1] = (ThreadCount.y + PROBE_THREADGROUP_SIZE_2D - 1) / PROBE_THREADGROUP_SIZE_2D;
	RWScreenProbeIndirectArgs[Index * 3 + 2] = 1;
}

[numthreads(1, 1, 1)]
void SetupAdaptiveProbeIndirectArgsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 AtlasSizeInProbes = uint2(ScreenProbeAtlasViewSize.x, (GetNumScreenProbes() + ScreenProbeAtlasViewSize.x - 1) / ScreenProbeAtlasViewSize.x);

	// Must match EScreenProbeIndirectArgs in C++
	WriteArgs2D(0, AtlasSizeInProbes * PROBE_THREADGROUP_SIZE_2D);
	WriteArgs2D(1, AtlasSizeInProbes);
	WriteArgs2D(2, AtlasSizeInProbes * ScreenProbeTracingOctahedronResolution);
	WriteArgs2D(3, AtlasSizeInProbes * ScreenProbeGatherOctahedronResolution);
	WriteArgs2D(4, AtlasSizeInProbes * ScreenProbeGatherOctahedronResolutionWithBorder);
}

[numthreads(PROBE_THREADGROUP_SIZE_2D, PROBE_THREADGROUP_SIZE_2D, 1)]
void MarkRadianceProbesUsedByScreenProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;
	uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);

	if (ScreenProbeIndex < GetNumScreenProbes() && ScreenProbeAtlasCoord.x < ScreenProbeAtlasViewSize.x)
	{
		float2 ScreenUV = GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition);
		float SceneDepth = GetScreenProbeDepth(ScreenProbeAtlasCoord);
		float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

		if (SceneDepth > 0)
		{
			uint ClipmapIndex = GetRadianceProbeClipmapForMark(WorldPosition, InterleavedGradientNoise(ScreenProbeAtlasCoord.xy, GENERAL_TEMPORAL_INDEX));

			if (IsValidRadianceCacheClipmapForMark(ClipmapIndex))
			{
				//@todo - cull by screen size
				//@todo - cull probes too small for voxel tracing and too large for max trace distance
				MarkPositionUsedInIndirectionTexture(WorldPosition, ClipmapIndex);
			}
		}
	}
}

int2 HairStrandsResolution;
float2 HairStrandsInvResolution;
uint HairStrandsMip;

#if PERMUTATION_USETILE
#include "../HairStrands/HairStrandsTileCommon.ush"
[numthreads(64, 1, 1)]
#else
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
#endif
void MarkRadianceProbesUsedByHairStrandsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 PixelCoords = 0;
	#if PERMUTATION_USETILE
	{
		const uint TileLinearIndex = DispatchThreadId.x;
		const uint TileCount = HairStrands.HairTileCount[HAIRTILE_HAIR_ALL];
		if (TileLinearIndex >= TileCount)
			return;

		// Position of a 8x8 tile
		PixelCoords = HairStrands.HairTileData[TileLinearIndex];
	}
	#else
	{
		PixelCoords = DispatchThreadId.xy;
		if (any(PixelCoords >= uint2(HairStrandsResolution)))
			return;
	}
	#endif  // PERMUTATION_USETILE

	// HZB starts at MIP1
	const float SceneDepth = ConvertFromDeviceZ(HairStrands.HairOnlyDepthClosestHZBTexture.Load(uint3(PixelCoords, HairStrandsMip - 1)).r);

	// Two "mark-used" methods:
	// * Fast    : use the center of the tile to estimate the used probe
	// * Accurate: compute the AABB of the tile in world-space, and mark all used radiance probes
	#define MARK_PROBE_FAST 0
	#define MARK_PROBE_ACCUMRATE 1
	#define HAIRSTRANDS_MARK_USED_METHOD MARK_PROBE_ACCUMRATE

	if (SceneDepth > 0)
	#if HAIRSTRANDS_MARK_USED_METHOD == MARK_PROBE_ACCUMRATE
	{
		const float3 P0			= GetWorldPositionFromScreenUV((PixelCoords + uint2(0, 0)) * HairStrandsInvResolution, SceneDepth);
		const float3 P1			= GetWorldPositionFromScreenUV((PixelCoords + uint2(1, 1)) * HairStrandsInvResolution, SceneDepth);
		const float3 MinAABB    = min(P0, P1);
		const float3 MaxAABB    = max(P0, P1);

		const FRadianceProbeCoord MinAABBProbe = GetRadianceProbeCoord(MinAABB, .01f);
		const FRadianceProbeCoord MaxAABBProbe = GetRadianceProbeCoord(MaxAABB, .01f);

		// If AABB is withing the same interpolated probes
		if (all(MinAABBProbe.ProbeMinCoord == MaxAABBProbe.ProbeMinCoord) && MinAABBProbe.ClipmapIndex == MaxAABBProbe.ClipmapIndex)
		{
			if (IsValidRadianceCacheClipmapForMark(MinAABBProbe.ClipmapIndex))
			{
				MarkPositionUsedInIndirectionTexture(MinAABB, MinAABBProbe.ClipmapIndex);
			}
		}
		else 
		{	
			const float3 P0 = float3(MinAABB.x, MinAABB.y, MinAABB.z);
			const float3 P1 = float3(MaxAABB.x, MinAABB.y, MinAABB.z);
			const float3 P2 = float3(MinAABB.x, MaxAABB.y, MinAABB.z);
			const float3 P3 = float3(MaxAABB.x, MaxAABB.y, MinAABB.z);
			const float3 P4 = float3(MinAABB.x, MinAABB.y, MaxAABB.z);
			const float3 P5 = float3(MaxAABB.x, MinAABB.y, MaxAABB.z);
			const float3 P6 = float3(MinAABB.x, MaxAABB.y, MaxAABB.z);
			const float3 P7 = float3(MaxAABB.x, MaxAABB.y, MaxAABB.z);

			// If AABB is within the same clipmap
			if (MinAABBProbe.ClipmapIndex == MaxAABBProbe.ClipmapIndex)
			{
				const uint ClipmapIndex = MinAABBProbe.ClipmapIndex;
				if (IsValidRadianceCacheClipmapForMark(ClipmapIndex))
				{
					MarkPositionUsedInIndirectionTexture(P0, ClipmapIndex);
					MarkPositionUsedInIndirectionTexture(P1, ClipmapIndex);
					MarkPositionUsedInIndirectionTexture(P2, ClipmapIndex);
					MarkPositionUsedInIndirectionTexture(P3, ClipmapIndex);
					MarkPositionUsedInIndirectionTexture(P4, ClipmapIndex);
					MarkPositionUsedInIndirectionTexture(P5, ClipmapIndex);
					MarkPositionUsedInIndirectionTexture(P6, ClipmapIndex);
					MarkPositionUsedInIndirectionTexture(P7, ClipmapIndex);
				}
			}
			else
			{
				// If AABB is crossing clipmap boundary
				const uint ClipmapIndex0 = GetRadianceProbeClipmapForMark(P0); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex0)) { MarkPositionUsedInIndirectionTexture(P0, ClipmapIndex0); }
				const uint ClipmapIndex1 = GetRadianceProbeClipmapForMark(P1); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex1)) { MarkPositionUsedInIndirectionTexture(P1, ClipmapIndex1); }
				const uint ClipmapIndex2 = GetRadianceProbeClipmapForMark(P2); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex2)) { MarkPositionUsedInIndirectionTexture(P2, ClipmapIndex2); }
				const uint ClipmapIndex3 = GetRadianceProbeClipmapForMark(P3); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex3)) { MarkPositionUsedInIndirectionTexture(P3, ClipmapIndex3); }
				const uint ClipmapIndex4 = GetRadianceProbeClipmapForMark(P4); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex4)) { MarkPositionUsedInIndirectionTexture(P4, ClipmapIndex4); }
				const uint ClipmapIndex5 = GetRadianceProbeClipmapForMark(P5); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex5)) { MarkPositionUsedInIndirectionTexture(P5, ClipmapIndex5); }
				const uint ClipmapIndex6 = GetRadianceProbeClipmapForMark(P6); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex6)) { MarkPositionUsedInIndirectionTexture(P6, ClipmapIndex6); }
				const uint ClipmapIndex7 = GetRadianceProbeClipmapForMark(P7); if (IsValidRadianceCacheClipmapForMark(ClipmapIndex7)) { MarkPositionUsedInIndirectionTexture(P7, ClipmapIndex7); }
			}
		}
	}
	#else // HAIRSTRANDS_MARK_USED_METHOD == MARK_PROBE_FAST
	{
		const float3 P0 = GetWorldPositionFromScreenUV((PixelCoords + float2(0.5f, 0.5f)) * HairStrandsInvResolution, SceneDepth);
		const uint ClipmapIndex = GetRadianceProbeClipmapForMark(P0);
		if (IsValidRadianceCacheClipmapForMark(ClipmapIndex))
		{
			MarkPositionUsedInIndirectionTexture(P0, ClipmapIndex);
		}
	}
	#endif // HAIRSTRANDS_MARK_USED_METHOD
}

#define INTEGRATE_TILE_SIZE 8

#define TILE_CLASSIFICATION_SIMPLE_DIFFUSE 0
#define TILE_CLASSIFICATION_SUPPORT_IMPORTANCE_SAMPLE_BRDF 1
// SampleBxDF bloats VGPR requirements due to Hair shading
#define TILE_CLASSIFICATION_SUPPORT_ALL 2
#define TILE_CLASSIFICATION_NUM 3

RWBuffer<uint> RWIntegrateIndirectArgs;
RWTexture2D<float4> RWDiffuseIndirect;
RWTexture2D<float3> RWRoughSpecularIndirect;
RWTexture2D<uint> RWTileClassificationModes;

uint DefaultDiffuseIntegrationMethod;

groupshared uint SharedTileClassification[TILE_CLASSIFICATION_NUM];


float GetDiffuseLerp(float Roughness)
{
	return saturate((Roughness - .5f) / .3f);
}

// Note: must match SampleBxDFWrapper
bool RequiresBxDFImportanceSampling(uint ShadingModelID)
{
	switch (ShadingModelID)
	{
	case SHADINGMODELID_HAIR:
		return true;
	default:
		return false;
	}
}

// Highest quality and fastest for diffuse
#define DIFFUSE_INTEGRATION_SPHERICAL_HARMONIC 0
// Noisy and slow, but handles any shading model and GBuffer bent normal AO
#define DIFFUSE_INTEGRATION_IMPORTANCE_SAMPLE_BRDF 1
// Slow reference
#define DIFFUSE_INTEGRATION_NUMERICAL_INTEGRAL 2

uint GetDiffuseIntegrationMethod(FGBufferData GBufferData)
{
	uint DiffuseIntegrationMethod = DefaultDiffuseIntegrationMethod;

	if (RequiresBxDFImportanceSampling(GBufferData.ShadingModelID))
	{
		DiffuseIntegrationMethod = DIFFUSE_INTEGRATION_IMPORTANCE_SAMPLE_BRDF;
	}

#if GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
	if (GBufferData.DiffuseIndirectSampleOcclusion != 0)
	{
		DiffuseIntegrationMethod = DIFFUSE_INTEGRATION_IMPORTANCE_SAMPLE_BRDF;
	}
#endif

	return DiffuseIntegrationMethod;
}

[numthreads(INTEGRATE_TILE_SIZE, INTEGRATE_TILE_SIZE, 1)] 
void ScreenProbeTileClassificationMarkCS(
	uint2 GroupId : SV_GroupID,
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	if (DispatchThreadId.x < TILE_CLASSIFICATION_NUM * 3)
	{
		RWIntegrateIndirectArgs[DispatchThreadId.x] = (DispatchThreadId.x % 3 == 0) ? 0 : 1;
	}

	if (GroupThreadId.x < TILE_CLASSIFICATION_NUM)
	{
		SharedTileClassification[GroupThreadId.x] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(DispatchThreadId < (uint2)View.ViewSizeAndInvSize.xy))
	{
		FGBufferData GBufferData = GetGBufferDataUint(DispatchThreadId);

		if (GBufferData.ShadingModelID != SHADINGMODELID_UNLIT)
		{
			uint TileClassification = TILE_CLASSIFICATION_SIMPLE_DIFFUSE;

			if (GBufferData.ShadingModelID == SHADINGMODELID_HAIR)
			{
				TileClassification = TILE_CLASSIFICATION_SUPPORT_ALL;
			}
			else 
			{
				uint DiffuseIntegrationMethod = GetDiffuseIntegrationMethod(GBufferData);

				if (DiffuseIntegrationMethod == DIFFUSE_INTEGRATION_IMPORTANCE_SAMPLE_BRDF)
				{
					TileClassification = TILE_CLASSIFICATION_SUPPORT_IMPORTANCE_SAMPLE_BRDF;
				}

				float DiffuseLerp = GetDiffuseLerp(GBufferData.Roughness);

				if (DiffuseLerp < 1.0f || GBufferData.ShadingModelID == SHADINGMODELID_CLEAR_COAT)
				{
					TileClassification = TILE_CLASSIFICATION_SUPPORT_IMPORTANCE_SAMPLE_BRDF;
				}
			}

			SharedTileClassification[TileClassification] = 1;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	uint MaxTileClassification = 0xFF;

	UNROLL
	for (uint i = 0; i < TILE_CLASSIFICATION_NUM; i++)
	{
		if (SharedTileClassification[i] > 0)
		{
			MaxTileClassification = i;
		}
	}

	if (all(GroupThreadId == 0))
	{
		RWTileClassificationModes[GroupId] = MaxTileClassification;
	}

	// Clear tiles that the integration shader won't run on
	if (MaxTileClassification == 0xFF && all(DispatchThreadId < (uint2)View.ViewSizeAndInvSize.xy))
	{
		RWDiffuseIndirect[DispatchThreadId.xy] = 0;
		RWRoughSpecularIndirect[DispatchThreadId.xy] = 0;
	}
}

RWStructuredBuffer<uint> RWIntegrateTileData;
Texture2D<uint> TileClassificationModes;

uint2 ViewportTileDimensions;

groupshared uint SharedNumTiles[TILE_CLASSIFICATION_NUM];
groupshared uint SharedIntegrateTileData[TILE_CLASSIFICATION_NUM * THREADGROUP_SIZE];
groupshared uint SharedGlobalTileOffset[TILE_CLASSIFICATION_NUM];

[numthreads(THREADGROUP_SIZE, 1, 1)] 
void ScreenProbeTileClassificationBuildListsCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	//@todo - parallel version
	if (GroupThreadId == 0)
	{
		UNROLL
		for (uint i = 0; i < TILE_CLASSIFICATION_NUM; i++)
		{
			SharedNumTiles[i] = 0;
		}

		for (uint x = 0; x < THREADGROUP_SIZE; x++)
		{
			uint2 ThreadOffset = ZOrder2D(x, log2(8));
			uint2 TileCoordinate = GroupId * 8 + ThreadOffset;

			if (all(TileCoordinate < ViewportTileDimensions))
			{
				uint Mode = TileClassificationModes[TileCoordinate];

				if (Mode != 0xFF)
				{
					uint TileOffset = SharedNumTiles[Mode];
					uint PackedTileData = TileCoordinate.x | (TileCoordinate.y << 16);
					SharedIntegrateTileData[Mode * THREADGROUP_SIZE + TileOffset] = PackedTileData;
					SharedNumTiles[Mode] = TileOffset + 1;
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupThreadId < TILE_CLASSIFICATION_NUM)
	{
		uint Mode = GroupThreadId;
		InterlockedAdd(RWIntegrateIndirectArgs[Mode * 3], SharedNumTiles[Mode], SharedGlobalTileOffset[Mode]);
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint ModeIndex = 0; ModeIndex < TILE_CLASSIFICATION_NUM; ModeIndex++)
	{
		if (GroupThreadId < SharedNumTiles[ModeIndex])
		{
			RWIntegrateTileData[ModeIndex * ViewportTileDimensions.x * ViewportTileDimensions.y + SharedGlobalTileOffset[ModeIndex] + GroupThreadId] = SharedIntegrateTileData[ModeIndex * THREADGROUP_SIZE + GroupThreadId];
		}
	}
}

Texture2D<float3> ScreenProbeRadianceSHAmbient;
Texture2D<float4> ScreenProbeRadianceSHDirectional;
Texture2D<float3> ScreenProbeIrradianceWithBorder;

FThreeBandSHVectorRGB GetScreenProbeSH(uint2 ScreenProbeAtlasCoord, float InterpolationWeight)
{
	float3 AmbientVector = ScreenProbeRadianceSHAmbient[ScreenProbeAtlasCoord].xyz;

	float4 SHCoefficients0Red = ScreenProbeRadianceSHDirectional[uint2(ScreenProbeAtlasCoord.x + 0 * ScreenProbeAtlasViewSize.x, ScreenProbeAtlasCoord.y)];
	float4 SHCoefficients1Red = ScreenProbeRadianceSHDirectional[uint2(ScreenProbeAtlasCoord.x + 1 * ScreenProbeAtlasViewSize.x, ScreenProbeAtlasCoord.y)];
	float4 SHCoefficients0Green = ScreenProbeRadianceSHDirectional[uint2(ScreenProbeAtlasCoord.x + 2 * ScreenProbeAtlasViewSize.x, ScreenProbeAtlasCoord.y)];
	float4 SHCoefficients1Green = ScreenProbeRadianceSHDirectional[uint2(ScreenProbeAtlasCoord.x + 3 * ScreenProbeAtlasViewSize.x, ScreenProbeAtlasCoord.y)];
	float4 SHCoefficients0Blue = ScreenProbeRadianceSHDirectional[uint2(ScreenProbeAtlasCoord.x + 4 * ScreenProbeAtlasViewSize.x, ScreenProbeAtlasCoord.y)];
	float4 SHCoefficients1Blue = ScreenProbeRadianceSHDirectional[uint2(ScreenProbeAtlasCoord.x + 5 * ScreenProbeAtlasViewSize.x, ScreenProbeAtlasCoord.y)];

#if SH_QUANTIZE_DIRECTIONAL_COEFFICIENTS
	float4 SHDenormalizationScales0 = float4(
		0.488603f / 0.282095f, 
		0.488603f / 0.282095f, 
		0.488603f / 0.282095f, 
		1.092548f / 0.282095f);

	float4 SHDenormalizationScales1 = float4(
		1.092548f / 0.282095f,
		4.0f * 0.315392f / 0.282095f,
		1.092548f / 0.282095f,
		2.0f * 0.546274f / 0.282095f);

	SHCoefficients0Red = (SHCoefficients0Red * 2 - 1) * AmbientVector.x * SHDenormalizationScales0;
	SHCoefficients1Red = (SHCoefficients1Red * 2 - 1) * AmbientVector.x * SHDenormalizationScales1;
	SHCoefficients0Green = (SHCoefficients0Green * 2 - 1) * AmbientVector.y * SHDenormalizationScales0;
	SHCoefficients1Green = (SHCoefficients1Green * 2 - 1) * AmbientVector.y * SHDenormalizationScales1;
	SHCoefficients0Blue = (SHCoefficients0Blue * 2 - 1) * AmbientVector.z * SHDenormalizationScales0;
	SHCoefficients1Blue = (SHCoefficients1Blue * 2 - 1) * AmbientVector.z * SHDenormalizationScales1;
#endif

	FThreeBandSHVectorRGB LightingSH;
	LightingSH.R.V0 = float4(AmbientVector.x, SHCoefficients0Red.xyz) * InterpolationWeight;
	LightingSH.R.V1 = float4(SHCoefficients0Red.w, SHCoefficients1Red.xyz) * InterpolationWeight;
	LightingSH.R.V2 = SHCoefficients1Red.w * InterpolationWeight;
	LightingSH.G.V0 = float4(AmbientVector.y, SHCoefficients0Green.xyz) * InterpolationWeight;
	LightingSH.G.V1 = float4(SHCoefficients0Green.w, SHCoefficients1Green.xyz) * InterpolationWeight;
	LightingSH.G.V2 = SHCoefficients1Green.w * InterpolationWeight;
	LightingSH.B.V0 = float4(AmbientVector.z, SHCoefficients0Blue.xyz) * InterpolationWeight;
	LightingSH.B.V1 = float4(SHCoefficients0Blue.w, SHCoefficients1Blue.xyz) * InterpolationWeight;
	LightingSH.B.V2 = SHCoefficients1Blue.w * InterpolationWeight;

	return LightingSH;
}

float3 GetScreenProbeIrradiance(uint2 ScreenProbeAtlasCoord, float2 IrradianceProbeUV)
{
	float2 IrradianceProbeUVCoord = IrradianceProbeUV * IRRADIANCE_PROBE_RES + 1.0f;
	float2 AtlasUV = (ScreenProbeAtlasCoord * IRRADIANCE_PROBE_WITH_BORDER_RES + IrradianceProbeUVCoord) / (ScreenProbeAtlasBufferSize * IRRADIANCE_PROBE_WITH_BORDER_RES);
	return ScreenProbeIrradianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, AtlasUV, 0).xyz;
}

// Bias the important sampling of SampleBxDF(SHADING_TERM_SPECULAR, ....)
float4 BiasBSDFImportantSample(float4 E)
{
	float Bias = 1.0 - 0.1;

	E.y = (E.y - 0.5) * Bias + 0.5;

	return E;
}

Texture2D<float3> ScreenProbeRadianceWithBorder;
Texture2D<float3> ScreenProbeRadiance;

float3 InterpolateFromScreenProbes(float3 ConeDirection, float MipLevel, FScreenProbeSample ScreenProbeSample)
{
	float2 ProbeUV = UnitVectorToOctahedron(ConeDirection) * 0.5 + 0.5;

#define COMBINED_FACTORS 1
#if COMBINED_FACTORS
	float2 AtlasUVMul = SampleRadianceAtlasUVMul;
	float2 AtlasUVAdd = ProbeUV * SampleRadianceProbeUVMul + SampleRadianceProbeUVAdd;
#else
	float BorderSize = exp2(ScreenProbeGatherMaxMip);
	float2 ProbeCoord = ProbeUV * ScreenProbeGatherOctahedronResolution;		
	float2 InvBufferSize = 1.0f / (float2)(ScreenProbeGatherOctahedronResolutionWithBorder * ScreenProbeAtlasBufferSize);
	float2 AtlasUVMul = ScreenProbeGatherOctahedronResolutionWithBorder * InvBufferSize;
	float2 AtlasUVAdd = (ProbeCoord + BorderSize) * InvBufferSize;
#endif

	float2 UV0 = ScreenProbeSample.AtlasCoord[0] * AtlasUVMul + AtlasUVAdd;
	float3 InterpolatedRadiance = ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV0, MipLevel).xyz * ScreenProbeSample.Weights.x;

#if !STOCHASTIC_PROBE_INTERPOLATION
	float2 UV1 = ScreenProbeSample.AtlasCoord[1] * AtlasUVMul + AtlasUVAdd;
	InterpolatedRadiance += ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV1, MipLevel).xyz * ScreenProbeSample.Weights.y;

	float2 UV2 = ScreenProbeSample.AtlasCoord[2] * AtlasUVMul + AtlasUVAdd;
	InterpolatedRadiance += ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV2, MipLevel).xyz * ScreenProbeSample.Weights.z;

	float2 UV3 = ScreenProbeSample.AtlasCoord[3] * AtlasUVMul + AtlasUVAdd;
	InterpolatedRadiance += ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV3, MipLevel).xyz * ScreenProbeSample.Weights.w;
#endif

	return InterpolatedRadiance;
}

void DebugVisualizeScreenProbePlacement(uint2 SVPosition, inout float3 DiffuseIndirectOutput)
{
	uint2 ScreenTileCoord = GetScreenTileCoord(SVPosition);
	uint2 UniformScreenProbeScreenPosition = GetUniformScreenProbeScreenPosition(ScreenTileCoord);

	if (all(UniformScreenProbeScreenPosition == SVPosition) && GetScreenProbeDepth(ScreenTileCoord) >= 0)
	{
		DiffuseIndirectOutput = float3(200, 0, 200);
	}

	uint NumAdaptiveProbes = ScreenTileAdaptiveProbeHeader[ScreenTileCoord];

	for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
	{
		uint2 AdaptiveProbeCoord = GetAdaptiveProbeCoord(ScreenTileCoord, AdaptiveProbeListIndex);
		uint AdaptiveProbeIndex = ScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord];
		uint ScreenProbeIndex = AdaptiveProbeIndex + NumUniformScreenProbes;

		uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);

		if (all(ScreenProbeScreenPosition == SVPosition))
		{
			DiffuseIndirectOutput = float3(200, 0, 200);
		}
	}

	//DiffuseIndirectOutput = NumAdaptiveProbes / 10.0f;
}

float FullResolutionJitterWidth;

FBxDFSample SampleBxDFWrapper(const uint TermMask, FGBufferData GBuffer, float3 V, float4 E)
{
#if INTEGRATE_TILE_CLASSIFICATION_MODE == TILE_CLASSIFICATION_SIMPLE_DIFFUSE || INTEGRATE_TILE_CLASSIFICATION_MODE == TILE_CLASSIFICATION_SUPPORT_IMPORTANCE_SAMPLE_BRDF
	return SampleDefaultLitBxDF(TermMask, GBuffer, V, E);
#else
	return SampleBxDF(TermMask, GBuffer, V, E);
#endif
}

float3 EvaluateDiffuse(FScreenProbeSample ScreenProbeSample, float3 WorldNormal, float3 UnitBentNormal, float AO)
{
	float3 DiffuseLighting = 0.0f;

	#if PROBE_IRRADIANCE_FORMAT == PROBE_IRRADIANCE_FORMAT_SH3
	{
		FThreeBandSHVectorRGB LightingSH = GetScreenProbeSH(ScreenProbeSample.AtlasCoord[0], ScreenProbeSample.Weights.x);

		#if !STOCHASTIC_PROBE_INTERPOLATION
			LightingSH = AddSH(LightingSH, GetScreenProbeSH(ScreenProbeSample.AtlasCoord[1], ScreenProbeSample.Weights.y));
			LightingSH = AddSH(LightingSH, GetScreenProbeSH(ScreenProbeSample.AtlasCoord[2], ScreenProbeSample.Weights.z));
			LightingSH = AddSH(LightingSH, GetScreenProbeSH(ScreenProbeSample.AtlasCoord[3], ScreenProbeSample.Weights.w));
		#endif

		float3 ProbeLightingNormal = WorldNormal;

		#if SCREEN_SPACE_BENT_NORMAL 
			// Use more bent normal in occluded corners
			ProbeLightingNormal = normalize(lerp(UnitBentNormal, WorldNormal, AO));
		#endif

		float3 SHDiffuseLighting = EvaluateSHIrradiance(ProbeLightingNormal, 1 - AO, LightingSH);
		DiffuseLighting += 4 * PI * SHDiffuseLighting;
	}
	#else
	{
		float2 IrradianceProbeUV = UnitVectorToOctahedron(WorldNormal) * 0.5f + 0.5f;

		float3 Irradiance = GetScreenProbeIrradiance(ScreenProbeSample.AtlasCoord[0], IrradianceProbeUV) * ScreenProbeSample.Weights.x;

		#if !STOCHASTIC_PROBE_INTERPOLATION
			Irradiance += GetScreenProbeIrradiance(ScreenProbeSample.AtlasCoord[1], IrradianceProbeUV) * ScreenProbeSample.Weights.y;
			Irradiance += GetScreenProbeIrradiance(ScreenProbeSample.AtlasCoord[2], IrradianceProbeUV) * ScreenProbeSample.Weights.z;
			Irradiance += GetScreenProbeIrradiance(ScreenProbeSample.AtlasCoord[3], IrradianceProbeUV) * ScreenProbeSample.Weights.w;
		#endif

		DiffuseLighting += Irradiance;
	}
	#endif	

	return DiffuseLighting;
}

#define TONEMAP_DURING_INTEGRATION 1

float Luma(float3 Color) 
{
	// Rec 709 function for luma.
	return dot(Color, float3(0.2126f, 0.7152f, 0.0722f));
}

float3 TonemapLighting(float3 Lighting)
{
#if TONEMAP_DURING_INTEGRATION
	return Lighting / (1.0f + Luma(Lighting));
#else
	return Lighting;
#endif
}

float3 InverseTonemapLighting(float3 TonemappedLighting)
{
#if TONEMAP_DURING_INTEGRATION
	return TonemappedLighting / (1.0f - Luma(TonemappedLighting));
#else
	return TonemappedLighting;
#endif
}

#define TILE_CLASSIFICATION_DISABLED TILE_CLASSIFICATION_NUM

float MaxRoughnessToTrace;
float RoughnessFadeLength;

StructuredBuffer<uint> IntegrateTileData;

[numthreads(INTEGRATE_TILE_SIZE, INTEGRATE_TILE_SIZE, 1)]  
void ScreenProbeIntegrateCS(
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
#if INTEGRATE_TILE_CLASSIFICATION_MODE < TILE_CLASSIFICATION_DISABLED
	uint PackedTileData = IntegrateTileData[INTEGRATE_TILE_CLASSIFICATION_MODE * ViewportTileDimensions.x * ViewportTileDimensions.y + GroupId];
	uint2 TileCoord = uint2(PackedTileData & 0xFFFF, PackedTileData >> 16);
	DispatchThreadId = TileCoord * INTEGRATE_TILE_SIZE + GroupThreadId;
#endif

	float SceneDepth = CalcSceneDepth(DispatchThreadId);

	{
		FGBufferData GBufferData = GetGBufferDataUint(DispatchThreadId);
		
		if (GBufferData.ShadingModelID != SHADINGMODELID_UNLIT)
		{
			float2 ScreenUV = (DispatchThreadId + 0.5) * View.BufferSizeAndInvSize.zw;
			float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

			float2 NoiseOffset = 0.0f;

			if (FullResolutionJitterWidth > 0)
			{
				//@todo - expose fade distance
				float EffectiveJitterWidth = FullResolutionJitterWidth * lerp(1.0f, .5f, saturate((SceneDepth - 500.0f) / 500.0f));
				uint2 RandomSeed = Rand3DPCG16(int3(DispatchThreadId.xy, GENERAL_TEMPORAL_INDEX)).xy;
				float2 ScreenTileJitterE = Hammersley16(0, 1, RandomSeed);
				//float2 ScreenTileJitterE = EvalBlueNoise(DispatchThreadId.xy % BlueNoise.Dimensions.xy, RAY_DIRECTION_TEMPORAL_INDEX % BlueNoise.Dimensions.z).xy;
				float2 JitterNoiseOffset = (ScreenTileJitterE * 2 - 1) * ScreenProbeDownsampleFactor * EffectiveJitterWidth;

				float2 JitteredScreenUV = clamp(DispatchThreadId.xy + JitterNoiseOffset, View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy - 1) * View.BufferSizeAndInvSize.zw;
				float JitteredSceneDepth = CalcSceneDepth(JitteredScreenUV);

				float DepthWeight;

				{
					float4 ScenePlane = float4(GBufferData.WorldNormal, dot(WorldPosition, GBufferData.WorldNormal));
					float3 JitteredPosition = GetWorldPositionFromScreenUV(JitteredScreenUV, JitteredSceneDepth);
					float PlaneDistance = abs(dot(float4(JitteredPosition, -1), ScenePlane));
					float RelativeDepthDifference = PlaneDistance / SceneDepth;
					DepthWeight = exp2(-1000000.0f * (RelativeDepthDifference * RelativeDepthDifference));
				}

				if (DepthWeight > .01f)
				{
					NoiseOffset = JitterNoiseOffset;
				}
			}

			FScreenProbeSample ScreenProbeSample = (FScreenProbeSample) 0;

			CalculateUpsampleInterpolationWeights(
				DispatchThreadId.xy,
				NoiseOffset,
				WorldPosition,
				SceneDepth,
				GBufferData.WorldNormal,
				true,
				ScreenProbeSample);

			float Epsilon = .01f;
			ScreenProbeSample.Weights /= max(dot(ScreenProbeSample.Weights, 1), Epsilon);

			FScreenProbeSample StochasticScreenProbeSample = ScreenProbeSample;
			#if STOCHASTIC_PROBE_INTERPOLATION
			{
				// Pick a single best sample in a stochastic manner
				float RandomValue = InterleavedGradientNoise(DispatchThreadId.xy, GENERAL_TEMPORAL_INDEX);

				float WeightSum = dot(ScreenProbeSample.Weights, 1.0f);
				RandomValue *= WeightSum;

				uint2 PickedScreenProbeAtlasCoord = 0;
				if (RandomValue >= ScreenProbeSample.Weights[0] + ScreenProbeSample.Weights[1] + ScreenProbeSample.Weights[2])
				{
					PickedScreenProbeAtlasCoord = ScreenProbeSample.AtlasCoord[3];
				}
				else if (RandomValue >= ScreenProbeSample.Weights[0] + ScreenProbeSample.Weights[1])
				{
					PickedScreenProbeAtlasCoord = ScreenProbeSample.AtlasCoord[2];
				}
				else if (RandomValue >= ScreenProbeSample.Weights[0])
				{
					PickedScreenProbeAtlasCoord = ScreenProbeSample.AtlasCoord[1];
				}
				else
				{
					PickedScreenProbeAtlasCoord = ScreenProbeSample.AtlasCoord[0];
				}

				StochasticScreenProbeSample.AtlasCoord[0] = PickedScreenProbeAtlasCoord;
				StochasticScreenProbeSample.AtlasCoord[1] = PickedScreenProbeAtlasCoord;
				StochasticScreenProbeSample.AtlasCoord[2] = PickedScreenProbeAtlasCoord;
				StochasticScreenProbeSample.AtlasCoord[3] = PickedScreenProbeAtlasCoord;
				StochasticScreenProbeSample.Weights = float4(1.0f, 0.0f, 0.0f, 0.0f);
				ScreenProbeSample = StochasticScreenProbeSample;
			}
			#endif

			float3 V = normalize(LWCHackToFloat(PrimaryView.WorldCameraOrigin) - WorldPosition);
			float3 UnitBentNormal = GBufferData.WorldNormal;
			float AO = 1.0f;
			float3 DiffuseLighting = 0;

			#if SCREEN_SPACE_BENT_NORMAL 
			if (UseScreenBentNormal > 0)
			{
				float3 BentNormal = ScreenBentNormal[DispatchThreadId.xy].xyz * 2 - 1;
				AO = length(BentNormal);
				UnitBentNormal = AO > 0 ? BentNormal / AO : GBufferData.WorldNormal;
			}
			#endif

			uint DiffuseIntegrationMethod = GetDiffuseIntegrationMethod(GBufferData);

			if (DiffuseIntegrationMethod == DIFFUSE_INTEGRATION_SPHERICAL_HARMONIC)
			{
				DiffuseLighting += EvaluateDiffuse(ScreenProbeSample, GBufferData.WorldNormal, UnitBentNormal, AO);		
			}
#if INTEGRATE_TILE_CLASSIFICATION_MODE != TILE_CLASSIFICATION_SIMPLE_DIFFUSE
			else if (DiffuseIntegrationMethod == DIFFUSE_INTEGRATION_IMPORTANCE_SAMPLE_BRDF)
			{
				// This could be configurable if not for GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
				uint NumPixelSamples = INDIRECT_SAMPLE_COUNT;
				const uint TermMask = SHADING_TERM_DIFFUSE | SHADING_TERM_HAIR_R | SHADING_TERM_HAIR_TT | SHADING_TERM_HAIR_TRT;
				//@todo - calculate based on solid angle
				float DiffuseMipLevel = ScreenProbeGatherMaxMip;
				FSphericalGaussian HemisphereSG = Hemisphere_ToSphericalGaussian(GBufferData.WorldNormal);
				FSphericalGaussian VisibleSG = BentNormalAO_ToSphericalGaussian(UnitBentNormal, AO);

				for (uint PixelRayIndex = 0; PixelRayIndex < NumPixelSamples; PixelRayIndex += 1)
				{
					float4 E = ComputeIndirectLightingSampleE(DispatchThreadId.xy, PixelRayIndex, NumPixelSamples);
					FBxDFSample BxDFSample = SampleBxDFWrapper(TermMask, GBufferData, V, E);

					float3 InterpolatedRadiance = InterpolateFromScreenProbes(BxDFSample.L, DiffuseMipLevel, StochasticScreenProbeSample);

					#if GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
						// GetDiffuseIndirectSampleOcclusion in BasePassPixelShader encodes visibility bit using the same ComputeIndirectLightingSampleE
						bool bIsBentNormalOccluded = (GBufferData.DiffuseIndirectSampleOcclusion & (1 << PixelRayIndex)) != 0;
						float DirectionVisibility = bIsBentNormalOccluded ? 0 : 1;
					#else
						float DirectionVisibility = 1.0f;
					#endif

					#if SCREEN_SPACE_BENT_NORMAL
						float LVisibility = saturate(Evaluate(VisibleSG, BxDFSample.L) / Evaluate(HemisphereSG, BxDFSample.L));
						DirectionVisibility *= LVisibility;
					#endif

					DiffuseLighting += InterpolatedRadiance * BxDFSample.Weight * DirectionVisibility;
				}

				DiffuseLighting = DiffuseLighting * PI / ((float)NumPixelSamples * AO);

				#if GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
				{
					float MaterialAO = GBufferData.GBufferAO;
					DiffuseLighting *= AOMultiBounce(GBufferData.BaseColor, MaterialAO) * (MaterialAO > 0.0 ? rcp(MaterialAO) : 0.0);
				}
				#endif
			}
#endif
#if INTEGRATE_TILE_CLASSIFICATION_MODE == TILE_CLASSIFICATION_DISABLED
			else if (DiffuseIntegrationMethod == DIFFUSE_INTEGRATION_NUMERICAL_INTEGRAL)
			{
				float TotalWeight = 0;
				const float InvScreenProbeResolution = 1.0f / ScreenProbeGatherOctahedronResolution;
				float ScreenProbeResolutionFloat = ScreenProbeGatherOctahedronResolution;
				FSphericalGaussian HemisphereSG = Hemisphere_ToSphericalGaussian(GBufferData.WorldNormal);
				FSphericalGaussian VisibleSG = BentNormalAO_ToSphericalGaussian(UnitBentNormal, AO);

				for (float Y = 0; Y < ScreenProbeResolutionFloat; Y++)
				{
					for (float X = 0; X < ScreenProbeResolutionFloat; X++)
					{
						float2 ProbeTexelCenter = float2(0.5, 0.5);
						float2 ProbeUV = (float2(X, Y) + ProbeTexelCenter) * InvScreenProbeResolution;
						float3 WorldConeDirection = OctahedronToUnitVector(ProbeUV * 2.0 - 1.0);

						float NdotL = dot(WorldConeDirection, GBufferData.WorldNormal);

						if (NdotL > 0)
						{
							float SolidAngle = OctahedralSolidAngleLUT(ProbeUV, ScreenProbeGatherOctahedronResolution);

							#if 1
								float SampleWeight = NdotL * SolidAngle;
							#else
								FShadowTerms Shadow = { 1, 1, 1, InitHairTransmittanceData() };
								FDirectLighting BxDFSample = EvaluateBxDF(GBufferData, GBufferData.WorldNormal, V, WorldConeDirection, saturate(NdotL), Shadow);

								float3 SampleWeight = BxDFSample.Diffuse * SolidAngle;
							#endif
							
							float3 InterpolatedRadiance;

							uint2 ProbeCoord = uint2(X, Y);
							InterpolatedRadiance = ScreenProbeSample.Weights.x > 0 ? ScreenProbeRadiance.Load(int3(ScreenProbeSample.AtlasCoord[0] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * ScreenProbeSample.Weights.x : 0;
							
							if (ScreenProbeSample.Weights.y > 0)
							{
								InterpolatedRadiance += ScreenProbeRadiance.Load(int3(ScreenProbeSample.AtlasCoord[1] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * ScreenProbeSample.Weights.y;
							}
							if (ScreenProbeSample.Weights.z > 0)
							{
								InterpolatedRadiance += ScreenProbeRadiance.Load(int3(ScreenProbeSample.AtlasCoord[2] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * ScreenProbeSample.Weights.z;
							}
							if (ScreenProbeSample.Weights.w > 0)
							{
								InterpolatedRadiance += ScreenProbeRadiance.Load(int3(ScreenProbeSample.AtlasCoord[3] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * ScreenProbeSample.Weights.w;
							}
							float DirectionalOcclusion = 1.0f;

							#if SCREEN_SPACE_BENT_NORMAL
								float LVisibility = saturate(Evaluate(VisibleSG, WorldConeDirection) / Evaluate(HemisphereSG, WorldConeDirection));
								DirectionalOcclusion *= LVisibility;
							#endif

							DiffuseLighting += InterpolatedRadiance * SampleWeight * DirectionalOcclusion;
							TotalWeight += SampleWeight;
						}
					}
				}

				if (TotalWeight > 0)
				{
					DiffuseLighting = DiffuseLighting * PI / (TotalWeight * AO);
				}
			}
#endif
			bool bLightingIsValid = dot(StochasticScreenProbeSample.Weights, 1) > 1.0f - Epsilon;

			#if !GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
				DiffuseLighting *= AOMultiBounce(GBufferData.BaseColor, GBufferData.GBufferAO);
			#endif

			#if SCREEN_SPACE_BENT_NORMAL
			{
				DiffuseLighting *= DistantIlluminationRescale(GBufferData.BaseColor, AO);
			}
			#endif

			float LightingIsMoving = GetScreenProbeMoving(StochasticScreenProbeSample.AtlasCoord[0]) * StochasticScreenProbeSample.Weights.x;
			#if !STOCHASTIC_PROBE_INTERPOLATION
				LightingIsMoving += GetScreenProbeMoving(StochasticScreenProbeSample.AtlasCoord[1]) * StochasticScreenProbeSample.Weights.y;
				LightingIsMoving += GetScreenProbeMoving(StochasticScreenProbeSample.AtlasCoord[2]) * StochasticScreenProbeSample.Weights.z;
				LightingIsMoving += GetScreenProbeMoving(StochasticScreenProbeSample.AtlasCoord[3]) * StochasticScreenProbeSample.Weights.w;
			#endif

			float EncodedAlpha = (bLightingIsValid ? 1.0f : -1.0f) * max(LightingIsMoving, .001f);

			float3 DiffuseIndirectOutput = DiffuseLighting * (bLightingIsValid ? 1.0f : 0.0f) * Diffuse_Lambert(float3(1, 1, 1));

			#define DEBUG_VISUALIZE_PROBE_WORLD_SPEED 0
			#if DEBUG_VISUALIZE_PROBE_WORLD_SPEED
				float InterpolatedWorldSpeed = GetScreenProbeSpeed(ScreenProbeSample.AtlasCoord[0]) * StochasticScreenProbeSample.Weights.x
					+ GetScreenProbeSpeed(ScreenProbeSample.AtlasCoord[1]) * StochasticScreenProbeSample.Weights.y
					+ GetScreenProbeSpeed(ScreenProbeSample.AtlasCoord[2]) * StochasticScreenProbeSample.Weights.z
					+ GetScreenProbeSpeed(ScreenProbeSample.AtlasCoord[3]) * StochasticScreenProbeSample.Weights.w;

				DiffuseIndirectOutput = abs(InterpolatedWorldSpeed) / 2.0f;
			#endif

			#define DEBUG_VISUALIZE_SCREEN_PROBE_PLACEMENT 0
			#if DEBUG_VISUALIZE_SCREEN_PROBE_PLACEMENT
				DebugVisualizeScreenProbePlacement(DispatchThreadId, DiffuseIndirectOutput);
			#endif

			#define DEBUG_VISUALIZE_INVALID_UPSAMPLE 0
			#if DEBUG_VISUALIZE_INVALID_UPSAMPLE
				if (!bLightingIsValid)
				{
					DiffuseIndirectOutput = float3(10, 0, 0);
				}
			#endif

			#define DEBUG_VISUALIZE_TILE_CLASSIFICATION 0
			#if DEBUG_VISUALIZE_TILE_CLASSIFICATION
				float3 FastModeColor = float3(0, 1, 0);
				float3 SlowModeColor = float3(1, 0, 0);
				float3 TileClassificationColoring = lerp(FastModeColor, SlowModeColor, INTEGRATE_TILE_CLASSIFICATION_MODE / (float)(TILE_CLASSIFICATION_NUM - 1));
				DiffuseIndirectOutput = TileClassificationColoring;
			#endif

			// FDiffuseIndirectCompositePS applies DiffuseColor
			RWDiffuseIndirect[DispatchThreadId.xy] = float4(DiffuseIndirectOutput, EncodedAlpha);

			float3 SpecularLighting = 0;

			float DiffuseLerp = GetDiffuseLerp(GBufferData.Roughness);

#define DEBUG_COMPUTE_ROUGH_SPECULAR 1
#if DEBUG_COMPUTE_ROUGH_SPECULAR && INTEGRATE_TILE_CLASSIFICATION_MODE != TILE_CLASSIFICATION_SIMPLE_DIFFUSE

			uint NumSpecularSamples = 4;

			// Prevent NaNs from ImportanceSampleVisibleGGX
			GBufferData.Roughness = max(GBufferData.Roughness, .01f);

			float MinRoughnessForProbeImportanceSampling = MaxRoughnessToTrace - RoughnessFadeLength;

			if ((DiffuseLerp < 1.0f && GBufferData.Roughness >= MinRoughnessForProbeImportanceSampling) || GBufferData.ShadingModelID == SHADINGMODELID_CLEAR_COAT)
			{
				// Prevent low roughness values that we can't support through screen probes with acceptable quality, eg clearcoat with bottom layer roughness 0
				GBufferData.Roughness = max(GBufferData.Roughness, MaxRoughnessToTrace);
				// For clear coat materials, screen probes are always providing the bottom layer reflections
				GBufferData.WorldNormal = GetClearCoatBottomNormal(GBufferData, GBufferData.WorldNormal);

				//@todo - derive mip from cone angle from roughness
				
				// Approximation made to move out of inner loop
				float RayPDFForMip = 1.0f;
				float SolidAngleSample = 1.0 / (NumSpecularSamples * RayPDFForMip);
				float CosConeHalfAngle = 1.0 - SolidAngleSample / (2.0 * PI);
				float NumTexels = sqrt(1.0f - CosConeHalfAngle) * ScreenProbeGatherOctahedronResolution;
				float MipLevel = clamp(log2(NumTexels), 0, ScreenProbeGatherMaxMip);
				FSphericalGaussian HemisphereSG = Hemisphere_ToSphericalGaussian(GBufferData.WorldNormal);
				FSphericalGaussian VisibleSG = BentNormalAO_ToSphericalGaussian(UnitBentNormal, AO);

				for (uint TracingRayIndex = 0; TracingRayIndex < NumSpecularSamples; TracingRayIndex++)
				{
					float4 E = ComputeIndirectLightingSampleE(DispatchThreadId.xy, TracingRayIndex, NumSpecularSamples);
				
					E = BiasBSDFImportantSample(E);

					FBxDFSample BxDFSample = SampleBxDFWrapper(SHADING_TERM_SPECULAR, GBufferData, V, E);
					float3 InterpolatedRadiance = InterpolateFromScreenProbes(BxDFSample.L, MipLevel, StochasticScreenProbeSample);

					float DirectionVisibility = 1.0f;

					#if SCREEN_SPACE_BENT_NORMAL
						float LVisibility = saturate(Evaluate(VisibleSG, BxDFSample.L) / Evaluate(HemisphereSG, BxDFSample.L));
						DirectionVisibility *= LVisibility;
					#endif

					SpecularLighting += TonemapLighting(InterpolatedRadiance * BxDFSample.Weight * DirectionVisibility);
				}

				SpecularLighting = InverseTonemapLighting(SpecularLighting / (float)NumSpecularSamples);
			}

#endif
			//@todo - replace with SH fit of GGX
			SpecularLighting = lerp(SpecularLighting, DiffuseLighting / PI, DiffuseLerp);

			#if DEBUG_VISUALIZE_TILE_CLASSIFICATION
				SpecularLighting = TileClassificationColoring;
			#endif

			RWRoughSpecularIndirect[DispatchThreadId.xy] = SpecularLighting;
		}
		else
		{
			RWDiffuseIndirect[DispatchThreadId.xy] = 0;
			RWRoughSpecularIndirect[DispatchThreadId.xy] = 0;
		}
	}
}

RWTexture2D<float3> RWNewHistoryDiffuseIndirect;
RWTexture2D<float3> RWNewHistoryRoughSpecularIndirect;
RWTexture2D<UNORM float> RWNumHistoryFramesAccumulated;
RWTexture2D<UNORM float> RWNewHistoryFastUpdateMode;

Texture2D DiffuseIndirect;
Texture2D RoughSpecularIndirect;
Texture2D DiffuseIndirectHistory;
Texture2D RoughSpecularIndirectHistory;
Texture2D DiffuseIndirectDepthHistory;
Texture2D HistoryNumFramesAccumulated;
Texture2D FastUpdateModeHistory;
Texture2D NormalHistory;

float HistoryDistanceThreshold;

float4 HistoryScreenPositionScaleBias;
float4 HistoryUVToScreenPositionScaleBias;
float4 HistoryUVMinMax;
uint4 HistoryViewportMinMax;

float PrevSceneColorPreExposureCorrection;
float InvFractionOfLightingMovingForFastUpdateMode;
float MaxFastUpdateModeAmount;
float MaxFramesAccumulated;
float HistoryNormalCosThreshold;

static const int2 kOffsets3x3[8] =
{
	int2(-1, -1),
	int2( 0, -1),
	int2( 1, -1),
	int2(-1,  0),
	int2( 1,  0),
	int2(-1,  1),
	int2( 0,  1),
	int2( 1,  1),
};

float3 GetFilteredNeighborhoodLighting(
	Texture2D LightingTexture,
	uint2 ScreenCoord, 
	uint2 MinScreenCoord, 
	uint2 MaxScreenCoord,
	out bool bLightingIsValid)
{
	float3 FilteredLighting = 0;
	float TotalWeight = 0;

	for (uint NeighborId = 0; NeighborId < 8; NeighborId++)
	{
		int2 SampleOffset = kOffsets3x3[NeighborId];

		uint2 NeighborScreenCoord = ScreenCoord + SampleOffset;
		NeighborScreenCoord = clamp(NeighborScreenCoord, MinScreenCoord, MaxScreenCoord);

		float4 Lighting = LightingTexture[NeighborScreenCoord];
		bool bSampleLightingIsValid = Lighting.w > 0.0f;

		if (bSampleLightingIsValid)
		{
			FilteredLighting += Lighting.xyz;
			TotalWeight++;
		}
	}

	bLightingIsValid = TotalWeight > 0;
	return FilteredLighting /= max(TotalWeight, 1.0f);
}

float3 ClampHistory(
	Texture2D LightingTexture,
	uint2 ScreenCoord, 
	uint2 MinScreenCoord, 
	uint2 MaxScreenCoord,
	float3 NewLighting,
	float3 HistoryLighting)
{
	float3 NeighborMin = NewLighting;
	float3 NeighborMax = NewLighting;

	UNROLL
	for (uint NeighborId = 0; NeighborId < 8; NeighborId++)
	{
		int2 SampleOffset = kOffsets3x3[NeighborId];

		uint2 NeighborScreenCoord = ScreenCoord + SampleOffset;
		NeighborScreenCoord = clamp(NeighborScreenCoord, MinScreenCoord, MaxScreenCoord);

		float3 Lighting = LightingTexture[NeighborScreenCoord].xyz;
		NeighborMin = min(NeighborMin, Lighting.xyz);
		NeighborMax = max(NeighborMax, Lighting.xyz);
	}

	HistoryLighting = clamp(HistoryLighting, NeighborMin, NeighborMax);
	return HistoryLighting;
}

struct Bilinear
{
	float2 Origin;
	float2 Weights;
};

Bilinear GetBilinearFilter(float2 UV, float2 TextureSize)
{
	Bilinear Result;
	Result.Origin = floor(UV * TextureSize - .5f);
	Result.Weights = frac(UV * TextureSize - .5f);
	return Result;
}

float4 GetBilinearCustomWeights(Bilinear F, float4 CustomWeights)
{
	float4 Weights;
	Weights.x = (1.0f - F.Weights.x) * (1.0f - F.Weights.y);
	Weights.y = F.Weights.x * (1.0f - F.Weights.y);
	Weights.z = (1.0f - F.Weights.x) * F.Weights.y;
	Weights.w = F.Weights.x * F.Weights.y;
	return Weights * CustomWeights;
}

float3 WeightedAverage(float3 V00, float3 V10,  float3 V01,  float3 V11, float4 Weights)
{
	float3 Result = V00 * Weights.x + V10 * Weights.y + V01 * Weights.z + V11 * Weights.w;
	return Result / max(dot(Weights, 1), .00001f);
}

float WeightedAverage(float4 V, float4 Weights)
{	
	return dot(V, Weights) / max(dot(Weights, 1), .00001f);
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeTemporalReprojectionCS( 
	uint2 DispatchThreadId : SV_DispatchThreadID)
{
	float2 ScreenUV = (DispatchThreadId + 0.5f) * View.BufferSizeAndInvSize.zw;
	float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;

	float DeviceZ = SceneDepthTexture[DispatchThreadId].x;
	float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float3 HistoryScreenPosition = GetHistoryScreenPosition(ScreenPosition, ScreenUV, DeviceZ);

	float2 HistoryScreenUV = HistoryScreenPosition.xy * HistoryScreenPositionScaleBias.xy + HistoryScreenPositionScaleBias.wz;
	bool bHistoryWasOnscreen = all(HistoryScreenUV < HistoryUVMinMax.zw) && all(HistoryScreenUV > HistoryUVMinMax.xy);
	// Avoid reading NaNs outside the valid viewport, just setting the weight to 0 is not enough
	HistoryScreenUV = clamp(HistoryScreenUV, HistoryUVMinMax.xy, HistoryUVMinMax.zw);

	Bilinear BilinearFilterAtHistoryScreenUV = GetBilinearFilter(HistoryScreenUV, View.BufferSizeAndInvSize.xy);
	float2 HistoryGatherUV = (BilinearFilterAtHistoryScreenUV.Origin + 1.0f) * View.BufferSizeAndInvSize.zw;

	// Whether to disocclusion test each of the 4 neighboring texels in the history
	// This allows for much more reliable history, especially on foliage
#define ACCURATE_HISTORY_DISOCCLUSION 1
#if ACCURATE_HISTORY_DISOCCLUSION
	float4 HistoryDepthDeviceZ = DiffuseIndirectDepthHistory.GatherRed(GlobalPointClampedSampler, HistoryGatherUV).wzxy;
	float4 HistorySceneDepth = float4(ConvertFromDeviceZ(HistoryDepthDeviceZ.x), ConvertFromDeviceZ(HistoryDepthDeviceZ.y), ConvertFromDeviceZ(HistoryDepthDeviceZ.z), ConvertFromDeviceZ(HistoryDepthDeviceZ.w));
#else
	float4 HistorySceneDepth = ConvertFromDeviceZ(Texture2DSampleLevel(DiffuseIndirectDepthHistory, GlobalBilinearClampedSampler, HistoryScreenUV, 0).x).xxxx;
#endif

	FGBufferData GBufferData = GetGBufferDataUint(DispatchThreadId);
	float Noise = InterleavedGradientNoise(DispatchThreadId.xy, View.StateFrameIndexMod8);
	float DisocclusionDistanceThreshold = HistoryDistanceThreshold * lerp(.5f, 1.5f, Noise);
	float PrevSceneDepth = ConvertFromDeviceZ(HistoryScreenPosition.z);

	float2 TexelSize = View.BufferSizeAndInvSize.zw;
	float2 HistoryGatherUV00 = (BilinearFilterAtHistoryScreenUV.Origin + .5f) * TexelSize;

#define PLANE_DISOCCLUSION_WEIGHTS 0
#if PLANE_DISOCCLUSION_WEIGHTS
	float3 PrevTranslatedPrevWorldPosition = mul(float4(HistoryScreenPosition.xy * PrevSceneDepth, PrevSceneDepth, 1), View.PrevScreenToTranslatedWorld).xyz;
	float4 PrevTranslatedPrevScenePlane = float4(GBufferData.WorldNormal, dot(PrevTranslatedPrevWorldPosition, GBufferData.WorldNormal));

	float4 PlaneDistance;
	{
		float2 HistoryScreenPosition00 = HistoryGatherUV00 * HistoryUVToScreenPositionScaleBias.xy + HistoryUVToScreenPositionScaleBias.zw;
		float3 PrevTranslatedHistoryWorldPosition00 = mul(float4(HistoryScreenPosition00 * HistorySceneDepth.x, HistorySceneDepth.x, 1), View.PrevScreenToTranslatedWorld).xyz;
		PlaneDistance.x = abs(dot(float4(PrevTranslatedHistoryWorldPosition00, -1), PrevTranslatedPrevScenePlane));

		float2 HistoryScreenPosition10 = (HistoryGatherUV00 + float2(TexelSize.x, 0)) * HistoryUVToScreenPositionScaleBias.xy + HistoryUVToScreenPositionScaleBias.zw;
		float3 PrevTranslatedHistoryWorldPosition10 = mul(float4(HistoryScreenPosition10 * HistorySceneDepth.y, HistorySceneDepth.y, 1), View.PrevScreenToTranslatedWorld).xyz;
		PlaneDistance.y = abs(dot(float4(PrevTranslatedHistoryWorldPosition10, -1), PrevTranslatedPrevScenePlane));

		float2 HistoryScreenPosition01 = (HistoryGatherUV00 + float2(0, TexelSize.y)) * HistoryUVToScreenPositionScaleBias.xy + HistoryUVToScreenPositionScaleBias.zw;
		float3 PrevTranslatedHistoryWorldPosition01 = mul(float4(HistoryScreenPosition01 * HistorySceneDepth.z, HistorySceneDepth.z, 1), View.PrevScreenToTranslatedWorld).xyz;
		PlaneDistance.z = abs(dot(float4(PrevTranslatedHistoryWorldPosition01, -1), PrevTranslatedPrevScenePlane));

		float2 HistoryScreenPosition11 = (HistoryGatherUV00 + TexelSize) * HistoryUVToScreenPositionScaleBias.xy + HistoryUVToScreenPositionScaleBias.zw;
		float3 PrevTranslatedHistoryWorldPosition11 = mul(float4(HistoryScreenPosition11.xy * HistorySceneDepth.w, HistorySceneDepth.w, 1), View.PrevScreenToTranslatedWorld).xyz;
		PlaneDistance.w = abs(dot(float4(PrevTranslatedHistoryWorldPosition11, -1), PrevTranslatedPrevScenePlane));
	}
	
	float4 OcclusionWeights = PlaneDistance >= PrevSceneDepth * DisocclusionDistanceThreshold ? 1 : 0;
#else

	#define EXPAND_HISTORY_DISTANCE_THRESHOLD_FOR_JITTER 1
	#if EXPAND_HISTORY_DISTANCE_THRESHOLD_FOR_JITTER
		float3 TranslatedWorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToTranslatedWorld).xyz;
		float3 V = normalize(-TranslatedWorldPosition);
		// Raise the threshold at grazing angles to compensate for TAA jitter causing a depth mismatch dependent on the angle
		// This also introduces some ghosting around characters, needs a better solution
		DisocclusionDistanceThreshold /= clamp(saturate(dot(V, GBufferData.WorldNormal)), .1f, 1.0f); 
	#endif

	float4 DistanceToHistoryValue = abs(HistorySceneDepth - PrevSceneDepth);
	float4 OcclusionWeights = DistanceToHistoryValue >= PrevSceneDepth * DisocclusionDistanceThreshold ? 1 : 0;

#endif

	float4 OriginalOcclusionWeights = OcclusionWeights;

#if HISTORY_REJECT_BASED_ON_NORMAL
	float3 HistoryNormal00 = DecodeNormal(Texture2DSampleLevel(NormalHistory, GlobalPointClampedSampler, HistoryGatherUV00, 0).xyz);
	float3 HistoryNormal10 = DecodeNormal(Texture2DSampleLevel(NormalHistory, GlobalPointClampedSampler, HistoryGatherUV00 + float2(TexelSize.x, 0), 0).xyz);
	float3 HistoryNormal01 = DecodeNormal(Texture2DSampleLevel(NormalHistory, GlobalPointClampedSampler, HistoryGatherUV00 + float2(0, TexelSize.y), 0).xyz);
	float3 HistoryNormal11 = DecodeNormal(Texture2DSampleLevel(NormalHistory, GlobalPointClampedSampler, HistoryGatherUV00 + TexelSize, 0).xyz);

	float4 HistoryNormalWeights = float4(
		dot(HistoryNormal00, GBufferData.WorldNormal),
		dot(HistoryNormal10, GBufferData.WorldNormal),
		dot(HistoryNormal01, GBufferData.WorldNormal),
		dot(HistoryNormal11, GBufferData.WorldNormal)) < HistoryNormalCosThreshold ? 1.0f : 0.0f;

	OcclusionWeights = saturate(HistoryNormalWeights + OcclusionWeights);
#endif

	//@todo - calculate for each texel in the footprint to avoid tossing history around screen edges
	float4 VisibilityWeights = saturate((bHistoryWasOnscreen ? 1.0f : 0.0f) - OcclusionWeights);

	float4 NewDiffuseLighting = DiffuseIndirect[DispatchThreadId];
	bool bLightingIsValid = NewDiffuseLighting.w > 0.0f;
	float LightingIsMoving = abs(NewDiffuseLighting.w);

	if (!bLightingIsValid)
	{
		// Flood fill from valid neighbors as a last ditch effort for when ScreenProbe interpolation fails
		uint2 MinScreenCoord = uint2(0, 0);
		uint2 MaxScreenCoord = (uint2)(View.ViewSizeAndInvSize.xy - 1);
		NewDiffuseLighting.xyz = GetFilteredNeighborhoodLighting(DiffuseIndirect, DispatchThreadId, MinScreenCoord, MaxScreenCoord, bLightingIsValid);
	}

	if (!bLightingIsValid)
	{
		// Flood fill failed and we have no valid lighting this frame, force history
		VisibilityWeights = 1;
	}

	float4 FinalWeights = GetBilinearCustomWeights(BilinearFilterAtHistoryScreenUV, VisibilityWeights);

#if ACCURATE_HISTORY_DISOCCLUSION
	float3 HistoryDiffuseIndirect00 = Texture2DSampleLevel(DiffuseIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00, 0).xyz;
	float3 HistoryDiffuseIndirect10 = Texture2DSampleLevel(DiffuseIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00 + float2(TexelSize.x, 0), 0).xyz;
	float3 HistoryDiffuseIndirect01 = Texture2DSampleLevel(DiffuseIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00 + float2(0, TexelSize.y), 0).xyz;
	float3 HistoryDiffuseIndirect11 = Texture2DSampleLevel(DiffuseIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00 + TexelSize, 0).xyz;

	float3 HistoryDiffuseIndirect = WeightedAverage(HistoryDiffuseIndirect00, HistoryDiffuseIndirect10, HistoryDiffuseIndirect01, HistoryDiffuseIndirect11, FinalWeights) * PrevSceneColorPreExposureCorrection;

	float3 HistoryRoughSpecularIndirect00 = Texture2DSampleLevel(RoughSpecularIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00, 0).xyz;
	float3 HistoryRoughSpecularIndirect10 = Texture2DSampleLevel(RoughSpecularIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00 + float2(TexelSize.x, 0), 0).xyz;
	float3 HistoryRoughSpecularIndirect01 = Texture2DSampleLevel(RoughSpecularIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00 + float2(0, TexelSize.y), 0).xyz;
	float3 HistoryRoughSpecularIndirect11 = Texture2DSampleLevel(RoughSpecularIndirectHistory, GlobalPointClampedSampler, HistoryGatherUV00 + TexelSize, 0).xyz;

	float3 HistoryRoughSpecularIndirect = WeightedAverage(HistoryRoughSpecularIndirect00, HistoryRoughSpecularIndirect10, HistoryRoughSpecularIndirect01, HistoryRoughSpecularIndirect11, FinalWeights) * PrevSceneColorPreExposureCorrection;
#else
	float3 HistoryDiffuseIndirect = Texture2DSampleLevel(DiffuseIndirectHistory, GlobalBilinearClampedSampler, HistoryScreenUV, 0).xyz * PrevSceneColorPreExposureCorrection;
	float3 HistoryRoughSpecularIndirect = Texture2DSampleLevel(RoughSpecularIndirectHistory, GlobalBilinearClampedSampler, HistoryScreenUV, 0).xyz * PrevSceneColorPreExposureCorrection;
#endif

	float4 NumFramesAccumulatedNeighborhood = HistoryNumFramesAccumulated.GatherRed(GlobalPointClampedSampler, HistoryGatherUV).wzxy * MaxFramesAccumulated;
	NumFramesAccumulatedNeighborhood = min(NumFramesAccumulatedNeighborhood + 1.0f, MaxFramesAccumulated);
	float NumFramesAccumulated = WeightedAverage(NumFramesAccumulatedNeighborhood, FinalWeights);

	float FastUpdateModeAmount = saturate(LightingIsMoving * InvFractionOfLightingMovingForFastUpdateMode);
	FastUpdateModeAmount = saturate(min((FastUpdateModeAmount - .2f) / .8f, MaxFastUpdateModeAmount));

	{
		RWNewHistoryFastUpdateMode[DispatchThreadId] = FastUpdateModeAmount;
		float FastUpdateModeHistoryValue = WeightedAverage(FastUpdateModeHistory.GatherRed(GlobalPointClampedSampler, HistoryGatherUV).wzxy, FinalWeights);
		// Stabilizes the calculated value, and speeds up lighting change propagation around where the moving object was last frame
		FastUpdateModeAmount = max(FastUpdateModeAmount, FastUpdateModeHistoryValue);
	}
	
	float NewNumFramesAccumulated = NumFramesAccumulated;
	NewNumFramesAccumulated = min(NewNumFramesAccumulated, (1.0f - FastUpdateModeAmount) * MaxFramesAccumulated);
	NewNumFramesAccumulated = bHistoryWasOnscreen ? NewNumFramesAccumulated : 0;

#if !ACCURATE_HISTORY_DISOCCLUSION
	if (VisibilityWeights.x < .01f)
	{
		NewNumFramesAccumulated = 0;
	}
#endif

	float3 NewRoughSpecularLighting = RoughSpecularIndirect[DispatchThreadId].xyz;

#if FAST_UPDATE_MODE_NEIGHBORHOOD_CLAMP
	if (FastUpdateModeAmount > 0.0f)
	{
		uint2 MinScreenCoord = uint2(0, 0);
		uint2 MaxScreenCoord = (uint2)(View.ViewSizeAndInvSize.xy - 1);
		HistoryDiffuseIndirect = ClampHistory(DiffuseIndirect, DispatchThreadId, MinScreenCoord, MaxScreenCoord, NewDiffuseLighting.xyz, HistoryDiffuseIndirect);
		HistoryRoughSpecularIndirect = ClampHistory(RoughSpecularIndirect, DispatchThreadId, MinScreenCoord, MaxScreenCoord, NewRoughSpecularLighting, HistoryRoughSpecularIndirect);
	}
#endif

	float Alpha = 1.0f / (1.0f + NewNumFramesAccumulated);
	float3 OutDiffuseIndirect = lerp(HistoryDiffuseIndirect, NewDiffuseLighting.xyz, Alpha);
	float3 OutRoughSpecularIndirect = lerp(HistoryRoughSpecularIndirect, NewRoughSpecularLighting, Alpha);

	// Debug visualizations
	//OutRoughSpecularIndirect.xyz = OutDiffuseIndirect.xyz = bHistoryWasOnscreen ? (dot(VisibilityWeights, 1) > 0.0f) : 0.0f;
	//OutRoughSpecularIndirect.xyz = OutDiffuseIndirect.xyz = FastUpdateModeAmount; 
	//if (!bLightingIsValid) { OutRoughSpecularIndirect.xyz = OutDiffuseIndirect.xyz = float3(1, 0, 0); }
	//OutRoughSpecularIndirect.xyz = OutDiffuseIndirect.xyz = bHistoryWasOnscreen ? saturate(HistoryNormalWeights.xyz - OriginalOcclusionWeights.xyz) : 0.0f;

	OutDiffuseIndirect.rgb = -min(-OutDiffuseIndirect.rgb, 0.0f);
	OutRoughSpecularIndirect.rgb = -min(-OutRoughSpecularIndirect.rgb, 0.0f);

	RWNewHistoryDiffuseIndirect[DispatchThreadId] = OutDiffuseIndirect;
	RWNewHistoryRoughSpecularIndirect[DispatchThreadId] = OutRoughSpecularIndirect;
	RWNumHistoryFramesAccumulated[DispatchThreadId] = NewNumFramesAccumulated / MaxFramesAccumulated;
}

RWTexture2D<float> RWCompressedDepthBufferOutput;
RWTexture2D<uint> RWCompressedShadingModelOutput;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void GenerateCompressedGBuffer( 
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	uint2 PixelCoord = GroupId * THREADGROUP_SIZE + GroupThreadId;
	float2 BufferUV = (PixelCoord + View.ViewRectMin.xy + 0.5f) * View.BufferSizeAndInvSize.zw;
	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);

	RWCompressedDepthBufferOutput[PixelCoord] = ConvertToDeviceZ(GBuffer.Depth);
	RWCompressedShadingModelOutput[PixelCoord] = GBuffer.ShadingModelID;
}
