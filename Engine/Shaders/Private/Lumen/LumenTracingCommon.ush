// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenTracingCommon.ush
=============================================================================*/

#pragma once

#include "../ReflectionEnvironmentShared.ush"
#include "../BRDF.ush"
#include "../FastMath.ush"
#include "../SHCommon.ush"
#define DISTANCE_FIELD_IN_VIEW_UB 1
#include "../GlobalDistanceFieldShared.ush"
#include "../GlobalDistanceFieldUtils.ush"
#include "../DistanceFieldLightingShared.ush"
#define USE_GLOBAL_GPU_SCENE_DATA 1
#include "../SceneData.ush"
#include "LumenSurfaceCacheSampling.ush"

#ifndef VISIBILITY_ONLY_TRACE
	#define VISIBILITY_ONLY_TRACE 0
#endif

#ifndef DEPTH_WEIGHTED_OIT_32_BIT
	#define DEPTH_WEIGHTED_OIT_32_BIT 1
#endif

#ifndef ENABLE_DYNAMIC_SKY_LIGHT
	#define ENABLE_DYNAMIC_SKY_LIGHT 1
#endif

#ifndef SDF_TRACING_TRAVERSE_MIPS
	#define SDF_TRACING_TRAVERSE_MIPS 0
#endif

#ifndef SCENE_TRACE_MESH_SDFS
	#define SCENE_TRACE_MESH_SDFS 1
#endif

#ifndef SCENE_TRACE_HEIGHTFIELDS
	#define SCENE_TRACE_HEIGHTFIELDS 0
#endif

#define SCENE_TRACE_VOXELS 1

#define MIN_flt			(1.175494351e-38F)			/* min positive value */

#if CARD_TRACE_DEPTH_WEIGHTED_OIT

class FCardTraceBlendState
{
	float4 LightingAndOpacity;
	float Revealage;
	float NumSteps;
	float NumOverlaps;
	float OpaqueHitDistance;

	void Initialize(float MaxTraceDistance)
	{
		LightingAndOpacity = 0;
		Revealage = 1;
		NumSteps = 0;
		NumOverlaps = 0;
		OpaqueHitDistance = MaxTraceDistance;
	}

	float ComputeDepthWeight(float InDepth, float InOpacity)
	{
#if DEPTH_WEIGHTED_OIT_32_BIT
		// From Weighted Blended Order-Independent Transparency
		//@todo - make full use of 32 bit fp, original functions were crafted for 16 bit fp render targets but we are using shader temporaries
		//@todo - try 64 bit fp
	#define HEURISTIC 2
	#if HEURISTIC == 0
		float A = InDepth / 50.0f;
		float B = InDepth / 2000.0f;
		float B2 = B * B;
		float B6 = B2 * B2 * B2;
		return InOpacity * max(.01f, min(10000000.0f, 10.0f / (.00001f + A * A + B6)));
	#elif HEURISTIC == 1
		float ZNear = 10.0f;
		float ZFar = 100000.0f;
		float D = saturate(((ZNear * ZFar) / InDepth - ZFar) / (ZNear - ZFar));
		float InvD = 1 - D;
		return InOpacity * max(.01f, 1000000.0f * InvD * InvD * InvD);
	#elif HEURISTIC == 2
		float a = min(8 * InOpacity, 1) + .01f;
		float ZNear = .5f;
		float ZFar = 100000.0f;
		// Clamp depth to prevent black lighting
		InDepth = min(InDepth, .9f * (ZFar - ZNear));
		float z = saturate(ZFar / (ZFar - ZNear) - (ZFar * ZNear) / (InDepth * (ZFar - ZNear)));
		float b = 1 - z;
		float b2 = b * b;
		float b4 = b2 * b2;
		return min(10000 * b4 * b4, 30000) * a * a * a;
	#endif
#else
		// 16 bit fp version
		float a = min(8 * InOpacity, 1) + .01f;
		float ZNear = .5f;
		float ZFar = 100000.0f;
		// Clamp depth to prevent black lighting
		InDepth = min(InDepth, .9f * (ZFar - ZNear));
		float z = saturate(ZFar / (ZFar - ZNear) - (ZFar * ZNear) / (InDepth * (ZFar - ZNear)));
		float b = 1 - z;
		return min(10000 * b * b * b + 5, 20) * a * a * a;
#endif
	}

	void AddLighting(float3 InLighting, float InOpacity, float InDepth)
	{
		float4 WeightedLighting = float4(InLighting * InOpacity, InOpacity) * ComputeDepthWeight(InDepth, InOpacity);
		LightingAndOpacity += WeightedLighting;
		Revealage *= (1 - InOpacity);
	}

	void RegisterStep(uint NewSteps)
	{
		NumSteps += NewSteps;
	}

	void RegisterOpaqueHit(float Distance)
	{
		OpaqueHitDistance = Distance;
	}

	bool HasRemainingVisibility(float MaxTraceDistance)
	{
		return OpaqueHitDistance >= MaxTraceDistance;
	}

	void AddCardTrace(FCardTraceBlendState InBlendState)
	{
		LightingAndOpacity += InBlendState.LightingAndOpacity;
		Revealage *= InBlendState.Revealage;
		NumSteps += InBlendState.NumSteps;
		OpaqueHitDistance = min(OpaqueHitDistance, InBlendState.OpaqueHitDistance);
		NumOverlaps++;
	}

	float3 GetFinalLighting()
	{
		float ClampedWeightedOpacity = max(LightingAndOpacity.a, MIN_flt);
		return LightingAndOpacity.rgb / ClampedWeightedOpacity * (1 - Revealage);
	}

	float4 GetLightingAndOpacity()
	{
		return LightingAndOpacity;
	}

	float GetTransparency()
	{
		return Revealage;
	}
};

#else

class FCardTraceBlendState
{
	float4 LightingAndOpacity;
	float NumSteps;
	float OpaqueHitDistance;
	float NumOverlaps;

	void Initialize(float MaxTraceDistance)
	{
		LightingAndOpacity = 0;
		NumSteps = 0;
		NumOverlaps = 0;
		OpaqueHitDistance = MaxTraceDistance;
	}

	void AddLighting(float3 InLighting, float InOpacity, float InDepth)
	{
		if (InDepth < OpaqueHitDistance)
		{
			LightingAndOpacity.xyz = InLighting;
			LightingAndOpacity.w = InOpacity;
			OpaqueHitDistance = InDepth;
		}
	}

	void RegisterStep(uint NewSteps)
	{
		NumSteps += NewSteps;
	}

	void RegisterOpaqueHit(float Distance)
	{
		// This is done in AddLighting
		//OpaqueHitDistance = Distance;
	}

	bool HasRemainingVisibility(float MaxTraceDistance)
	{
		return OpaqueHitDistance >= MaxTraceDistance;
	}

	void AddCardTrace(FCardTraceBlendState InBlendState)
	{
		LightingAndOpacity.xyz += InBlendState.LightingAndOpacity.xyz;
		LightingAndOpacity.w = max(LightingAndOpacity.w, InBlendState.LightingAndOpacity.w);
		NumSteps += InBlendState.NumSteps;
		OpaqueHitDistance = min(OpaqueHitDistance, InBlendState.OpaqueHitDistance);
	}

	float3 GetFinalLighting()
	{
		return LightingAndOpacity.xyz;
	}

	float4 GetLightingAndOpacity()
	{
		return LightingAndOpacity;
	}

	float GetTransparency()
	{
		return 1.0f - LightingAndOpacity.w;
	}
};

#endif

//https://iquilezles.org/www/articles/smin/smin.htm
float SmoothMin2( float a, float b, float k )
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return lerp( b, a, h ) - k*h*(1.0-h);
}

float ComputeBorderFadeDistance(float2 BoxMin, float2 BoxMax, float2 InPoint)
{
	float2 DistancesToMin = max(InPoint - BoxMin, 0);
	float2 DistancesToMax = max(BoxMax - InPoint, 0);
	float2 ClosestDistances = min(DistancesToMin, DistancesToMax);
	return SmoothMin2(ClosestDistances.x, ClosestDistances.y, 100.0f);
}

#define TRACING_ATLAS_SAMPLER GlobalBilinearClampedSampler

struct FConeTraceInput
{
	float3 ConeOrigin;
	float3 ConeDirection;
	
	float ConeAngle;
	float TanConeAngle;

	float ConeStartRadius;
	float MinSampleRadius;
	float MinTraceDistance;
	float MaxTraceDistance;

	float StepFactor;
	float VoxelStepFactor;
	float VoxelTraceStartDistance;
	float SDFStepFactor;
	bool bBlackOutSteepIntersections;
	bool bExpandSurfaceUsingRayTimeInsteadOfMaxDistance;
	float InitialMaxDistance;

	// Used for dithering
	uint2 ScreenCoord;

	// Whether to use epsilon trace (skip back face hits over initial short distance) for heightfield tracing
	bool bUseEpsilonTraceForHeightfields;

	// Whether to sample high res surface cache data or low res always resident pages
	bool bHiResSurface;

	bool bCalculateHitVelocity;

	// Mesh SDF traces
	uint NumMeshSDFs;
	uint MeshSDFStartOffset;
	uint MeshSDFBitmaskStartOffset;
	float CardInterpolateInfluenceRadius;

	// Heightfield traces
	uint NumHeightfields;
	uint HeightfieldStartOffset;

	void Setup(
		float3 InConeOrigin,
		float3 InConeDirection,
		float InConeAngle,
		float InMinSampleRadius,
		float InMinTraceDistance,
		float InMaxTraceDistance,
		float InStepFactor)
	{
		ConeOrigin = InConeOrigin;
		ConeDirection = InConeDirection;
		ConeAngle = InConeAngle;
		TanConeAngle = tan(ConeAngle);
		ConeStartRadius = 0;
		MinSampleRadius = InMinSampleRadius;
		MinTraceDistance = InMinTraceDistance;
		MaxTraceDistance = InMaxTraceDistance;
		StepFactor = InStepFactor;
		VoxelStepFactor = .7f;
		VoxelTraceStartDistance = InMaxTraceDistance;

		// The global SDF often overestimates due to the way distances outside of an object SDF are calculated, can be corrected by stepping slower, but increases trace cost
		SDFStepFactor = 1;
		bBlackOutSteepIntersections = false;
		bExpandSurfaceUsingRayTimeInsteadOfMaxDistance = true;
		InitialMaxDistance = 0;

		ScreenCoord = uint2(0, 0);
		bHiResSurface = false;
		bCalculateHitVelocity = false;

		bUseEpsilonTraceForHeightfields = true;
	}
};

struct FConeTraceResult
{
#if !VISIBILITY_ONLY_TRACE
	float3 Lighting;
#endif
	float Transparency;
	float NumSteps;
	float NumOverlaps;
	float OpaqueHitDistance;
	float ExpandSurfaceAmount;
	float3 Debug;
	float3 WorldVelocity;
};

void ConeTraceSingleLumenCard(
	FConeTraceInput TraceInput,
	uint CardIndex,
	inout float3 Debug,
	inout float OutTraceEndDistance,
	inout FCardTraceBlendState CardTraceBlendState)
{
	FLumenCardData LumenCardData = GetLumenCardData(CardIndex);

	float3 LocalConeOrigin = mul(TraceInput.ConeOrigin - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);
	float3 LocalConeDirection = mul(TraceInput.ConeDirection, LumenCardData.WorldToLocalRotation);
	float3 LocalTraceEnd = LocalConeOrigin + LocalConeDirection * TraceInput.MaxTraceDistance;

	float2 IntersectionRange = LineBoxIntersect(LocalConeOrigin, LocalTraceEnd, -LumenCardData.LocalExtent, LumenCardData.LocalExtent);
	IntersectionRange.x = max(IntersectionRange.x, TraceInput.MinTraceDistance / TraceInput.MaxTraceDistance);
	OutTraceEndDistance = IntersectionRange.y * TraceInput.MaxTraceDistance;

	if (IntersectionRange.y > IntersectionRange.x
		&& LumenCardData.bVisible)
	{
		// #lumen_todo: restore after a distant scene rewrite
/*
		{
			FCardTraceBlendState ConeStepBlendState;
			ConeStepBlendState.Initialize(TraceInput.MaxTraceDistance);

			float StepTime = IntersectionRange.x * TraceInput.MaxTraceDistance;
			float3 SamplePosition = LocalCoreveneOrigin + StepTime * LocalConeDirection;
			float TraceEndDistance = IntersectionRange.y * TraceInput.MaxTraceDistance;

			float IntersectionLength = (IntersectionRange.y - IntersectionRange.x) * TraceInput.MaxTraceDistance;
			float MinStepSize = IntersectionLength / (float)LumenCardScene.MaxConeSteps;

			float PreviousStepTime = StepTime;
			float3 PreviousSamplePosition = SamplePosition;
			// Magic value to prevent linear intersection approximation on first step
			float PreviousHeightfieldZ = -2;

			bool bClampedToEnd = false;
			bool bFoundSurface = false;
			bool bRayAboveSurface = false;
			float IntersectionStepTime = 0;
			float2 IntersectionSamplePositionXY = SamplePosition.xy;
			float IntersectionSlope = 0;

			uint NumStepsPerLoop = 4;
			for (uint StepIndex = 0; StepIndex < LumenCardScene.MaxConeSteps && StepTime < TraceEndDistance; StepIndex += NumStepsPerLoop)
			{
				float SampleRadius = max(TraceInput.ConeStartRadius + TraceInput.TanConeAngle * StepTime, TraceInput.MinSampleRadius);
				float StepSize = max(SampleRadius * TraceInput.StepFactor, MinStepSize);
				float TraceClampDistance = TraceEndDistance - StepSize * .0001f;

				float DepthMip;
				float2 DepthValidRegionScale;
				CalculateMip(SampleRadius, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, DepthMip, DepthValidRegionScale);

				float3 SamplePosition1 = LocalConeOrigin + min(StepTime + 0 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition2 = LocalConeOrigin + min(StepTime + 1 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition3 = LocalConeOrigin + min(StepTime + 2 * StepSize, TraceClampDistance) * LocalConeDirection;
				float3 SamplePosition4 = LocalConeOrigin + min(StepTime + 3 * StepSize, TraceClampDistance) * LocalConeDirection;

				float2 DepthAtlasUV1 = CalculateAtlasUV(SamplePosition1.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV2 = CalculateAtlasUV(SamplePosition2.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV3 = CalculateAtlasUV(SamplePosition3.xy, DepthValidRegionScale, LumenCardData);
				float2 DepthAtlasUV4 = CalculateAtlasUV(SamplePosition4.xy, DepthValidRegionScale, LumenCardData);

				float Depth1 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV1, DepthMip).x;
				float Depth2 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV2, DepthMip).x;
				float Depth3 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV3, DepthMip).x;
				float Depth4 = Texture2DSampleLevel(DepthAtlas, TRACING_ATLAS_SAMPLER, DepthAtlasUV4, DepthMip).x;

				float HeightfieldZ1 = LumenCardData.LocalExtent.z - Depth1 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ2 = LumenCardData.LocalExtent.z - Depth2 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ3 = LumenCardData.LocalExtent.z - Depth3 * 2 * LumenCardData.LocalExtent.z;
				float HeightfieldZ4 = LumenCardData.LocalExtent.z - Depth4 * 2 * LumenCardData.LocalExtent.z;

				ConeStepBlendState.RegisterStep(NumStepsPerLoop);

				bool4 HeightfieldHit = bool4(
					SamplePosition1.z < HeightfieldZ1,
					SamplePosition2.z < HeightfieldZ2,
					SamplePosition3.z < HeightfieldZ3,
					SamplePosition4.z < HeightfieldZ4);

				bool bRayBelowHeightfield = any(HeightfieldHit);
				bool bRayWasAboveSurface = bRayAboveSurface;

				if (!bRayBelowHeightfield)
				{
					bRayAboveSurface = true;
				}

				// Traces which started below the heightfield have to get above before they can register a hit
				if (bRayBelowHeightfield && bRayWasAboveSurface)
				{
					float HeightfieldZ;
					if (HeightfieldHit.x)
					{
						SamplePosition = SamplePosition1;
						HeightfieldZ = HeightfieldZ1;
						StepTime = StepTime + 0 * StepSize;
					}
					else if (HeightfieldHit.y)
					{
						PreviousSamplePosition = SamplePosition1;
						PreviousHeightfieldZ = HeightfieldZ1;
						PreviousStepTime = StepTime + 0 * StepSize;

						SamplePosition = SamplePosition2;
						HeightfieldZ = HeightfieldZ2;
						StepTime = StepTime + 1 * StepSize;
					}
					else if (HeightfieldHit.z)
					{
						PreviousSamplePosition = SamplePosition2;
						PreviousHeightfieldZ = HeightfieldZ2;
						PreviousStepTime = StepTime + 1 * StepSize;

						SamplePosition = SamplePosition3;
						HeightfieldZ = HeightfieldZ3;
						StepTime = StepTime + 2 * StepSize;
					}
					else
					{
						PreviousSamplePosition = SamplePosition3;
						PreviousHeightfieldZ = HeightfieldZ3;
						PreviousStepTime = StepTime + 2 * StepSize;

						SamplePosition = SamplePosition4;
						HeightfieldZ = HeightfieldZ4;
						StepTime = StepTime + 3 * StepSize;
					}

					StepTime = min(StepTime, TraceClampDistance);

					if (PreviousHeightfieldZ != -2)
					{
						// Construct a linear approximation of both the SamplePosition z and heightfield z between the previous step and this step: y = m * x + b
						// SamplePosition z linear approximation:
						// y = (SamplePosition.z - PreviousSampleZ) / (StepTime - PreviousStepTime) * (x - PreviousStepTime) + PreviousSampleZ
						// Heightfield z linear approximation:
						// y = (HeightfieldZ - PreviousHeightfieldZ) / (StepTime - PreviousStepTime) * (x - PreviousStepTime) + PreviousHeightfieldZ 

						// Solve for x where they intersect
						IntersectionStepTime = PreviousStepTime + ((PreviousSamplePosition.z - PreviousHeightfieldZ) * (StepTime - PreviousStepTime)) / (HeightfieldZ - PreviousHeightfieldZ + PreviousSamplePosition.z - SamplePosition.z);

						float2 LocalPositionSlopeXY = (SamplePosition.xy - PreviousSamplePosition.xy) / (StepTime - PreviousStepTime);
						IntersectionSamplePositionXY = LocalPositionSlopeXY * (IntersectionStepTime - PreviousStepTime) + PreviousSamplePosition.xy;

						IntersectionSlope = abs(PreviousHeightfieldZ - HeightfieldZ) / max(length(PreviousSamplePosition.xy - SamplePosition.xy), .0001f);

						PreviousHeightfieldZ = -2;
						bFoundSurface = true;
					}
					break;
				}

				PreviousStepTime = StepTime + 3 * StepSize;
				PreviousSamplePosition = SamplePosition4;
				PreviousHeightfieldZ = HeightfieldZ4;
				StepTime += 4 * StepSize;

				if (StepTime >= TraceEndDistance && !bClampedToEnd)
				{
					bClampedToEnd = true;
					// Stop the last step just before the intersection end, since the linear approximation needs to step past the surface to detect a hit, without terminating the loop
					StepTime = TraceClampDistance;
				}
			}

			if (bFoundSurface)
			{
				float IntersectionSampleRadius = TraceInput.ConeStartRadius + TraceInput.TanConeAngle * IntersectionStepTime;

				float MaxMip;
				float2 ValidRegionScale;
				CalculateMip(IntersectionSampleRadius, LumenCardData, LumenCardData.LocalExtent, LumenCardData.MaxMip, MaxMip, ValidRegionScale);

				float2 IntersectionAtlasUV = CalculateAtlasUV(IntersectionSamplePositionXY, ValidRegionScale, LumenCardData);

				float DistanceToSurface = 0;
				float ConeIntersectSurface = saturate(DistanceToSurface / IntersectionSampleRadius);
				float ConeVisibility = ConeIntersectSurface;

				float MaxDistanceFade = 1; // saturate((TraceInput.MaxTraceDistance - IntersectionStepTime) * TraceInput.InvMaxDistanceFadeLength);

				ConeStepBlendState.RegisterOpaqueHit(IntersectionStepTime);
				OutTraceEndDistance = IntersectionStepTime;

				float Opacity = Texture2DSampleLevel(OpacityAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).x;
				float ConeOcclusion = (1.0f - ConeVisibility) * Opacity * MaxDistanceFade;

				#if VISIBILITY_ONLY_TRACE
					float3 StepLighting = 0;
				#else
					float3 StepLighting = Texture2DSampleLevel(FinalLightingAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).rgb;
					//float3 StepLighting = Pow2(Texture2DSampleLevel(LumenCardScene.AlbedoAtlas, TRACING_ATLAS_SAMPLER, IntersectionAtlasUV, MaxMip).rgb);
				#endif
			
				if (TraceInput.bBlackOutSteepIntersections)
				{
					// Assume steep sections are covered by other faces and fade out.
					float SlopeFade = 1 - saturate((IntersectionSlope - 5) / 1.0f);
					StepLighting = lerp(0, StepLighting, SlopeFade);
					ConeOcclusion = lerp(0, ConeOcclusion, SlopeFade);
				}

				ConeStepBlendState.AddLighting(StepLighting, ConeOcclusion, IntersectionStepTime);
			}

			CardTraceBlendState.AddCardTrace(ConeStepBlendState);
		}
*/
	}
}

Buffer<uint> CulledCardGridData;

void ConeTraceLumenCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FCardTraceBlendState CardTraceBlendState;
	CardTraceBlendState.Initialize(TraceInput.MaxTraceDistance);
	float3 ConeEndPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
	float3 debug = 0;
	float TraceEndDistance = 0;

	for (uint CardIndex = 0; CardIndex < LumenCardScene.NumCards; CardIndex++)
	{
		ConeTraceSingleLumenCard(
			TraceInput,
			CardIndex,
			debug,
			TraceEndDistance,
			CardTraceBlendState);
	}

	OutResult = (FConeTraceResult)0;

	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = CardTraceBlendState.GetFinalLighting();
	#endif
	OutResult.Transparency = CardTraceBlendState.GetTransparency();
	OutResult.NumSteps = CardTraceBlendState.NumSteps;
	OutResult.NumOverlaps = CardTraceBlendState.NumOverlaps;
	OutResult.OpaqueHitDistance = CardTraceBlendState.OpaqueHitDistance;
	OutResult.Debug = debug;
}

// Mesh SDF cull grid
Buffer<uint> NumGridCulledMeshSDFObjects;
Buffer<uint> GridCulledMeshSDFObjectStartOffsetArray;
Buffer<uint> GridCulledMeshSDFObjectIndicesArray;

struct FTraceMeshSDFResult
{
	float HitDistance;
	uint HitObject;
	bool bRayStartInsideGeometry;
};

void RayTraceSingleMeshSDF(
	float3 WorldRayStart, 
	float3 WorldRayDirection, 
	float TanConeHalfAngle,
	float MinTraceDistance,
	float MaxTraceDistance, 
	uint ObjectIndex,
	// The SDF surface is expanded to reduce leaking through thin surfaces, especially foliage meshes with bGenerateDistanceFieldAsIfTwoSided
	// Expanding as RayTime increases errors on the side of over-occlusion, especially at grazing angles, which can be desirable for diffuse GI.
	// Expanding as MaxDistance increases has less incorrect self-intersection which is desirable for reflections rays.
	bool bExpandSurfaceUsingRayTimeInsteadOfMaxDistance,
	float InitialMaxDistance,
	inout FTraceMeshSDFResult TraceResult)
{
	FDFObjectData DFObjectData = LoadDFObjectData(ObjectIndex);

	// Trace up to the current hit point
	MaxTraceDistance = min(MaxTraceDistance, TraceResult.HitDistance + DFObjectData.VolumeSurfaceBias);

	float3 WorldRayEnd = WorldRayStart + WorldRayDirection * MaxTraceDistance;
	float3 VolumeRayStart = mul(float4(WorldRayStart, 1), DFObjectData.WorldToVolume).xyz;
	float3 VolumeRayEnd = mul(float4(WorldRayEnd, 1), DFObjectData.WorldToVolume).xyz;
	float3 VolumeRayDirection = VolumeRayEnd - VolumeRayStart;

	float VolumeMaxTraceDistance = length(VolumeRayDirection);
	float VolumeMinTraceDistance = VolumeMaxTraceDistance * (MinTraceDistance / MaxTraceDistance);
	VolumeRayDirection /= VolumeMaxTraceDistance;

	float2 VolumeSpaceIntersectionTimes = LineBoxIntersect(VolumeRayStart, VolumeRayEnd, -DFObjectData.VolumePositionExtent, DFObjectData.VolumePositionExtent);

	VolumeSpaceIntersectionTimes *= VolumeMaxTraceDistance;
	VolumeSpaceIntersectionTimes.x = max(VolumeSpaceIntersectionTimes.x, VolumeMinTraceDistance);

	BRANCH
	if (VolumeSpaceIntersectionTimes.x < VolumeSpaceIntersectionTimes.y)
	{
		uint MaxMipIndex = LoadDFAssetData(DFObjectData.AssetIndex, 0).NumMips - 1;
		// Start tracing at the highest resolution mip
		uint ReversedMipIndex = MaxMipIndex;
		FDFAssetData DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);

		#if !SDF_TRACING_TRAVERSE_MIPS
			ReversedMipIndex = MaxMipIndex;
			DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);
		#endif

		bool bRayStartInsideGeometry = false;
		float SampleRayTime = VolumeSpaceIntersectionTimes.x;

		uint MaxSteps = 64;
		float MinStepSize = 1.0f / (16 * MaxSteps);
		uint StepIndex = 0;
		bool bHit = false;
		float MaxDistance = InitialMaxDistance;

		LOOP
		for (; StepIndex < MaxSteps; StepIndex++)
		{
			float3 SampleVolumePosition = VolumeRayStart + VolumeRayDirection * SampleRayTime;
			float DistanceField = SampleSparseMeshSignedDistanceField(SampleVolumePosition, DFAssetMipData);

			MaxDistance = max(DistanceField, MaxDistance);
			float ExpandSurfaceTime = bExpandSurfaceUsingRayTimeInsteadOfMaxDistance ? SampleRayTime : MaxDistance;

			// Expand the surface to find thin features, but only away from the start of the trace where it won't introduce incorrect self-occlusion
			// This still causes incorrect self-occlusion at grazing angles
			float ExpandSurfaceDistance = DFObjectData.VolumeSurfaceBias;
			const float ExpandSurfaceFalloff = 2.0f * ExpandSurfaceDistance;
			const float ExpandSurfaceAmount = ExpandSurfaceDistance * saturate(ExpandSurfaceTime / ExpandSurfaceFalloff);

#if SDF_TRACING_TRAVERSE_MIPS

			float MaxEncodedDistance = DFAssetMipData.DistanceFieldToVolumeScaleBias.x + DFAssetMipData.DistanceFieldToVolumeScaleBias.y;

			// We reached the maximum distance of this mip's narrow band, use a lower resolution mip for next iteration
			if (abs(DistanceField) > MaxEncodedDistance && ReversedMipIndex > 0)
			{
				ReversedMipIndex--;
				DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);
			}
			// We are close to the surface, step back to safety and use a higher resolution mip for next iteration
			else if (abs(DistanceField) < .25f * MaxEncodedDistance && ReversedMipIndex < MaxMipIndex)
			{
				DistanceField -= 6.0f * DFObjectData.VolumeSurfaceBias;
				ReversedMipIndex++;
				DFAssetMipData = LoadDFAssetData(DFObjectData.AssetIndex, ReversedMipIndex);
			}
			else 
#endif
			if (DistanceField < ExpandSurfaceAmount && ReversedMipIndex == MaxMipIndex)
			{
				bRayStartInsideGeometry = SampleRayTime <= 0.0f && SampleRayTime + DistanceField < 0.0f ? true : false;
				// One more step to the surface
				// Pull back by ExpandSurfaceAmount to improve the gradient computed off of the hit point
				SampleRayTime = clamp(SampleRayTime + DistanceField - ExpandSurfaceAmount, VolumeSpaceIntersectionTimes.x, VolumeSpaceIntersectionTimes.y);
				bHit = true;
				break;
			}

			float StepDistance = max(DistanceField, MinStepSize);
			SampleRayTime += StepDistance;		

			if (SampleRayTime > VolumeSpaceIntersectionTimes.y + ExpandSurfaceAmount)
			{
				break;
			}
		}

		if (StepIndex == MaxSteps)
		{
			bHit = true;
		}

		if (bHit)
		{
			float NewHitDistance = length(VolumeRayDirection * SampleRayTime * DFObjectData.VolumeToWorldScale);

			if (NewHitDistance < TraceResult.HitDistance)
			{
				TraceResult.HitObject = ObjectIndex;
				TraceResult.HitDistance = NewHitDistance;
				TraceResult.bRayStartInsideGeometry = bRayStartInsideGeometry;
			}
		}
	}
}

float3 GetPrevWorldPositionFromGPUSceneInstanceIndex(float3 WorldPosition, uint GPUSceneInstanceIndex)
{
	FInstanceSceneData InstanceSceneData = GetInstanceSceneData(GPUSceneInstanceIndex, View.InstanceSceneDataSOAStride);
	float4 LocalPosition = mul(float4(WorldPosition, 1), LWCHackToFloat(InstanceSceneData.WorldToLocal));
	float3 PrevWorldPosition = mul(LocalPosition, LWCHackToFloat(InstanceSceneData.PrevLocalToWorld)).xyz;
	return PrevWorldPosition;
}

struct FTraceMeshSDFDerivedData
{
	float3 HitNormal;
	uint SceneInstanceIndex;
	uint MeshCardsIndex;
	float SurfaceCacheBias;
	float3 WorldVelocity;
};

FTraceMeshSDFDerivedData CalculateMeshSDFDerivedData(
	float3 WorldRayStart, 
	float3 WorldRayDirection, 
	float TraceDistance,
	bool bCalculateHitVelocity,
	FTraceMeshSDFResult TraceMeshSDFResult)
{
	FTraceMeshSDFDerivedData TraceSDFData;

	uint DFObjectIndex = TraceMeshSDFResult.HitObject;
	FDFObjectData DFObjectData = LoadDFObjectData(DFObjectIndex);

	float3 HitPosition = WorldRayStart + WorldRayDirection * TraceMeshSDFResult.HitDistance;
	float3 SampleVolumePosition = mul(float4(HitPosition, 1), DFObjectData.WorldToVolume).xyz;

	// Clamp hit point to a valid volume
	SampleVolumePosition = clamp(SampleVolumePosition, -DFObjectData.VolumePositionExtent, DFObjectData.VolumePositionExtent);

	FDFAssetData DFAssetData = LoadDFAssetDataHighestResolution(DFObjectData.AssetIndex);
	float3 VolumeGradient = CalculateMeshSDFGradient(SampleVolumePosition, DFAssetData);
	float VolumeGradientLength = length(VolumeGradient);
	float3 VolumeNormal = VolumeGradientLength > 0.0f ? VolumeGradient / VolumeGradientLength : 0;
	// Transform by transposed inverse to handle non-uniform scaling
	float3 WorldGradient = mul(VolumeNormal, transpose((float3x3)DFObjectData.WorldToVolume));
	float WorldGradientLength = length(WorldGradient);
	TraceSDFData.HitNormal = WorldGradientLength > 0.0f ? WorldGradient / WorldGradientLength : 0;
	TraceSDFData.SurfaceCacheBias = DFObjectData.bMostlyTwoSided ? 40.0f : 20.0f;

	if (bCalculateHitVelocity)
	{
		TraceSDFData.WorldVelocity = HitPosition - GetPrevWorldPositionFromGPUSceneInstanceIndex(HitPosition, DFObjectData.GPUSceneInstanceIndex);
	}

	TraceSDFData.SceneInstanceIndex = DFObjectData.GPUSceneInstanceIndex;
	TraceSDFData.MeshCardsIndex = GetMeshCardsIndexFromSceneInstanceIndex(TraceSDFData.SceneInstanceIndex);

	return TraceSDFData;
}

Buffer<uint> NumCulledHeightfieldObjects;
Buffer<uint> CulledHeightfieldObjectIndexBuffer;

Buffer<uint> NumGridCulledHeightfieldObjects;
Buffer<uint> GridCulledHeightfieldObjectStartOffsetArray;
Buffer<uint> GridCulledHeightfieldObjectIndicesArray;

struct FConeTraceHeightfieldSimpleResult
{
	bool bIsHit;
	bool bHitFrontFace;
	float HitDistance;
};

struct FHeightfieldRayStep
{
	float tValue;
	float3 LocalSamplePosition;
	float LocalHeightfieldDepth;
	bool bAboveHeightfield;
};

FHeightfieldRayStep HeightfieldRayStep(FLumenCardData LumenCardData, uint LocalCardIndex, FConeTraceInput TraceInput, float3 LocalConeOrigin, float3 LocalConeDirection, float tValue)
{
	float SampleRadius = max(TraceInput.ConeStartRadius + TraceInput.TanConeAngle * tValue, TraceInput.MinSampleRadius);
	float3 LocalSamplePosition = LocalConeOrigin + LocalConeDirection * tValue;
	bool bHiResSurface = false;

	FLumenCardSample CardSample = ComputeSurfaceCacheSample(LumenCardData, LocalCardIndex, LocalSamplePosition.xy, SampleRadius, bHiResSurface);

	float NormalizedDepth = 1.0f - Texture2DSampleLevel(LumenCardScene.DepthAtlas, GlobalBilinearClampedSampler, CardSample.PhysicalAtlasUV, 0).x;

	FHeightfieldRayStep RayStep;
	RayStep.tValue = tValue;
	RayStep.LocalSamplePosition = LocalSamplePosition;
	RayStep.LocalHeightfieldDepth = -LumenCardData.LocalExtent.z + NormalizedDepth * 2.0f * LumenCardData.LocalExtent.z;
	RayStep.bAboveHeightfield = RayStep.LocalSamplePosition.z > RayStep.LocalHeightfieldDepth;
	return RayStep;
}

float GetHeightfieldAlpha(FLumenCardData LumenCardData, uint LocalCardIndex, FConeTraceInput TraceInput, float3 LocalConeOrigin, float3 LocalConeDirection, float tValue)
{
	float SampleRadius = max(TraceInput.ConeStartRadius + TraceInput.TanConeAngle * tValue, TraceInput.MinSampleRadius);
	float3 LocalSamplePosition = LocalConeOrigin + LocalConeDirection * tValue;
	bool bHiResSurface = false;

	FLumenCardSample CardSample = ComputeSurfaceCacheSample(LumenCardData, LocalCardIndex, LocalSamplePosition.xy, SampleRadius, bHiResSurface);

	return Texture2DSampleLevel(LumenCardScene.OpacityAtlas, GlobalBilinearClampedSampler, CardSample.PhysicalAtlasUV, 0).x;
}

bool EvaluateHeightfieldHit(
	FLumenCardData LumenCardData, 
	uint LocalCardIndex, 
	FConeTraceInput TraceInput,
	float3 LocalConeOrigin,
	float3 LocalConeDirection,
	FHeightfieldRayStep PrevStep,
	FHeightfieldRayStep Step,
	float StepSize, 
	float tMinValue,
	float tMaxValue,
	inout FConeTraceHeightfieldSimpleResult Result)
{
	// Hit-point is approximated as the intersection between the ray and a line connecting the previous two evaluation points
	// (1 - t) * PrevPosition.z + t * LocalSamplePosition.z = (1 - t) * PrevHeightfieldDepth + t * LocalHeightfieldDepth
	float DeltaT = (PrevStep.LocalSamplePosition.z - PrevStep.LocalHeightfieldDepth) / (PrevStep.LocalSamplePosition.z - Step.LocalSamplePosition.z - PrevStep.LocalHeightfieldDepth + Step.LocalHeightfieldDepth);
	float HitDistance = clamp(PrevStep.tValue + DeltaT * StepSize, tMinValue, tMaxValue);

	float HeightfieldAlpha = GetHeightfieldAlpha(LumenCardData, LocalCardIndex, TraceInput, LocalConeOrigin, LocalConeDirection, HitDistance);
	if (HeightfieldAlpha > 0.5f)
	{
		Result.HitDistance = HitDistance;
		Result.bIsHit = true;
		Result.bHitFrontFace = !Step.bAboveHeightfield;
	}

	return Result.bIsHit;
}

int HeightfieldMaxTracingSteps;

FConeTraceHeightfieldSimpleResult ConeTraceHeightfieldSimple(
	FConeTraceInput TraceInput,
	uint HeightfieldIndex
)
{
	FConeTraceHeightfieldSimpleResult Result;
	Result.bIsHit = false;
	Result.bHitFrontFace = false;
	Result.HitDistance = TraceInput.MaxTraceDistance;

	FLumenHeightfieldData LumenHeightfield = GetLumenHeightfieldData(HeightfieldIndex);
	FLumenMeshCardsData MeshCardsData = GetLumenMeshCardsData(LumenHeightfield.MeshCardsIndex);

	// Fetch card
	int LocalCardIndex = LUMEN_HEIGHTFIELD_LOCAL_CARD_INDEX;
	FLumenCardData LumenCardData = GetLumenCardData(MeshCardsData.CardOffset + LocalCardIndex);

	// Convert ray to local space
	float3 LocalConeOrigin = mul(TraceInput.ConeOrigin - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);
	float3 LocalConeDirection = mul(TraceInput.ConeDirection, LumenCardData.WorldToLocalRotation);
	float3 LocalConeEndPoint = LocalConeOrigin + LocalConeDirection * TraceInput.MaxTraceDistance;

	// Intersect ray and clip to heightfield bounds
	float2 HitT = LineBoxIntersect(LocalConeOrigin, LocalConeEndPoint, -LumenCardData.LocalExtent, LumenCardData.LocalExtent);
	HitT *= length(LocalConeEndPoint - LocalConeOrigin);

	// Clip marching space to intersection window
	float tMinValue = max(HitT.x, TraceInput.MinTraceDistance);
	float tMaxValue = min(HitT.y, TraceInput.MaxTraceDistance);

	// Ray-march at some nominal step size, evaluating heightfield data along the way
	if (tMinValue < tMaxValue && LumenCardData.bVisible)
	{
		// Calculate initial entry depth
		FHeightfieldRayStep PrevStep = HeightfieldRayStep(LumenCardData, LocalCardIndex, TraceInput, LocalConeOrigin, LocalConeDirection, tMinValue);

		// Skip back face hits between [0; EpsilonTraceLength]
		float EpsilonTraceLength = LumenCardData.TexelSize;
		if (TraceInput.bUseEpsilonTraceForHeightfields && tMinValue < EpsilonTraceLength)
		{
			FHeightfieldRayStep Step = HeightfieldRayStep(LumenCardData, LocalCardIndex, TraceInput, LocalConeOrigin, LocalConeDirection, EpsilonTraceLength);

			// Hit only front faces
			if (PrevStep.bAboveHeightfield && !Step.bAboveHeightfield)
			{
				EvaluateHeightfieldHit(
					LumenCardData,
					LocalCardIndex,
					TraceInput,
					LocalConeOrigin,
					LocalConeDirection,
					PrevStep,
					Step,
					/*StepSize*/ EpsilonTraceLength,
					tMinValue,
					tMaxValue,
					Result);
			}

			PrevStep = Step;
			tMinValue = EpsilonTraceLength;
		}

		if (!Result.bIsHit)
		{
			const int MaxSteps = HeightfieldMaxTracingSteps;
			float MinStepSize = (tMaxValue - tMinValue) / MaxSteps;
			float StepSize = max(LumenCardData.TexelSize * TraceInput.StepFactor, MinStepSize);

			float tValue = tMinValue;
			for (int StepIndex = 0; StepIndex < MaxSteps; ++StepIndex)
			{
				tValue = min(tValue + StepSize, tMaxValue);

				FHeightfieldRayStep Step = HeightfieldRayStep(LumenCardData, LocalCardIndex, TraceInput, LocalConeOrigin, LocalConeDirection, tValue);

				// Encountered zero-crossing
				if (PrevStep.bAboveHeightfield != Step.bAboveHeightfield)
				{
					EvaluateHeightfieldHit(
						LumenCardData,
						LocalCardIndex,
						TraceInput,
						LocalConeOrigin,
						LocalConeDirection,
						PrevStep,
						Step,
						/*StepSize*/ StepSize,
						tMinValue,
						tMaxValue,
						Result);
				}

				PrevStep = Step;

				// Make sure we do one step at tMaxValue order to guarantee a hit
				if (Result.bIsHit || tValue >= tMaxValue)
				{
					break;
				}
			}
		}
	}

	return Result;
}

struct FTraceMeshHeightfieldResult
{
	FLumenCardData LumenCardData;
	int LocalCardIndex;
	float HitDistance;
	int TotalStepCount;
	uint HeightfieldObjectIndex;
};

struct FTraceMeshHeightfieldShadedResult
{
	float3 Lighting;
	float Opacity;
};

FTraceMeshHeightfieldResult ConeTraceHeightfield(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult
)
{
	OutResult = (FConeTraceResult)0;
	FTraceMeshHeightfieldResult TraceMeshHeightfieldResult = (FTraceMeshHeightfieldResult)0;
	TraceMeshHeightfieldResult.HitDistance = TraceInput.MaxTraceDistance;

	bool bHitFrontFace = false;
#if USE_HEIGHTFIELD_VIEW_CULLING_ONLY
	uint NumHeightfields = NumCulledHeightfieldObjects[0];
#else // Use froxel-based culling
	uint NumHeightfields = TraceInput.NumHeightfields;
#endif

#if SCENE_TRACE_HEIGHTFIELDS
	for (uint Index = 0; Index < NumHeightfields; Index++)
	{
#if USE_HEIGHTFIELD_VIEW_CULLING_ONLY
		uint HeightfieldObjectIndex = CulledHeightfieldObjectIndexBuffer[Index];
#else // Use froxel-based culling
		uint HeightfieldObjectIndex = GridCulledHeightfieldObjectIndicesArray[TraceInput.HeightfieldStartOffset + Index];
#endif
		FConeTraceHeightfieldSimpleResult SimpleResult = ConeTraceHeightfieldSimple(TraceInput, HeightfieldObjectIndex);

		if (SimpleResult.bIsHit && (SimpleResult.HitDistance < TraceMeshHeightfieldResult.HitDistance))
		{
			TraceMeshHeightfieldResult.HitDistance = SimpleResult.HitDistance;
			TraceMeshHeightfieldResult.HeightfieldObjectIndex = HeightfieldObjectIndex;
			bHitFrontFace = SimpleResult.bHitFrontFace;
		}
	}

	if (TraceMeshHeightfieldResult.HitDistance < TraceInput.MaxTraceDistance)
	{
		FLumenHeightfieldData LumenHeightfield = GetLumenHeightfieldData(TraceMeshHeightfieldResult.HeightfieldObjectIndex);
		float3 SamplePosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceMeshHeightfieldResult.HitDistance;
		float3 SampleNormal = float3(0, 0, 1);
		float SampleRadius = max(TraceInput.ConeStartRadius + TraceInput.TanConeAngle * TraceMeshHeightfieldResult.HitDistance, TraceInput.MinSampleRadius);
		float SurfaceCacheBias = 20.0f;
		uint AtlasId = FINAL_LIGHTING_ATLAS_ID;

		if (bHitFrontFace)
		{
			OutResult.Lighting = SampleLumenMeshCards(
				TraceInput.ScreenCoord,
				LumenHeightfield.MeshCardsIndex,
				SamplePosition,
				SampleNormal,
				SampleRadius,
				SurfaceCacheBias,
				TraceInput.bHiResSurface,
				AtlasId).Lighting;
		}
		else
		{
			OutResult.Lighting = 0;
		}
		OutResult.Transparency = 0;
	}
#endif
	OutResult.NumOverlaps = NumHeightfields;
	OutResult.OpaqueHitDistance = TraceMeshHeightfieldResult.HitDistance;
	return TraceMeshHeightfieldResult;
}

void ConeTraceMeshSDFsAndInterpolateFromCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FTraceMeshSDFResult TraceMeshSDFResult;
	TraceMeshSDFResult.HitDistance = TraceInput.MaxTraceDistance;
	TraceMeshSDFResult.HitObject = 0;

	for (uint GridCulledMeshSDFIndex = 0; GridCulledMeshSDFIndex < TraceInput.NumMeshSDFs; GridCulledMeshSDFIndex++)
	{
		uint ObjectIndex = GridCulledMeshSDFObjectIndicesArray[TraceInput.MeshSDFStartOffset + GridCulledMeshSDFIndex];

		RayTraceSingleMeshSDF(
			TraceInput.ConeOrigin, 
			TraceInput.ConeDirection, 
			TraceInput.TanConeAngle,
			TraceInput.MinTraceDistance,
			TraceInput.MaxTraceDistance, 
			ObjectIndex, 
			TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance,
			TraceInput.InitialMaxDistance,
			TraceMeshSDFResult);
	}

	if (TraceMeshSDFResult.HitDistance < TraceInput.MaxTraceDistance)
	{
		FTraceMeshSDFDerivedData TraceSDFData = CalculateMeshSDFDerivedData(
			TraceInput.ConeOrigin, 
			TraceInput.ConeDirection, 
			TraceInput.MaxTraceDistance, 
			TraceInput.bCalculateHitVelocity,
			TraceMeshSDFResult);

		//OutResult.Lighting = frac(10 * TraceMeshSDFResult.HitDistance / TraceInput.MaxTraceDistance);
		//OutResult.Lighting = NumGridCulledMeshSDFObjects[MeshSDFGridCellIndex] / 10.0f;
		
		float3 InterpolatePosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceMeshSDFResult.HitDistance;
		float InterpolateRadius = TraceMeshSDFResult.HitDistance * TraceInput.TanConeAngle;

		//OutResult.Lighting = TraceSDFData.HitNormal * .5f + .5f;
		//OutResult.Lighting = frac(InterpolatePosition / 1000);
	
		uint AtlasId = FINAL_LIGHTING_ATLAS_ID;
		OutResult.Lighting = SampleLumenMeshCards(
			TraceInput.ScreenCoord,
			TraceSDFData.MeshCardsIndex,
			InterpolatePosition,
			TraceSDFData.HitNormal,
			InterpolateRadius,
			TraceSDFData.SurfaceCacheBias,
			TraceInput.bHiResSurface,
			AtlasId).Lighting;
		OutResult.Transparency = 0;
		OutResult.WorldVelocity = TraceSDFData.WorldVelocity;
	}

	OutResult.OpaqueHitDistance = TraceMeshSDFResult.HitDistance;
}

Texture3D VoxelLighting;
// Must match C++
#define MAX_VOXEL_CLIPMAP_LEVELS 8
#define NumClipmapLevels LumenVoxelTracingParameters.NumClipmapLevels
#define ClipmapWorldToUVScale LumenVoxelTracingParameters.ClipmapWorldToUVScale
#define ClipmapWorldToUVBias LumenVoxelTracingParameters.ClipmapWorldToUVBias
#define ClipmapVoxelSizeAndRadius LumenVoxelTracingParameters.ClipmapVoxelSizeAndRadius
#define ClipmapWorldCenter LumenVoxelTracingParameters.ClipmapWorldCenter
#define ClipmapWorldExtent LumenVoxelTracingParameters.ClipmapWorldExtent
#define ClipmapWorldSamplingExtent LumenVoxelTracingParameters.ClipmapWorldSamplingExtent

float4 SampleVoxelLighting(float3 WorldPosition, float3 Direction, uint ClipmapIndex)
{
	float3 UV = WorldPosition * ClipmapWorldToUVScale[ClipmapIndex].xyz + ClipmapWorldToUVBias[ClipmapIndex].xyz;
	UV.y = (UV.y + ClipmapIndex) / (float)NumClipmapLevels;

	float4 Lighting = 0;

	float3 XAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.x > 0 ? 0 : 1.0f / 6.0f));
	float3 YAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.y > 0 ? 2.0f / 6.0f : 3.0f / 6.0f));
	float3 ZAxisUV = float3(UV.xy, UV.z / 6.0f + (Direction.z > 0 ? 4.0f / 6.0f : 5.0f / 6.0f));

	float4 XAxisLighting;
	float4 YAxisLighting;
	float4 ZAxisLighting;

	XAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, XAxisUV, 0);
	YAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, YAxisUV, 0);
	ZAxisLighting = Texture3DSampleLevel(VoxelLighting, GlobalTrilinearClampedSampler, ZAxisUV, 0);

	float3 AxisWeights = Direction * Direction;
	float InvTotalWeight = 1.0f / dot(AxisWeights, 1.0f);

	Lighting = (XAxisLighting * AxisWeights.x + YAxisLighting * AxisWeights.y + ZAxisLighting * AxisWeights.z) * InvTotalWeight;

	return Lighting.xyzw;
}

// Transparency value which is forced to zero to reduce leaking. It is softly faded-in with a VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH.
static float MIN_VOXEL_TRACE_TRANSPARENCY = 0.1f;
static float VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH = 0.05f;

float4 FadeOutVoxelConeTraceMinTransparency(float4 LightingAndAlpha)
{
	if (LightingAndAlpha.a < MIN_VOXEL_TRACE_TRANSPARENCY + VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH)
	{
		// Restore missing energy due to early out.
		LightingAndAlpha.rgb *= (1.0f + LightingAndAlpha.a);

		// Smoothly force a transparency of MIN_VOXEL_TRACE_TRANSPARENCY to 0, since we stopped tracing
		LightingAndAlpha.a = saturate((LightingAndAlpha.a - MIN_VOXEL_TRACE_TRANSPARENCY) * (MIN_VOXEL_TRACE_TRANSPARENCY + VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH) / VOXEL_TRACE_TRANSPARENCY_FADE_LENGTH);
	}

	return LightingAndAlpha;
}

uint VoxelFaceFromStep(uint3 StepInc, int3 VoxelStep)
{
	uint3 DirectionOffset = VoxelStep >= 0 ? 0 : 1;
	return dot(StepInc, uint3(0, 2, 4) + DirectionOffset);
}

/**
 * Ray trace the Global Distance Field, compute hit point and hit normal, and fetch lighting from Voxel Lighting volume
 */
void ConeTraceVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	FGlobalSDFTraceResult SDFTraceResult;

	// Trace SDF ray
	{
		FGlobalSDFTraceInput SDFTraceInput = SetupGlobalSDFTraceInput(TraceInput.ConeOrigin, TraceInput.ConeDirection, TraceInput.MinTraceDistance, TraceInput.MaxTraceDistance, TraceInput.SDFStepFactor, TraceInput.VoxelStepFactor);
		SDFTraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance = TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance;
		SDFTraceInput.InitialMaxDistance = TraceInput.InitialMaxDistance;

		SDFTraceResult = RayTraceGlobalDistanceField(SDFTraceInput);
	}

	float4 LightingAndAlpha = float4(0, 0, 0, 1);

	if (GlobalSDFTraceResultIsHit(SDFTraceResult))
	{
		float3 SampleWorldPosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * SDFTraceResult.HitTime;

		uint VoxelClipmapIndex = 0;
		float3 VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
		float3 VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;

		bool bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);

		// Find the voxel clipmap that matches the cone width at the current step
		while (bOutsideValidRegion && VoxelClipmapIndex + 1 < NumClipmapLevels)
		{
			VoxelClipmapIndex++;
			VoxelClipmapCenter = ClipmapWorldCenter[VoxelClipmapIndex].xyz;
			VoxelClipmapExtent = ClipmapWorldSamplingExtent[VoxelClipmapIndex].xyz;
			bOutsideValidRegion = any(SampleWorldPosition > VoxelClipmapCenter + VoxelClipmapExtent || SampleWorldPosition < VoxelClipmapCenter - VoxelClipmapExtent);
		}

		LightingAndAlpha.xyzw = 0.0f;

		if (!bOutsideValidRegion)
		{
			float3 DistanceFieldGradient = -TraceInput.ConeDirection;

			float3 ClipmapVolumeUV = ComputeGlobalUV(SampleWorldPosition, SDFTraceResult.HitClipmapIndex);
			uint PageIndex = GetGlobalDistanceFieldPage(ClipmapVolumeUV, SDFTraceResult.HitClipmapIndex);

			if (PageIndex < GLOBAL_DISTANCE_FIELD_INVALID_PAGE_ID)
			{
				float3 PageUV = ComputeGlobalDistanceFieldPageUV(ClipmapVolumeUV, PageIndex);
				DistanceFieldGradient = GlobalDistanceFieldPageCentralDiff(PageUV);
			}

			float DistanceFieldGradientLength = length(DistanceFieldGradient);
			float3 SampleNormal = DistanceFieldGradientLength > 0.001 ? DistanceFieldGradient / DistanceFieldGradientLength : -TraceInput.ConeDirection;
			float4 StepLighting = SampleVoxelLighting(SampleWorldPosition, -SampleNormal, VoxelClipmapIndex);

			StepLighting.xyz = StepLighting.xyz * (1.0f / max(StepLighting.w, 0.1));

			float VoxelSelfLightingBias = 1.0f;
			if (TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance)
			{
				// For diffuse rays prefer to over occlude instead of leaking
				VoxelSelfLightingBias = smoothstep(1.5 * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w, 2.0 * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w, SDFTraceResult.HitTime);
			}

			LightingAndAlpha.xyz = StepLighting.xyz * VoxelSelfLightingBias;
		}
	}

	LightingAndAlpha = FadeOutVoxelConeTraceMinTransparency(LightingAndAlpha);

	OutResult = (FConeTraceResult)0;
	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = LightingAndAlpha.rgb;
	#endif
	OutResult.Transparency = LightingAndAlpha.a;
	OutResult.NumSteps = SDFTraceResult.TotalStepsTaken;
	OutResult.OpaqueHitDistance = GlobalSDFTraceResultIsHit(SDFTraceResult) ? SDFTraceResult.HitTime : TraceInput.MaxTraceDistance;
	OutResult.ExpandSurfaceAmount = SDFTraceResult.ExpandSurfaceAmount;
}

float ComputeSquaredDistanceBetweenAABBs(float3 CenterA, float3 ExtentA, float3 CenterB, float3 ExtentB)
{
	float3 AxisDistances = max(abs(CenterB - CenterA) - (ExtentA + ExtentB), 0);
	return dot(AxisDistances, AxisDistances);
}

float CalculateVoxelTraceStartDistance(float MinTraceDistance, float MaxTraceDistance, float MaxMeshSDFTraceDistance, bool bContinueCardTracing)
{
	float VoxelTraceStartDistance = MaxTraceDistance;

	if (NumClipmapLevels > 0)
	{
		VoxelTraceStartDistance = MinTraceDistance;

		if (bContinueCardTracing)
		{
			VoxelTraceStartDistance = max(VoxelTraceStartDistance, MaxMeshSDFTraceDistance);
		}
	}

	return VoxelTraceStartDistance;
}

void ConeTraceLumenSceneCards(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	OutResult = (FConeTraceResult)0;
	OutResult.Transparency = 1;
	OutResult.OpaqueHitDistance = TraceInput.MaxTraceDistance;

#if SCENE_TRACE_MESH_SDFS
	if (TraceInput.VoxelTraceStartDistance > TraceInput.MinTraceDistance)
	{
		FConeTraceInput CardTraceInput = TraceInput;
		CardTraceInput.MaxTraceDistance = TraceInput.VoxelTraceStartDistance;

		ConeTraceMeshSDFsAndInterpolateFromCards(CardTraceInput, OutResult);
	}
#endif
}

void ConeTraceLumenSceneHeightfields(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
#if SCENE_TRACE_HEIGHTFIELDS
	if (TraceInput.VoxelTraceStartDistance > TraceInput.MinTraceDistance)
	{
		FConeTraceInput CardTraceInput = TraceInput;
		CardTraceInput.MaxTraceDistance = min(TraceInput.VoxelTraceStartDistance, OutResult.OpaqueHitDistance);

		FConeTraceResult HeightfieldResult = OutResult;
		ConeTraceHeightfield(CardTraceInput, HeightfieldResult);

		if (HeightfieldResult.OpaqueHitDistance < CardTraceInput.MaxTraceDistance)
		{
			OutResult = HeightfieldResult;
		}
		OutResult.NumSteps += HeightfieldResult.NumSteps;
	}
#endif
}

void ConeTraceLumenSceneVoxels(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
#if SCENE_TRACE_VOXELS
	if (TraceInput.VoxelTraceStartDistance < TraceInput.MaxTraceDistance)
	{
		FConeTraceInput VoxelTraceInput = TraceInput;
		VoxelTraceInput.MinTraceDistance = TraceInput.VoxelTraceStartDistance;
		FConeTraceResult VoxelTraceResult;
		ConeTraceVoxels(VoxelTraceInput, VoxelTraceResult);

		#if !VISIBILITY_ONLY_TRACE
			OutResult.Lighting += VoxelTraceResult.Lighting * OutResult.Transparency;
		#endif
		OutResult.Transparency *= VoxelTraceResult.Transparency;
		OutResult.NumSteps += VoxelTraceResult.NumSteps;
		OutResult.OpaqueHitDistance = min(OutResult.OpaqueHitDistance, VoxelTraceResult.OpaqueHitDistance);
	}
#endif
}

void ConeTraceLumenScene(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	ConeTraceLumenSceneCards(TraceInput, OutResult);
	ConeTraceLumenSceneHeightfields(TraceInput, OutResult);
	ConeTraceLumenSceneVoxels(TraceInput, OutResult);
}

void ConeTraceLumenDistantScene(
	FConeTraceInput TraceInput,
	inout FConeTraceResult OutResult)
{
	float3 debug = 0;
	TraceInput.MaxTraceDistance = LumenCardScene.DistantSceneMaxTraceDistance;
	TraceInput.bBlackOutSteepIntersections = true;

	FCardTraceBlendState CardTraceBlendState;
	CardTraceBlendState.Initialize(TraceInput.MaxTraceDistance);

	if (LumenCardScene.NumDistantCards > 0)
	{
		if (NumClipmapLevels > 0)
		{
			float3 VoxelLightingCenter = ClipmapWorldCenter[NumClipmapLevels - 1].xyz;
			float3 VoxelLightingExtent = ClipmapWorldSamplingExtent[NumClipmapLevels - 1].xyz;

			float3 RayEnd = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceInput.MaxTraceDistance;
			float2 IntersectionTimes = LineBoxIntersect(TraceInput.ConeOrigin, RayEnd, VoxelLightingCenter - VoxelLightingExtent, VoxelLightingCenter + VoxelLightingExtent);

			// If we are starting inside the voxel clipmaps, move the start of the trace past the voxel clipmaps
			if (IntersectionTimes.x < IntersectionTimes.y && IntersectionTimes.x < .001f)
			{
				TraceInput.MinTraceDistance = IntersectionTimes.y * TraceInput.MaxTraceDistance;
			}
		}

		float TraceEndDistance = TraceInput.MinTraceDistance;

		// Multiple cascades disabled for now - artifacts when resuming traces between cascades, and shader has worse occupancy
		//for (uint ListIndex = 0; ListIndex < LumenCardScene.NumDistantCards && CardTraceBlendState.HasRemainingVisibility(TraceInput.MaxTraceDistance); ListIndex++)
		{
			//TraceInput.MinTraceDistance = TraceEndDistance;
			uint ListIndex = 0;
			uint CardIndex = GET_SCALAR_ARRAY_ELEMENT(LumenCardScene.DistantCardIndices, ListIndex);

			ConeTraceSingleLumenCard(
				TraceInput,
				CardIndex,
				debug,
				TraceEndDistance,
				CardTraceBlendState);
		}
	}

	OutResult = (FConeTraceResult)0;

	#if !VISIBILITY_ONLY_TRACE
		OutResult.Lighting = CardTraceBlendState.GetFinalLighting();
	#endif
	OutResult.Transparency = CardTraceBlendState.GetTransparency();
	OutResult.NumSteps = CardTraceBlendState.NumSteps;
	OutResult.NumOverlaps = CardTraceBlendState.NumOverlaps;
	OutResult.OpaqueHitDistance = CardTraceBlendState.OpaqueHitDistance;
	OutResult.Debug = debug;
}

float TanConeAngleToRoughness(float TanConeAngle)
{
	//@todo DynamicGI - derive roughness from cone angle
	return sqrt(saturate(TanConeAngle / (.5f * PI)));
}

float3 EvaluateSkyRadiance(float3 Direction, float TanConeAngle)
{
	float3 SkyRadiance = 0.0f;

#if ENABLE_DYNAMIC_SKY_LIGHT
	if (ReflectionStruct.SkyLightParameters.y > 0)
	{
		float SkyAverageBrightness = 1.0f;
		float Roughness = TanConeAngleToRoughness(TanConeAngle);

		SkyRadiance = GetSkyLightReflection(Direction, Roughness, SkyAverageBrightness);
	}
#endif

	return SkyRadiance;
}

void EvaluateSkyRadianceForCone(
	float3 ConeDirection, 
	float TanConeAngle, 
	inout FConeTraceResult TraceResult)
{ 
#if ENABLE_DYNAMIC_SKY_LIGHT
	if (ReflectionStruct.SkyLightParameters.y > 0)
	{
		float SkyAverageBrightness = 1.0f;
		float Roughness = TanConeAngleToRoughness(TanConeAngle);

		#if !VISIBILITY_ONLY_TRACE
			TraceResult.Lighting += GetSkyLightReflection(ConeDirection, Roughness, SkyAverageBrightness) * TraceResult.Transparency;
		#endif
		TraceResult.Transparency = 0;
	}
#endif
}