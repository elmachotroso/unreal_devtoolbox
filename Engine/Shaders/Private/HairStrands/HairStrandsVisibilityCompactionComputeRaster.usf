// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "HairStrandsVisibilityCommon.ush" 
#include "HairStrandsTileCommon.ush" 

#if PERMUTATION_GROUPSIZE == 0
#define TILE_PIXEL_SIZE_X 8
#define TILE_PIXEL_SIZE_Y 4
#else
#define TILE_PIXEL_SIZE_X 8
#define TILE_PIXEL_SIZE_Y 8
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if COMPILER_SUPPORTS_UINT64_IMAGE_ATOMICS && COMPILER_SUPPORTS_ULONG_TYPES
#define PackedType UlongType
uint2 UnpackData(PackedType In)
{
	return UnpackUlongType(In);
}
#else
#define PackedType uint2
uint2 UnpackData(PackedType In)
{
	return In;
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

int2 OutputResolution;
uint MaxNodeCount;
uint SamplerPerPixel;
float CoverageThreshold;

RWTexture2D<uint> 					OutCompactNodeCounter;
RWTexture2D<uint> 					OutCompactNodeIndex;
RWStructuredBuffer<FPackedHairVis> 	OutCompactNodeVis;
RWBuffer<uint2>						OutCompactNodeCoord;
RWTexture2D<float> 					OutCoverageTexture;

groupshared uint AllocationNodeCount;
groupshared uint AllocationNodeOffset;


struct FSampleSetDesc
{
	uint   UniqueSampleCount;
	uint   ValidSampleCount;
	uint   HairSampleCount;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Compute raster visibility buffer
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

Texture2D<PackedType> VisibilityTexture0;
Texture2D<PackedType> VisibilityTexture1;
Texture2D<PackedType> VisibilityTexture2;
Texture2D<PackedType> VisibilityTexture3;

Texture2D<uint>  VisibilityHairCount;
Texture2D<float> ViewTransmittanceTexture;

#if PERMUTATION_TILE
int2 TileCountXY;
uint TileSize;
Buffer<uint> TileCountBuffer;
Buffer<uint2> TileDataBuffer;
#endif // PERMUTATION_TILE

[numthreads(TILE_PIXEL_SIZE_X, TILE_PIXEL_SIZE_Y, 1)]
void MainCS(
	uint  GroupIndex : SV_GroupIndex,
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (GroupIndex == 0)
	{
		AllocationNodeCount = 0;
		AllocationNodeOffset = 0;
	}

#if PERMUTATION_TILE
	const uint TileCount = TileCountBuffer[HAIRTILE_HAIR_ALL];
	const uint LinearIndex = GroupId.x + GroupId.y * TileCountXY.x;
	if (LinearIndex >= TileCount)
	{
		return;
	}
	const uint2 TileCoord = TileDataBuffer[LinearIndex];
	uint2 PixelCoord = TileCoord * TileSize + GroupThreadId;
#else
	uint2 PixelCoord = DispatchThreadId.xy;// +ResolutionOffset;
#endif // PERMUTATION_TILE

	if (PixelCoord.x >= uint(OutputResolution.x) || PixelCoord.y >= uint(OutputResolution.y))
		PixelCoord = uint2(0, 0);

	FSampleSetDesc SampleDesc;

	const float OpaqueDepth = SceneTexturesStruct.SceneDepthTexture.Load(uint3(PixelCoord, 0)).r;

	//const uint HairCountAndRadius = VisibilityHairCount.Load(uint3(PixelCoord, 0)); // Contains both hair count and the radius;
	//const uint HairRadius = 0; // TODO
	//const uint HairCount  = HairCountAndRadius;
	const uint2 VisData0 = UnpackData(VisibilityTexture0.Load(uint3(PixelCoord, 0)));
	const uint2 VisData1 = UnpackData(VisibilityTexture1.Load(uint3(PixelCoord, 0)));
	const uint2 VisData2 = UnpackData(VisibilityTexture2.Load(uint3(PixelCoord, 0)));
	const uint2 VisData3 = UnpackData(VisibilityTexture3.Load(uint3(PixelCoord, 0)));

	uint2  Vis_PrimId_MatId[4];
	float2 Vis_Depth_Cov[4];
	float  TotalCoverage = 0;
	uint   UniqueSampleCount = 0;

	uint CurrentPrimitiveId = 0;
	const float DepthThres = OpaqueDepth;
	if (VisData0.y)
	{
		const uint VisSamplePrimitiveId = UnpackHairVisPrimitiveId(VisData0.x);
		const uint VisSampleMaterialId  = UnpackHairVisMaterialId(VisData0.x);
		const float2 Depth_Cov = float2(UnpackHairVisDepth(VisData0.y), UnpackHairVisCoverage(VisData0.y));

		Vis_PrimId_MatId[UniqueSampleCount]	= uint2(VisSamplePrimitiveId, VisSampleMaterialId);
		Vis_Depth_Cov[UniqueSampleCount]	= Depth_Cov;

		if (Depth_Cov.x > DepthThres && VisSamplePrimitiveId != CurrentPrimitiveId)
		{
			TotalCoverage += Vis_Depth_Cov[UniqueSampleCount].y;
			CurrentPrimitiveId = VisSamplePrimitiveId;
			UniqueSampleCount++;
		}
	}

	if (VisData1.y && SamplerPerPixel > 1)
	{
		const uint VisSamplePrimitiveId = UnpackHairVisPrimitiveId(VisData1.x);
		const uint VisSampleMaterialId  = UnpackHairVisMaterialId(VisData1.x);
		const float2 Depth_Cov			= float2(UnpackHairVisDepth(VisData1.y), UnpackHairVisCoverage(VisData1.y));

		Vis_PrimId_MatId[UniqueSampleCount]	= uint2(VisSamplePrimitiveId, VisSampleMaterialId);
		Vis_Depth_Cov[UniqueSampleCount]	= Depth_Cov;
		
		if (Depth_Cov.x > DepthThres && VisSamplePrimitiveId != CurrentPrimitiveId)
		{
			TotalCoverage += Vis_Depth_Cov[UniqueSampleCount].y;
			CurrentPrimitiveId = VisSamplePrimitiveId;
			UniqueSampleCount++;
		}
	}

	if (VisData2.y && SamplerPerPixel > 2)
	{
		const uint VisSamplePrimitiveId = UnpackHairVisPrimitiveId(VisData2.x);
		const uint VisSampleMaterialId  = UnpackHairVisMaterialId(VisData2.x);
		const float2 Depth_Cov			= float2(UnpackHairVisDepth(VisData2.y), UnpackHairVisCoverage(VisData2.y));

		Vis_PrimId_MatId[UniqueSampleCount]	= uint2(VisSamplePrimitiveId, VisSampleMaterialId);
		Vis_Depth_Cov[UniqueSampleCount]	= Depth_Cov;
		
		if (Depth_Cov.x > DepthThres && VisSamplePrimitiveId != CurrentPrimitiveId)
		{
			TotalCoverage += Vis_Depth_Cov[UniqueSampleCount].y;
			CurrentPrimitiveId = VisSamplePrimitiveId;
			UniqueSampleCount++;
		}
	}

	if (VisData3.y && SamplerPerPixel > 3)
	{
		const uint VisSamplePrimitiveId = UnpackHairVisPrimitiveId(VisData3.x);
		const uint VisSampleMaterialId  = UnpackHairVisMaterialId(VisData3.x);
		const float2 Depth_Cov			= float2(UnpackHairVisDepth(VisData3.y), UnpackHairVisCoverage(VisData3.y));

		Vis_PrimId_MatId[UniqueSampleCount]	 = uint2(VisSamplePrimitiveId, VisSampleMaterialId);
		Vis_Depth_Cov[UniqueSampleCount]	 = Depth_Cov;
		
		if (Depth_Cov.x > DepthThres && VisSamplePrimitiveId != CurrentPrimitiveId)
		{
			TotalCoverage += Vis_Depth_Cov[UniqueSampleCount].y;
			CurrentPrimitiveId = VisSamplePrimitiveId;
			UniqueSampleCount++;
		}
	}

	FNodeDesc NodeDesc;
	NodeDesc.Count = UniqueSampleCount;
	NodeDesc.Offset = 0;

	if (NodeDesc.Count > 0)
	{
		InterlockedAdd(AllocationNodeCount, NodeDesc.Count, NodeDesc.Offset);
	}
	GroupMemoryBarrierWithGroupSync();
	if (GroupIndex == 0 && AllocationNodeCount > 0)
	{
		InterlockedAdd(OutCompactNodeCounter[uint2(0, 0)], AllocationNodeCount, AllocationNodeOffset);
	}
	GroupMemoryBarrierWithGroupSync();

	// Allocate node space
	float PixelCoverage = 0;
	if (NodeDesc.Count > 0)
	{
		NodeDesc.Offset += AllocationNodeOffset;

		// Store final sort node data 
		if (NodeDesc.Offset + NodeDesc.Count < MaxNodeCount)
		{
			for (uint OutIndex = 0; OutIndex < NodeDesc.Count; ++OutIndex)
			{
				// VisibilityData.Coverage8bit is a weight normalising to 1 the contribution of all the compacted samples. Because later it is weighted by Categorization.PixelCoverage.
				FHairVis OutNodeVis;
				OutNodeVis.PrimitiveId	= Vis_PrimId_MatId[OutIndex].x;
				OutNodeVis.MaterialId	= Vis_PrimId_MatId[OutIndex].y;
				OutNodeVis.Depth		= Vis_Depth_Cov[OutIndex].x;
				OutNodeVis.Coverage8bit = To8bitCoverage(Vis_Depth_Cov[OutIndex].y / TotalCoverage); 

				const uint StoreIndex = NodeDesc.Offset + OutIndex;
				OutCompactNodeVis[StoreIndex] = PackHairVis(OutNodeVis);
				OutCompactNodeCoord[StoreIndex] = PixelCoord;
			}

			PixelCoverage = TransmittanceToCoverage(ViewTransmittanceTexture.Load(uint3(PixelCoord, 0)), CoverageThreshold);
		}
	}

	OutCompactNodeIndex[PixelCoord] = EncodeNodeDesc(NodeDesc);
	OutCoverageTexture[PixelCoord] = PixelCoverage;
}
