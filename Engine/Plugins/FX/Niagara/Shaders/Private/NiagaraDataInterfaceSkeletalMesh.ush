// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NiagaraBaryCentricUtils.ush"

#define DISKELMESH_BONE_INFLUENCES_MAX4			0
#define DISKELMESH_BONE_INFLUENCES_MAX8			1
#define DISKELMESH_BONE_INFLUENCES_UNLIMITED	2

#ifndef DISKELMESH_BONE_INFLUENCES
#define DISKELMESH_BONE_INFLUENCES	DISKELMESH_BONE_INFLUENCES_UNLIMITED
#endif

#define DISKELMESH_PROBALIAS_FORMAT_64			0		// 64 bits : Float probability	: uint alias
#define DISKELMESH_PROBALIAS_FORMAT_24_8		1		// 32 bits : 8 bits probability	: 24 bits alias
#define DISKELMESH_PROBALIAS_FORMAT_23_9		2		// 32 bits : 9 bits probability	: 23 bits alias

#ifndef DISKELMESH_PROBALIAS_FORMAT
#define DISKELMESH_PROBALIAS_FORMAT	DISKELMESH_PROBALIAS_FORMAT_64
#endif

#define DISKELMESH_ADJ_INDEX_FORMAT_FULL 0				// 32 bits
#define DISKELMESH_ADJ_INDEX_FORMAT_HALF 1				// 16 bits

#ifndef DISKELMESH_ADJ_INDEX_FORMAT
#define DISKELMESH_ADJ_INDEX_FORMAT DISKELMESH_ADJ_INDEX_FORMAT_FULL
#endif

struct FDISkelMeshContext
{
	Buffer<uint>	MeshIndexBuffer;
	Buffer<float>	MeshVertexBuffer;
	Buffer<uint>	MeshSkinWeightBuffer;
	Buffer<uint>	MeshSkinWeightLookupBuffer;
	Buffer<float4>	MeshCurrBonesBuffer;
	Buffer<float4>	MeshPrevBonesBuffer;
	Buffer<float4>	MeshCurrSamplingBonesBuffer;
    Buffer<float4>	MeshPrevSamplingBonesBuffer;
	Buffer<float4>	MeshTangentBuffer;
	Buffer<float2>	MeshTexCoordBuffer;
    Buffer<float4>	MeshColorBuffer;
	Buffer<uint>	MeshTriangleSamplerProbAliasBuffer;
	uint			MeshNumSamplingRegionTriangles;
	uint			MeshNumSamplingRegionVertices;
	Buffer<uint>	MeshSamplingRegionsProbAliasBuffer;
	Buffer<uint>	MeshSampleRegionsTriangleIndices;
	Buffer<uint>	MeshSampleRegionsVertices;
	Buffer<uint>	MeshTriangleMatricesOffsetBuffer;
	uint			MeshTriangleCount;
	uint			MeshVertexCount;
    uint			MeshWeightStride;
	uint			MeshSkinWeightIndexSize;
	uint			MeshNumTexCoord;
	uint			MeshNumWeights;
	int				NumBones;
	int				NumFilteredBones;
	int				NumUnfilteredBones;
	int				RandomMaxBone;
	int				ExcludeBoneIndex;
	Buffer<uint>	FilteredAndUnfilteredBones;
	int				NumFilteredSockets;
	int				FilteredSocketBoneOffset;
	Buffer<int>		UvMappingBuffer;
	uint			UvMappingBufferLength;
	uint			UvMappingSet;
	Buffer<uint>		ConnectivityBuffer;
	uint			ConnectivityMaxAdjacentPerVertex;
	uint			ConnectivityBufferLength;
	float4x4		InstanceTransform;
	float4x4		InstancePrevTransform;
	float4			InstanceRotation;
	float4			InstancePrevRotation;
	float			InstanceInvDeltaTime;
	bool			UniformTriangleSamplingEnable;
	bool			UniformSamplingRegionEnabled;
	bool			UnlimitedBoneInfluences;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Triangle Sampling

//-TODO: We need to consolodate the random interface inside NiagaraEmitterInstanceShader.usf it's a bit messy at the moment but should follow what FNDIRandomHelper does
float DISKelMesh_Random(uint S1, uint S2, uint S3)
{
	return S3 == 0xffffffff ? NiagaraInternalNoise(S1, S2, S3) : rand(1.0f, S1, S2, S3);
}

struct FDISkelMeshSkinnedVertex
{
	float3	Position;
	float3	PrevPosition;
	float3	TangentX;
	float3	TangentY;
	float3	TangentZ;
};

float3 DISKelMesh_RandomBarycentricCoord(uint Seed1, uint Seed2, uint Seed3)
{
	float r0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	float r1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	float sqrt0 = sqrt(r0);
	float sqrt1 = sqrt(r1);
	return float3(1.0f - sqrt0, sqrt0 * (1.0 - r1), r1 * sqrt0);
}

float3x4 DISkelMesh_GetPrevBoneSkinningMatrix(in FDISkelMeshContext DIContext, uint Bone)
{
    return float3x4(DIContext.MeshPrevBonesBuffer[Bone * 3], DIContext.MeshPrevBonesBuffer[Bone * 3 + 1], DIContext.MeshPrevBonesBuffer[Bone * 3 + 2]);
}

float3x4 DISkelMesh_GetPrevSkinningMatrix(in FDISkelMeshContext DIContext, uint SectionBoneOffset, int4 BlendIndices, float4 BlendWeights)
{
	float3x4 Result;
    Result = DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.x) * BlendWeights.x;
    Result += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.y) * BlendWeights.y;
    Result += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.z) * BlendWeights.z;
    Result += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.w) * BlendWeights.w;
	return Result;
}

float3x4 DISkelMesh_GetCurrBoneSkinningMatrix(in FDISkelMeshContext DIContext, uint Bone)
{
	return float3x4(DIContext.MeshCurrBonesBuffer[Bone * 3], DIContext.MeshCurrBonesBuffer[Bone * 3 + 1], DIContext.MeshCurrBonesBuffer[Bone * 3 + 2]);
}

float3x4 DISkelMesh_GetCurrSkinningMatrix(in FDISkelMeshContext DIContext, uint SectionBoneOffset, int4 BlendIndices, float4 BlendWeights)
{
	float3x4 Result;
    Result = DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.x) * BlendWeights.x;
    Result += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.y) * BlendWeights.y;
    Result += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.z) * BlendWeights.z;
    Result += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, SectionBoneOffset + BlendIndices.w) * BlendWeights.w;
	return Result;
}

int4 DISkelMesh_UnpackIndices4(uint Packed)
{
	return int4(Packed & 0xff, Packed >> 8 & 0xff, Packed >> 16 & 0xff, Packed >> 24 & 0xff);
}

float4 DISkelMesh_UnpackWeights4(uint Packed)
{
	return float4(Packed & 0xff, Packed >> 8 & 0xff, Packed >> 16 & 0xff, Packed >> 24 & 0xff) / 255.0f;
}

void DISkelMesh_GetVertex(in FDISkelMeshContext DIContext, uint VertexIndex, out float3 OutPosition, out float3 OutTangentX, out float3 OutTangentY, out float3 OutTangentZ)
{
	//-TODO: Use a R32G32B32 format
	float3 Position = float3(DIContext.MeshVertexBuffer[VertexIndex * 3], DIContext.MeshVertexBuffer[VertexIndex * 3 + 1], DIContext.MeshVertexBuffer[VertexIndex * 3 + 2]);
	float3 TangentX = TangentBias(DIContext.MeshTangentBuffer[VertexIndex * 2    ].xyz);
	float4 TangentZ = TangentBias(DIContext.MeshTangentBuffer[VertexIndex * 2 + 1].xyzw);	
	float3 TangentY = cross(TangentZ.xyz, TangentX.xyz) * TangentZ.w;

	OutPosition = Position;
	OutTangentX = cross(TangentY, TangentZ.xyz) * TangentZ.w;
	OutTangentY = TangentY;
	OutTangentZ = TangentZ.xyz;
}

void DISkelMesh_GetPointOnTriangle(in FDISkelMeshContext DIContext, uint TriangleIndex, float3 BaryCoord, out float3 OutPosition, out float3 OutTangentX, out float3 OutTangentY, out float3 OutTangentZ)
{
	uint IndexBufferOffset = TriangleIndex * 3;
	uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset];
	uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset + 1];
	uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset + 2];

	float3 Positions[3], TangentsX[3], TangentsY[3], TangentsZ[3];
	DISkelMesh_GetVertex(DIContext, VertexIndex0, Positions[0], TangentsX[0], TangentsY[0], TangentsZ[0]);
	DISkelMesh_GetVertex(DIContext, VertexIndex1, Positions[1], TangentsX[1], TangentsY[1], TangentsZ[1]);
	DISkelMesh_GetVertex(DIContext, VertexIndex2, Positions[2], TangentsX[2], TangentsY[2], TangentsZ[2]);
	OutPosition = Positions[0] * BaryCoord.x + Positions[1] * BaryCoord.y  + Positions[2] * BaryCoord.z;
	OutTangentX = TangentsX[0] * BaryCoord.x + TangentsX[1] * BaryCoord.y  + TangentsX[2] * BaryCoord.z;
	OutTangentY = TangentsY[0] * BaryCoord.x + TangentsY[1] * BaryCoord.y  + TangentsY[2] * BaryCoord.z;
	OutTangentZ = TangentsZ[0] * BaryCoord.x + TangentsZ[1] * BaryCoord.y  + TangentsZ[2] * BaryCoord.z;
}

FDISkelMeshSkinnedVertex DISkelMesh_GetSkinnedVertex(in FDISkelMeshContext DIContext, uint VertexIndex)
{
	//-TODO: Use a R32G32B32 format
	float3 CurrPosition = float3(DIContext.MeshVertexBuffer[VertexIndex * 3], DIContext.MeshVertexBuffer[VertexIndex * 3 + 1], DIContext.MeshVertexBuffer[VertexIndex * 3 + 2]);
	float3 PrevPosition = CurrPosition;

	float3 TangentX = TangentBias(DIContext.MeshTangentBuffer[VertexIndex * 2    ].xyz);
	float4 TangentZ = TangentBias(DIContext.MeshTangentBuffer[VertexIndex * 2 + 1].xyzw);
	
	if ( DIContext.MeshNumWeights > 0 )
	{
		float3x4 PrevBoneMatrix;
		float3x4 CurrBoneMatrix;

		// Get the matrix offset for each vertex because BlendIndices are stored relatively to each section start vertex.
		uint SectionBoneOffset = DIContext.MeshTriangleMatricesOffsetBuffer[VertexIndex];

#if DISKELMESH_BONE_INFLUENCES == DISKELMESH_BONE_INFLUENCES_UNLIMITED
		BRANCH
		if (DIContext.UnlimitedBoneInfluences)
		{
			uint BlendOffsetCount = DIContext.MeshSkinWeightLookupBuffer[VertexIndex];
			int NumBoneInfluences = BlendOffsetCount & 0xff;
			int StreamOffset = BlendOffsetCount >> 8;
			int WeightsOffset = StreamOffset + (DIContext.MeshSkinWeightIndexSize * NumBoneInfluences);

			PrevBoneMatrix = float3x4(float4(0,0,0,0), float4(0,0,0,0), float4(0,0,0,0));
			CurrBoneMatrix = float3x4(float4(0,0,0,0), float4(0,0,0,0), float4(0,0,0,0));
			for (int InfluenceIdx = 0; InfluenceIdx < NumBoneInfluences; InfluenceIdx++)
			{
				int BoneIndexOffset = StreamOffset + (DIContext.MeshSkinWeightIndexSize * InfluenceIdx);
				int BoneIndex = DIContext.MeshSkinWeightBuffer[BoneIndexOffset];
				if (DIContext.MeshSkinWeightIndexSize > 1)
				{
					BoneIndex = DIContext.MeshSkinWeightBuffer[BoneIndexOffset + 1] << 8 | BoneIndex;
					//@todo-lh: Workaround to fix issue in SPIRVEmitter of DXC; this block must be inside the if branch
					float BoneWeight = float(DIContext.MeshSkinWeightBuffer[WeightsOffset + InfluenceIdx]) / 255.0f;

					PrevBoneMatrix += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, SectionBoneOffset + BoneIndex) * BoneWeight;
					CurrBoneMatrix += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, SectionBoneOffset + BoneIndex) * BoneWeight;
				}
				else
				{
					//@todo-lh: Workaround to fix issue in SPIRVEmitter of DXC; this block must be inside the if branch
					float BoneWeight = float(DIContext.MeshSkinWeightBuffer[WeightsOffset + InfluenceIdx]) / 255.0f;

					PrevBoneMatrix += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, SectionBoneOffset + BoneIndex) * BoneWeight;
					CurrBoneMatrix += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, SectionBoneOffset + BoneIndex) * BoneWeight;
				}
			}	
		}
		else
#endif
		{
			uint WeightOffset = DIContext.MeshNumWeights == 8 ? 2 : 1;
			int4 BlendIndices = DISkelMesh_UnpackIndices4(DIContext.MeshSkinWeightBuffer[VertexIndex * DIContext.MeshWeightStride]);
	        float4 BlendWeights = DISkelMesh_UnpackWeights4(DIContext.MeshSkinWeightBuffer[VertexIndex * DIContext.MeshWeightStride + WeightOffset]);
			CurrBoneMatrix = DISkelMesh_GetCurrSkinningMatrix(DIContext, SectionBoneOffset, BlendIndices, BlendWeights);
			PrevBoneMatrix = DISkelMesh_GetPrevSkinningMatrix(DIContext, SectionBoneOffset, BlendIndices, BlendWeights);
#if DISKELMESH_BONE_INFLUENCES != DISKELMESH_BONE_INFLUENCES_MAX4
			// We are in 8 or unlimited mode so need to check for the extended weights
			if (DIContext.MeshNumWeights == 8)
			{
			    BlendIndices = DISkelMesh_UnpackIndices4(DIContext.MeshSkinWeightBuffer[VertexIndex * DIContext.MeshWeightStride + 1]);
			    BlendWeights = DISkelMesh_UnpackWeights4(DIContext.MeshSkinWeightBuffer[VertexIndex * DIContext.MeshWeightStride + WeightOffset + 1]);
				CurrBoneMatrix += DISkelMesh_GetCurrSkinningMatrix(DIContext, SectionBoneOffset, BlendIndices, BlendWeights);
				PrevBoneMatrix += DISkelMesh_GetPrevSkinningMatrix(DIContext, SectionBoneOffset, BlendIndices, BlendWeights);
			}
#endif
		}

		CurrPosition = mul(CurrBoneMatrix, float4(CurrPosition, 1.0f)).xyz;
		PrevPosition = mul(PrevBoneMatrix, float4(PrevPosition, 1.0f)).xyz;

		// Not using InverseTranspose of matrices so assuming uniform scaling only (same as SkinCache)
		TangentX.xyz = mul(CurrBoneMatrix, float4(TangentX.xyz, 0.0f)).xyz;
		TangentZ.xyz = mul(CurrBoneMatrix, float4(TangentZ.xyz, 0.0f)).xyz;
	}

	float3 TangentY = cross(TangentZ.xyz, TangentX.xyz) * TangentZ.w;

	FDISkelMeshSkinnedVertex SkinnedVertex;
	SkinnedVertex.Position = CurrPosition;
	SkinnedVertex.PrevPosition = PrevPosition;
	SkinnedVertex.TangentX = cross(TangentY, TangentZ.xyz) * TangentZ.w;
	SkinnedVertex.TangentY = TangentY;
	SkinnedVertex.TangentZ = TangentZ.xyz;
	return SkinnedVertex;
}

FDISkelMeshSkinnedVertex DISkelMesh_GetSkinnedPointOnTriangle(in FDISkelMeshContext DIContext, uint TriangleIndex, float3 BaryCoord)
{
	uint IndexBufferOffset = TriangleIndex * 3;
	uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset];
	uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset + 1];
	uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset + 2];

	FDISkelMeshSkinnedVertex SkinnedVertex0 = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex0);
	FDISkelMeshSkinnedVertex SkinnedVertex1 = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex1);
	FDISkelMeshSkinnedVertex SkinnedVertex2 = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex2);

	FDISkelMeshSkinnedVertex FinalVertex;
	FinalVertex.Position		= (SkinnedVertex0.Position * BaryCoord.x) + (SkinnedVertex1.Position * BaryCoord.y) + (SkinnedVertex2.Position * BaryCoord.z);
	FinalVertex.PrevPosition	= (SkinnedVertex0.PrevPosition * BaryCoord.x) + (SkinnedVertex1.PrevPosition * BaryCoord.y) + (SkinnedVertex2.PrevPosition * BaryCoord.z);
	FinalVertex.TangentX		= (SkinnedVertex0.TangentX * BaryCoord.x) + (SkinnedVertex1.TangentX * BaryCoord.y) + (SkinnedVertex2.TangentX * BaryCoord.z);
	FinalVertex.TangentY		= (SkinnedVertex0.TangentY * BaryCoord.x) + (SkinnedVertex1.TangentY * BaryCoord.y) + (SkinnedVertex2.TangentY * BaryCoord.z);
	FinalVertex.TangentZ		= (SkinnedVertex0.TangentZ * BaryCoord.x) + (SkinnedVertex1.TangentZ * BaryCoord.y) + (SkinnedVertex2.TangentZ * BaryCoord.z);

	return FinalVertex;
}

FDISkelMeshSkinnedVertex DISkelMesh_GetSkinnedPointOnTriangleWS(in FDISkelMeshContext DIContext, uint TriangleIndex, float3 BaryCoord)
{
	FDISkelMeshSkinnedVertex FinalVertex = DISkelMesh_GetSkinnedPointOnTriangle(DIContext, TriangleIndex, BaryCoord);
	FinalVertex.Position		= mul(float4(FinalVertex.Position, 1.0f), DIContext.InstanceTransform).xyz;
	FinalVertex.PrevPosition	= mul(float4(FinalVertex.PrevPosition, 1.0f), DIContext.InstancePrevTransform).xyz;
	FinalVertex.TangentX		= mul(float4(FinalVertex.TangentX, 0.0f), DIContext.InstanceTransform).xyz;
	FinalVertex.TangentY		= mul(float4(FinalVertex.TangentY, 0.0f), DIContext.InstanceTransform).xyz;
	FinalVertex.TangentZ		= mul(float4(FinalVertex.TangentZ, 0.0f), DIContext.InstanceTransform).xyz;

	return FinalVertex;
}

void DISKelMesh_RandomTriCoord(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutTriangle, out float3 OutBaryCoord)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);

	[branch]
	if ( !DIContext.UniformTriangleSamplingEnable )
	{
		// Uniform triangle id selection
		OutTriangle = min(uint(RandT0 * float(DIContext.MeshTriangleCount)), DIContext.MeshTriangleCount - 1); // avoid % by using mul/min to Tri = MeshTriangleCountName
	}
	else
	{
		// Uniform area weighted position selection (using alias method from Alias method from FWeightedRandomSampler)
		uint TriangleIndex = min(uint(RandT0*float(DIContext.MeshTriangleCount)), DIContext.MeshTriangleCount - 1);

#if DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_64
		float TriangleProbability = asfloat(DIContext.MeshTriangleSamplerProbAliasBuffer[(TriangleIndex * 2) + 0]);
		uint TriangleAlias = DIContext.MeshTriangleSamplerProbAliasBuffer[(TriangleIndex * 2) + 1];
#elif DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_24_8
		uint TriangleProbAlias = DIContext.MeshTriangleSamplerProbAliasBuffer[TriangleIndex];
		float TriangleProbability = float(TriangleProbAlias & 0xff) / 255.0f;
		uint TriangleAlias = TriangleProbAlias >> 8;
#elif DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_23_9
		uint TriangleProbAlias = DIContext.MeshTriangleSamplerProbAliasBuffer[TriangleIndex];
		float TriangleProbability = float(TriangleProbAlias & 0x1ff) / 511.0f;
		uint TriangleAlias = TriangleProbAlias >> 9;
#endif

		// Alias check
		float RandT1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
		if( RandT1 > TriangleProbability )
		{
			TriangleIndex = TriangleAlias;
		}
		OutTriangle = int(TriangleIndex);
	}

	OutBaryCoord = DISKelMesh_RandomBarycentricCoord(Seed1, Seed2, Seed3);
}

void DISKelMesh_GetSkinnedTriangleDataWS(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangleWS(DIContext, TriangleIndex, BaryCoord);
	OutPosition	= SkinnedVertex.Position;
	OutVelocity	= (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal	= normalize(SkinnedVertex.TangentZ);
	OutBinormal	= normalize(SkinnedVertex.TangentY);
	OutTangent	= normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetSkinnedTriangleData(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangle(DIContext, TriangleIndex, BaryCoord);
	OutPosition	= SkinnedVertex.Position;
	OutVelocity	= (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal	= normalize(SkinnedVertex.TangentZ);
	OutBinormal	= normalize(SkinnedVertex.TangentY);
	OutTangent	= normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetSkinnedTriangleDataInterpolatedWS(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, in float Interp, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangleWS(DIContext, TriangleIndex, BaryCoord);
	OutPosition	= lerp(SkinnedVertex.PrevPosition, SkinnedVertex.Position, Interp);
	OutVelocity	= (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal	= normalize(SkinnedVertex.TangentZ);
	OutBinormal	= normalize(SkinnedVertex.TangentY);
	OutTangent	= normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetSkinnedTriangleDataInterpolated(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, in float Interp, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangle(DIContext, TriangleIndex, BaryCoord);
	OutPosition	= lerp(SkinnedVertex.PrevPosition, SkinnedVertex.Position, Interp);
	OutVelocity	= (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal	= normalize(SkinnedVertex.TangentZ);
	OutBinormal	= normalize(SkinnedVertex.TangentY);
	OutTangent	= normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetTriUV(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, in int UVSet, out float2 OutUV)
{
    if (DIContext.MeshNumTexCoord > 0)
	{
        uint IndexBufferOffset = TriangleIndex * 3;
		uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset  ];
		uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset+1];
		uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset+2];

        uint Stride = DIContext.MeshNumTexCoord;
        uint SelectedUVSet = clamp((uint) UVSet, 0, DIContext.MeshNumTexCoord - 1);
		float2 UV0 = DIContext.MeshTexCoordBuffer[VertexIndex0 * Stride + SelectedUVSet];
		float2 UV1 = DIContext.MeshTexCoordBuffer[VertexIndex1 * Stride + SelectedUVSet];
		float2 UV2 = DIContext.MeshTexCoordBuffer[VertexIndex2 * Stride + SelectedUVSet];

		OutUV = UV0 * BaryCoord.x + UV1 * BaryCoord.y + UV2 * BaryCoord.z;
	}
	else	
	{
		OutUV = 0.0f;
	}
}

void DISKelMesh_RandomTriangle(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutTriangle, out float3 OutBaryCoord)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	int TriangleIndex = min(int(RandT0 * float(DIContext.MeshTriangleCount)), (int)DIContext.MeshTriangleCount - 1); // avoid % by using mul/min to Tri = MeshTriangleCountName

	[branch]
	if ( DIContext.UniformTriangleSamplingEnable )
	{
		// Uniform area weighted position selection (using alias method from Alias method from FWeightedRandomSampler)
#if DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_64
		float TriangleProbability = asfloat(DIContext.MeshTriangleSamplerProbAliasBuffer[(TriangleIndex * 2) + 0]);
		uint TriangleAlias = DIContext.MeshTriangleSamplerProbAliasBuffer[(TriangleIndex * 2) + 1];
#elif DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_24_8
		uint TriangleProbAlias = DIContext.MeshTriangleSamplerProbAliasBuffer[TriangleIndex];
		float TriangleProbability = float(TriangleProbAlias & 0xff) / 255.0f;
		uint TriangleAlias = TriangleProbAlias >> 8;
#elif DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_23_9
		uint TriangleProbAlias = DIContext.MeshTriangleSamplerProbAliasBuffer[TriangleIndex];
		float TriangleProbability = float(TriangleProbAlias & 0x1ff) / 511.0f;
		uint TriangleAlias = TriangleProbAlias >> 9;
#endif

		// Alias check
		float RandT1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
		if( RandT1 > TriangleProbability )
		{
			TriangleIndex = int(TriangleAlias);
		}
	}

	OutTriangle = TriangleIndex;
	OutBaryCoord = DISKelMesh_RandomBarycentricCoord(Seed1, Seed2, Seed3);
}

void DISKelMesh_GetTriangleCount(in FDISkelMeshContext DIContext, out int OutCount)
{
	OutCount = DIContext.MeshTriangleCount;
}

void DISKelMesh_RandomFilteredTriangle(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutTriangle, out float3 OutBaryCoord)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	uint RegionTriangle = min(uint(RandT0 * float(DIContext.MeshNumSamplingRegionTriangles)), DIContext.MeshNumSamplingRegionTriangles - 1); // avoid % by using mul/min to Tri = MeshTriangleCountName

	[branch]
	if ( DIContext.UniformSamplingRegionEnabled )
	{
#if DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_64
		float TriangleProbability = asfloat(DIContext.MeshSamplingRegionsProbAliasBuffer[(RegionTriangle * 2) + 0]);
		uint TriangleAlias = DIContext.MeshSamplingRegionsProbAliasBuffer[(RegionTriangle * 2) + 1];
#elif DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_24_8
		uint TriangleProbAlias = DIContext.MeshSamplingRegionsProbAliasBuffer[RegionTriangle];
		float TriangleProbability = float(TriangleProbAlias & 0xff) / 255.0f;
		uint TriangleAlias = TriangleProbAlias >> 8;
#elif DISKELMESH_PROBALIAS_FORMAT == DISKELMESH_PROBALIAS_FORMAT_23_9
		uint TriangleProbAlias = DIContext.MeshSamplingRegionsProbAliasBuffer[RegionTriangle];
		float TriangleProbability = float(TriangleProbAlias & 0x1ff) / 511.0f;
		uint TriangleAlias = TriangleProbAlias >> 9;
#endif
		float RandT1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
		if ( RandT1 > TriangleProbability )
		{
			RegionTriangle = TriangleAlias;
		}
	}
	OutTriangle = (int)DIContext.MeshSampleRegionsTriangleIndices[RegionTriangle];
	OutBaryCoord = DISKelMesh_RandomBarycentricCoord(Seed1, Seed2, Seed3);
}

void DISKelMesh_GetFilteredTriangleCount(in FDISkelMeshContext DIContext, out int OutCount)
{
	OutCount = DIContext.MeshNumSamplingRegionTriangles;
}

void DISKelMesh_GetFilteredTriangleAt(in FDISkelMeshContext DIContext, int FilteredIndex, out int OutTriangle)
{
	if ( DIContext.MeshNumSamplingRegionTriangles > 0 )
	{
		FilteredIndex = clamp(FilteredIndex, 0, (int)DIContext.MeshNumSamplingRegionTriangles - 1);
		OutTriangle = (int)DIContext.MeshSampleRegionsTriangleIndices[FilteredIndex];
	}
	else
	{
		OutTriangle = 0;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Uv Mapping

// UvMappingBuffer organized as an array of:
//struct FFrozenNode
//{
//	int32 ChildOffsets[4]
//	int32 ElementCount
//	int32 TriangleIndices[]
//};

#define ElementCountOffset 4
#define TriangleIndexOffset 5
#define MinValidUvMappingBufferSize 24 // minimum size (in bytes) for a quadtree to have valid data

// Evaluates QuadTree for a single point
bool QuadTreeTriangleOverlap(FDISkelMeshContext DIContext, float2 Uv, float Tolerance, int TriangleIndex, out float3 OutBaryCoord)
{
	if (DIContext.MeshNumTexCoord > 0)
	{
        uint IndexBufferOffset = TriangleIndex * 3;
		uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset  ];
		uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset+1];
		uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset+2];

		uint Stride = DIContext.MeshNumTexCoord;
		float2 UV0 = DIContext.MeshTexCoordBuffer[VertexIndex0 * Stride + DIContext.UvMappingSet];
		float2 UV1 = DIContext.MeshTexCoordBuffer[VertexIndex1 * Stride + DIContext.UvMappingSet];
		float2 UV2 = DIContext.MeshTexCoordBuffer[VertexIndex2 * Stride + DIContext.UvMappingSet];

		OutBaryCoord = GetBaryCentric2D(Uv, UV0, UV1, UV2);

		if (all(OutBaryCoord > -Tolerance) && all(OutBaryCoord < (1.0f + Tolerance)))
		{
			return true;
		}
	}

	return false;
}

bool QuadTreeNodeContains(FDISkelMeshContext DIContext, int NodeBufferOffset, float2 Uv, float Tolerance, out int OutTriangleIndex, out float3 OutBaryCoord)
{
	if (NodeBufferOffset == -1)
	{
		return false;
	}

	const int TriangleCount = DIContext.UvMappingBuffer[NodeBufferOffset + ElementCountOffset];
	for (int TriangleIt = 0; TriangleIt < TriangleCount; ++TriangleIt)
	{
		int TriangleIndex = DIContext.UvMappingBuffer[NodeBufferOffset + TriangleIndexOffset + TriangleIt];
		if (QuadTreeTriangleOverlap(DIContext, Uv, Tolerance, TriangleIndex, OutBaryCoord))
		{
			OutTriangleIndex = TriangleIndex;
			return true;
		}
	}

	return false;
}

void DISkelMesh_GetTriangleCoordAtUV(in FDISkelMeshContext DIContext, bool Enabled, float2 InUv, float InTolerance, out int OutTriangle, out float3 OutBaryCoord, out bool OutIsValid)
{
	OutTriangle = -1;
	OutBaryCoord = float3(0.0f, 0.0f, 0.0f);
	OutIsValid = false;

	if (!Enabled || DIContext.UvMappingBufferLength < MinValidUvMappingBufferSize)
	{
		return;
	}

	int NodeBufferOffset = 0;

	float2 MidPoint = float2(0.5f, 0.5f);
	float2 Extent = float2(0.5f, 0.5f);

	while (NodeBufferOffset != -1)
	{
		if (QuadTreeNodeContains(DIContext, NodeBufferOffset, InUv, InTolerance, OutTriangle, OutBaryCoord))
		{
			OutIsValid = true;
			return;
		}

		Extent *= 0.5f;

		const bool LessX = InUv.x < MidPoint.x;
		const bool LessY = InUv.y < MidPoint.y;

		MidPoint += Extent * float2(LessX ? -1.0f : 1.0f, LessY ? -1.0f : 1.0f);
		int ChildIndex = LessX ? (LessY ? 2 : 0) : (LessY ? 3 : 1);

		NodeBufferOffset = DIContext.UvMappingBuffer[NodeBufferOffset + ChildIndex];
	}
}

bool NormalizedAabbTriangleIntersection(float2 A, float2 B, float2 C)
{
	float2 TriAabbMin = float2(min3(A.x, B.x, C.x), min3(A.y, B.y, C.y));
	float2 TriAabbMax = float2(max3(A.x, B.x, C.x), max3(A.y, B.y, C.y));

	if (any(TriAabbMin > 1.0f) || any(TriAabbMax < 0.0f))
	{
		return false;
	}

	#define AXIS_COUNT 3
	float2 TriangleEdges[AXIS_COUNT] = { C - B, A - C, B - A };

	for (int i = 0; i < AXIS_COUNT; ++i)
	{
		float2 Axis = TriangleEdges[i].yx * (float2(-1.0f, 0.0f));
		float AabbSegmentMin = min(0.0f, min3(Axis.x, Axis.y, Axis.x + Axis.y));
		float AabbSegmentMax = max(0.0f, max3(Axis.x, Axis.y, Axis.x + Axis.y));
		float TriangleSegmentMin = min3(dot(A, Axis), dot(B, Axis), dot(C, Axis));
		float TriangleSegmentMax = max3(dot(A, Axis), dot(B, Axis), dot(C, Axis));
		if (AabbSegmentMin > TriangleSegmentMax || AabbSegmentMax < TriangleSegmentMin)
		{
			return false;
		}
	}

	return true;
}

// Evaluates QuadTree for an AABB region
bool QuadTreeTriangleAabbOverlap(FDISkelMeshContext DIContext, float2 UvRef, float2 UvExtentScale, float2 UvExtentBias, int TriangleIndex, out float3 OutBaryCoord)
{
	if (DIContext.MeshNumTexCoord > 0)
	{
        uint IndexBufferOffset = TriangleIndex * 3;
		uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset  ];
		uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset+1];
		uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset+2];

		uint Stride = DIContext.MeshNumTexCoord;
		float2 UV0 = DIContext.MeshTexCoordBuffer[VertexIndex0 * Stride + DIContext.UvMappingSet];
		float2 UV1 = DIContext.MeshTexCoordBuffer[VertexIndex1 * Stride + DIContext.UvMappingSet];
		float2 UV2 = DIContext.MeshTexCoordBuffer[VertexIndex2 * Stride + DIContext.UvMappingSet];

		// evaluate whether our triangle intersects with our AABB, if it does, then generate the barycentric coordinate for the center of the AABB
		const bool Intersection = NormalizedAabbTriangleIntersection(
				UV0 * UvExtentScale + UvExtentBias,
				UV1 * UvExtentScale + UvExtentBias,
				UV2 * UvExtentScale + UvExtentBias);

		if (Intersection)
		{
			OutBaryCoord = GetClosestBaryCentric2D(UvRef, UV0, UV1, UV2);
			return true;
		}
	}

	return false;
}

bool QuadTreeNodeContainsAabb(FDISkelMeshContext DIContext, int NodeBufferOffset, float2 UvMin, float2 UvMax, out int OutTriangleIndex, out float3 OutBaryCoord)
{
	if (NodeBufferOffset == -1)
	{
		return false;
	}

	const int TriangleCount = DIContext.UvMappingBuffer[NodeBufferOffset + ElementCountOffset];
	if (TriangleCount == 0)
	{
		return false;
	}

	const float2 UvRef = 0.5f * (UvMin + UvMax);
	const float2 UvExtentScale = 1.0f / (UvMax - UvMin);
	const float2 UvExtentBias = 1.0f - UvMax * UvExtentScale;

	for (int TriangleIt = 0; TriangleIt < TriangleCount; ++TriangleIt)
	{
		float3 BaryCoord;
		int TriangleIndex = DIContext.UvMappingBuffer[NodeBufferOffset + TriangleIndexOffset + TriangleIt];
		if (QuadTreeTriangleAabbOverlap(DIContext, UvRef, UvExtentScale, UvExtentBias, TriangleIndex, BaryCoord))
		{
			OutTriangleIndex = TriangleIndex;
			OutBaryCoord = BaryCoord;
			return true;
		}
	}

	return false;
}

void DISkelMesh_GetTriangleCoordInAabb(FDISkelMeshContext DIContext, bool Enabled, float2 InUvMin, float2 InUvMax, out int OutTriangle, out float3 OutBaryCoord, out bool OutIsValid)
{
	OutTriangle = -1;
	OutBaryCoord = float3(0.0f, 0.0f, 0.0f);
	OutIsValid = false;

	if (!Enabled || DIContext.UvMappingBufferLength < MinValidUvMappingBufferSize)
	{
		return;
	}

	int NodeBufferOffset = 0;

	const float2 UvRegionCenter = 0.5f * (InUvMin + InUvMax);
	float2 MidPoint = float2(0.5f, 0.5f);
	float2 Extent = float2(0.5f, 0.5f);

	while (NodeBufferOffset != -1)
	{
		if (QuadTreeNodeContainsAabb(DIContext, NodeBufferOffset, InUvMin, InUvMax, OutTriangle, OutBaryCoord))
		{
			OutIsValid = true;
			return;
		}

		Extent *= 0.5f;

		const bool LessX = UvRegionCenter.x < MidPoint.x;
		const bool LessY = UvRegionCenter.y < MidPoint.y;

		MidPoint += Extent * float2(LessX ? -1.0f : 1.0f, LessY ? -1.0f : 1.0f);
		int ChildIndex = LessX ? (LessY ? 2 : 0) : (LessY ? 3 : 1);

		NodeBufferOffset = DIContext.UvMappingBuffer[NodeBufferOffset + ChildIndex];
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Bone Sampling

float4 DISKelMesh_QuatSlerp(float4 Quat1, float4 Quat2, float Slerp)
{
    const float RawCosom = dot(Quat1, Quat2);
    const float Cosom = abs(RawCosom);
	
    float Scale0, Scale1;
    if (Cosom < 0.9999f)
    {
        const float Omega = acos(Cosom);
        const float InvSin = 1.f / sin(Omega);
        Scale0 = sin((1.f - Slerp) * Omega) * InvSin;
        Scale1 = sin(Slerp * Omega) * InvSin;
    }
    else
    {
        Scale0 = 1.0f - Slerp;
        Scale1 = Slerp;
    }

	// In keeping with our flipped Cosom:
    Scale1 = RawCosom >= 0.0f ? Scale1 : -Scale1;

    return (Scale0 * Quat1) + (Scale1 * Quat2);
}

void DISkelMesh_GetSkinnedBoneCommon(in FDISkelMeshContext DIContext, in int Bone, in float Interp, in bool bWorldSpace, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    float3 PrevPosition = DIContext.MeshPrevSamplingBonesBuffer[Bone * 3].xyz;
    float4 PrevRotation = DIContext.MeshPrevSamplingBonesBuffer[Bone * 3 + 1];
    float3 CurrPosition = DIContext.MeshCurrSamplingBonesBuffer[Bone * 3].xyz;
    float4 CurrRotation = DIContext.MeshCurrSamplingBonesBuffer[Bone * 3 + 1];

    if (bWorldSpace)
    {
        PrevPosition = mul(float4(PrevPosition, 1), DIContext.InstancePrevTransform).xyz;
        CurrPosition = mul(float4(CurrPosition, 1), DIContext.InstanceTransform).xyz;
		PrevRotation = NiagaraGPU_QuatMul(DIContext.InstancePrevRotation, PrevRotation);
		CurrRotation = NiagaraGPU_QuatMul(DIContext.InstanceRotation, CurrRotation);
    }
    CurrPosition = lerp(PrevPosition, CurrPosition, Interp);

    OutPosition = CurrPosition;
    OutRotation = DISKelMesh_QuatSlerp(PrevRotation, CurrRotation, Interp);
    OutVelocity = (CurrPosition - PrevPosition) * DIContext.InstanceInvDeltaTime;
}

void DISkelMesh_GetSkinnedBone(in FDISkelMeshContext DIContext, in int Bone, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, 1.0f, false, OutPosition, OutRotation, OutVelocity);
}

void DISkelMesh_GetSkinnedBoneInterpolated(in FDISkelMeshContext DIContext, in int Bone, in float Interp, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, Interp, false, OutPosition, OutRotation, OutVelocity);
}

void DISkelMesh_GetSkinnedBoneWS(in FDISkelMeshContext DIContext, in int Bone, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, 1.0f, true, OutPosition, OutRotation, OutVelocity);
}

void DISkelMesh_GetSkinnedBoneInterpolatedWS(in FDISkelMeshContext DIContext, in int Bone, in float Interp, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, Interp, true, OutPosition, OutRotation, OutVelocity);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vertex Sampling

void DISkelMesh_GetTriVertices(in FDISkelMeshContext DIContext, in uint TriangleIndex, out int VertexIndex0, out int VertexIndex1, out int VertexIndex2)
{
    uint IndexBufferOffset = TriangleIndex * 3;
    VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset];
    VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset + 1];
    VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset + 2];
}

void DISkelMesh_GetTriColor(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, out float4 OutColor)
{
    uint IndexBufferOffset = TriangleIndex * 3;
    uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset];
    uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset + 1];
    uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset + 2];
    OutColor = (DIContext.MeshColorBuffer[VertexIndex0] FMANUALFETCH_COLOR_COMPONENT_SWIZZLE * BaryCoord.x) + (DIContext.MeshColorBuffer[VertexIndex1] FMANUALFETCH_COLOR_COMPONENT_SWIZZLE * BaryCoord.y) + (DIContext.MeshColorBuffer[VertexIndex2] FMANUALFETCH_COLOR_COMPONENT_SWIZZLE * BaryCoord.z);
}

void DISkelMesh_GetSkinnedVertex(in FDISkelMeshContext DIContext, in int VertexIndex, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex);
    OutPosition = SkinnedVertex.Position;
    OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal = SkinnedVertex.TangentZ;
	OutBinormal = SkinnedVertex.TangentY;
	OutTangent = SkinnedVertex.TangentX;
}

void DISkelMesh_GetSkinnedVertexWS(in FDISkelMeshContext DIContext, in int VertexIndex, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex);
    OutPosition = mul(float4(SkinnedVertex.Position, 1.0f), DIContext.InstanceTransform).xyz;
    float3 PrevPosition = mul(float4(SkinnedVertex.PrevPosition, 1.0f), DIContext.InstancePrevTransform).xyz;
    OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
    OutNormal   = normalize(mul(float4(SkinnedVertex.TangentZ, 0.0f), DIContext.InstanceTransform).xyz);
    OutBinormal = normalize(mul(float4(SkinnedVertex.TangentY, 0.0f), DIContext.InstanceTransform).xyz);
    OutTangent  = normalize(mul(float4(SkinnedVertex.TangentX, 0.0f), DIContext.InstanceTransform).xyz);
}

void DISkelMesh_GetVertexColor(in FDISkelMeshContext DIContext, in int VertexIndex, out float4 OutColor)
{
    OutColor = DIContext.MeshColorBuffer[VertexIndex] FMANUALFETCH_COLOR_COMPONENT_SWIZZLE;
}

void DISkelMesh_GetVertexUV(in FDISkelMeshContext DIContext, in int VertexIndex, in int UVSet, out float2 OutUV)
{
    if (DIContext.MeshNumTexCoord > 0)
    {
        uint Stride = DIContext.MeshNumTexCoord;
        uint SelectedUVSet = clamp((uint) UVSet, 0, DIContext.MeshNumTexCoord - 1);
        OutUV = DIContext.MeshTexCoordBuffer[VertexIndex * Stride + SelectedUVSet];
    }
    else
    {
        OutUV = 0.0f;
    }
}

void DISkelMesh_IsValidVertex(in FDISkelMeshContext DIContext, int Vertex, out bool IsValid)
{
    IsValid = Vertex < (int)DIContext.MeshVertexCount;
}

void DISkelMesh_GetRandomVertex(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutVertex)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	OutVertex = (int)min(uint(RandT0 * float(DIContext.MeshVertexCount)), DIContext.MeshVertexCount - 1); // avoid % by using mul/min to Tri = MeshVertexCount
}

void DISkelMesh_GetVertexCount(in FDISkelMeshContext DIContext, out int VertexCount)
{
	VertexCount = (int)DIContext.MeshVertexCount;
}

void DISkelMesh_IsValidFilteredVertex(in FDISkelMeshContext DIContext, int FilteredIndex, out bool IsValid)
{
	IsValid = FilteredIndex < (int)DIContext.MeshNumSamplingRegionVertices;
}

void DISkelMesh_GetRandomFilteredVertex(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutVertex)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	int FilteredIndex = (int)min(uint(RandT0 * float(DIContext.MeshNumSamplingRegionVertices)), DIContext.MeshNumSamplingRegionVertices - 1); // avoid % by using mul/min to Tri = MeshVertexCount
	OutVertex = (int)DIContext.MeshSampleRegionsVertices[FilteredIndex];
}

void DISkelMesh_GetFilteredVertexCount(in FDISkelMeshContext DIContext, out int VertexCount)
{
	VertexCount = (int)DIContext.MeshNumSamplingRegionVertices;
}

void DISkelMesh_GetFilteredVertexAt(in FDISkelMeshContext DIContext, int FilteredIndex, out int VertexIndex)
{
	FilteredIndex = clamp(FilteredIndex, 0, (int)DIContext.MeshNumSamplingRegionVertices - 1);
	VertexIndex = (int)DIContext.MeshSampleRegionsVertices[FilteredIndex];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Filtered Bones / Sockets
void DISkelMesh_IsValidBone(in FDISkelMeshContext DIContext, in int BoneIndex, out bool IsValid)
{
	IsValid = BoneIndex >= 0 && BoneIndex < DIContext.NumBones;
}

void DISkelMesh_RandomBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	Bone = min(int(RandT0 * float(DIContext.RandomMaxBone)), DIContext.RandomMaxBone);
	Bone = Bone != DIContext.ExcludeBoneIndex ? Bone : Bone + 1;
}

void DISkelMesh_GetBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
	Count = DIContext.NumBones;
}

void DISkelMesh_GetParentBone(in FDISkelMeshContext DIContext, int BoneIndex, out int ParentIndex)
{
	ParentIndex = -1;
	if ( BoneIndex >= 0 && BoneIndex < DIContext.NumBones )
	{
		ParentIndex = asint(DIContext.MeshCurrSamplingBonesBuffer[BoneIndex * 3 + 2].w);
		
	}
}

void DISkelMesh_GetFilteredBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
    Count = DIContext.NumFilteredBones;
}

void DISkelMesh_GetFilteredBoneAt(in FDISkelMeshContext DIContext, in int InBoneIndex, out int Bone)
{
    int BoneIndex = min(InBoneIndex, DIContext.NumFilteredBones - 1);
    Bone = (int)DIContext.FilteredAndUnfilteredBones[BoneIndex];
}

void DISkelMesh_RandomFilteredBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
    int FilteredBone = min(int(RandT0 * float(DIContext.NumFilteredBones)), DIContext.NumFilteredBones - 1); // avoid % by using mul/min to Tri = MeshVertexCount
    Bone = (int)DIContext.FilteredAndUnfilteredBones[FilteredBone];
}

void DISkelMesh_GetUnfilteredBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
    Count = DIContext.NumUnfilteredBones;
}

void DISkelMesh_GetUnfilteredBoneAt(in FDISkelMeshContext DIContext, in int InBoneIndex, out int Bone)
{
    int BoneIndex = min(InBoneIndex, DIContext.NumUnfilteredBones - 1);
    Bone = DIContext.NumFilteredBones > 0 ? (int)DIContext.FilteredAndUnfilteredBones[BoneIndex + DIContext.NumFilteredBones] : BoneIndex;
}

void DISkelMesh_RandomUnfilteredBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	if ( DIContext.NumFilteredBones == 0 )
	{
		Bone = min(int(RandT0 * float(DIContext.RandomMaxBone)), DIContext.RandomMaxBone);
		Bone = Bone != DIContext.ExcludeBoneIndex ? Bone : Bone + 1;
	}
	else
	{
		int UnfilteredBone = min(int(RandT0 * float(DIContext.NumUnfilteredBones)), DIContext.NumUnfilteredBones - 1); // avoid % by using mul/min to Tri = MeshVertexCount
		Bone = DIContext.NumFilteredBones > 0 ? (int)DIContext.FilteredAndUnfilteredBones[UnfilteredBone + DIContext.NumFilteredBones] : UnfilteredBone;
	}
}

void DISkelMesh_GetFilteredSocketCount(in FDISkelMeshContext DIContext, out int Count)
{
    Count = DIContext.NumFilteredSockets;
}

void DISkelMesh_GetFilteredSocketTransform(in FDISkelMeshContext DIContext, in int SocketIndex, in bool bApplyTransform, out float3 OutTranslation, out float4 OutRotation, out float3 OutScale)
{
    if ( DIContext.NumFilteredSockets > 0 )
	{
		SocketIndex = clamp(SocketIndex, 0, DIContext.NumFilteredSockets - 1);
		int BufferOffset = (DIContext.FilteredSocketBoneOffset + SocketIndex) * 3;

		OutTranslation = DIContext.MeshCurrSamplingBonesBuffer[BufferOffset + 0].xyz;
		OutRotation = DIContext.MeshCurrSamplingBonesBuffer[BufferOffset + 1];
		OutScale = DIContext.MeshCurrSamplingBonesBuffer[BufferOffset + 2].xyz;

		if (bApplyTransform)
		{
			OutTranslation = mul(float4(OutTranslation, 1), DIContext.InstanceTransform).xyz;
			OutRotation = NiagaraGPU_QuatMul(DIContext.InstanceRotation, OutRotation);
			OutScale = mul(OutScale, (float3x3)DIContext.InstanceTransform);
		}
	}
	else
	{
		OutTranslation = float3(0.0f, 0.0f, 0.0f);
		OutRotation = float4(0.0f, 0.0f, 0.0f, 1.0f);
		OutScale = float3(0.0f, 0.0f, 0.0f);
	}
}

void DISkelMesh_GetFilteredSocketBoneAt(in FDISkelMeshContext DIContext, in int InSocketIndex, out int Bone)
{
    Bone = DIContext.FilteredSocketBoneOffset + clamp(InSocketIndex, 0, DIContext.NumFilteredSockets - 1);
}

void DISkelMesh_RandomFilteredSocket(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int SocketBone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
    SocketBone = DIContext.FilteredSocketBoneOffset + min(int(RandT0 * float(DIContext.NumFilteredSockets)), DIContext.NumFilteredSockets - 1); // avoid % by using mul/min to Tri = MeshVertexCount
}

void DISkelMesh_RandomFilteredSocketOrBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	int NumFilteredSocketsAndBones = DIContext.NumFilteredBones + DIContext.NumFilteredSockets;
    int FilteredIndex = min(int(RandT0 * float(NumFilteredSocketsAndBones)), NumFilteredSocketsAndBones - 1);
	if ( FilteredIndex < DIContext.NumFilteredBones )
	{
		Bone = (int)DIContext.FilteredAndUnfilteredBones[FilteredIndex];
	}
	else
	{
		Bone = DIContext.FilteredSocketBoneOffset + FilteredIndex - DIContext.NumFilteredBones;
	}
}

void DISkelMesh_GetFilteredSocketOrBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
	Count = DIContext.NumFilteredBones + DIContext.NumFilteredSockets;
}

void DISkelMesh_GetFilteredSocketOrBoneAt(in FDISkelMeshContext DIContext, int FilteredIndex, out int Bone)
{
	int NumFilteredSocketsAndBones = DIContext.NumFilteredBones + DIContext.NumFilteredSockets;
	FilteredIndex = clamp(FilteredIndex, 0, NumFilteredSocketsAndBones - 1);
	if ( FilteredIndex < DIContext.NumFilteredBones )
	{
		Bone = (int)DIContext.FilteredAndUnfilteredBones[FilteredIndex];
	}
	else
	{
		Bone = DIContext.FilteredSocketBoneOffset + FilteredIndex - DIContext.NumFilteredBones;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Connectivity

void DISkelMesh_GetAdjacentTriangleIndex(in FDISkelMeshContext DIContext, int VertexId, uint AdjacencyIndex, out int TriangleIndex)
{
	TriangleIndex = -1;

	if (AdjacencyIndex < DIContext.ConnectivityMaxAdjacentPerVertex)
	{
#if DISKELMESH_ADJ_INDEX_FORMAT == DISKELMESH_ADJ_INDEX_FORMAT_FULL
		const uint ReadIndex = (VertexId * DIContext.ConnectivityMaxAdjacentPerVertex + AdjacencyIndex);
		if (ReadIndex < DIContext.ConnectivityBufferLength)
		{
			TriangleIndex = DIContext.ConnectivityBuffer[ReadIndex];
		}
#elif DISKELMESH_ADJ_INDEX_FORMAT == DISKELMESH_ADJ_INDEX_FORMAT_HALF
		const uint ReadIndex = ((VertexId * DIContext.ConnectivityMaxAdjacentPerVertex + AdjacencyIndex) & ~0x1) >> 1;
		if (ReadIndex < DIContext.ConnectivityBufferLength)
		{
			uint PackedIndices = DIContext.ConnectivityBuffer[ReadIndex];
			uint UnpackedIndex = uint2(PackedIndices & 0xFFFF, PackedIndices >> 16)[AdjacencyIndex & 1];
			TriangleIndex = UnpackedIndex == 0xFFFF ? -1 : int(UnpackedIndex);
		}
#else
		#error Unsupported index format for adjacency information
#endif
	}
}

bool IsAdjacent(FDISkelMeshContext DIContext, int VertexIndex, int TriangleIndex)
{
	for (uint AdjIt = 0; AdjIt < DIContext.ConnectivityMaxAdjacentPerVertex; ++AdjIt)
	{
		int AdjTriangleIndex = -1;
		DISkelMesh_GetAdjacentTriangleIndex(DIContext, VertexIndex, AdjIt, AdjTriangleIndex);
		if (AdjTriangleIndex == -1)
		{
			break;
		}
		if (AdjTriangleIndex == TriangleIndex)
		{
			return true;
		}
	}
	return false;
}

void DISkelMesh_GetTriangleNeighbor(in FDISkelMeshContext DIContext, int TriangleIndex, int EdgeIndex, out int NeighborTriangleIndex, out int NeighborEdgeIndex)
{
	NeighborTriangleIndex = -1;
	NeighborEdgeIndex = -1;

	int3 SourceVertexIndices;

	DISkelMesh_GetTriVertices(DIContext, TriangleIndex, SourceVertexIndices.x, SourceVertexIndices.y, SourceVertexIndices.z);

	int StartSourceIndex = SourceVertexIndices[(EdgeIndex + 1) % 3];
	int EndSourceIndex = SourceVertexIndices[(EdgeIndex + 2) % 3];

	for (uint SourceAdjIt = 0; SourceAdjIt < DIContext.ConnectivityMaxAdjacentPerVertex; ++SourceAdjIt)
	{
		int SourceAdjTriangleIndex = -1;
		DISkelMesh_GetAdjacentTriangleIndex(DIContext, StartSourceIndex, SourceAdjIt, SourceAdjTriangleIndex);

		if (SourceAdjTriangleIndex == TriangleIndex) // ignore self
		{
			continue;
		}
		if (SourceAdjTriangleIndex == -1) // stop looking
		{
			break;
		}

		if (IsAdjacent(DIContext, EndSourceIndex, SourceAdjTriangleIndex))
		{
			NeighborTriangleIndex = SourceAdjTriangleIndex;

			// now to find the edge index for the neighbor
			int3 NeighborVertexIndices;
			DISkelMesh_GetTriVertices(DIContext, NeighborTriangleIndex, NeighborVertexIndices.x, NeighborVertexIndices.y, NeighborVertexIndices.z);

			bool3 NeighborVertMatches = bool3(
				IsAdjacent(DIContext, NeighborVertexIndices.x, TriangleIndex),
				IsAdjacent(DIContext, NeighborVertexIndices.y, TriangleIndex),
				IsAdjacent(DIContext, NeighborVertexIndices.z, TriangleIndex));

			if (all(NeighborVertMatches.xy))
			{
				NeighborEdgeIndex = 2;
			}
			else if (all(NeighborVertMatches.yz))
			{
				NeighborEdgeIndex = 0;
			}
			else if (all(NeighborVertMatches.zx))
			{
				NeighborEdgeIndex = 1;
			}
			break;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DISKELMESH_DECLARE_CONSTANTS(NAME) \
	Buffer<uint>	MeshIndexBuffer_ ## NAME; \
	Buffer<float>	MeshVertexBuffer_ ## NAME; \
	Buffer<uint>	MeshSkinWeightBuffer_ ## NAME; \
	Buffer<uint>	MeshSkinWeightLookupBuffer_ ## NAME; \
	Buffer<float4>	MeshCurrBonesBuffer_ ## NAME; \
	Buffer<float4>	MeshPrevBonesBuffer_ ## NAME; \
	Buffer<float4>	MeshCurrSamplingBonesBuffer_ ## NAME; \
	Buffer<float4>	MeshPrevSamplingBonesBuffer_ ## NAME; \
	Buffer<float4>	MeshTangentBuffer_ ## NAME; \
	Buffer<float2>	MeshTexCoordBuffer_ ## NAME; \
	Buffer<float4>	MeshColorBuffer_ ## NAME; \
	Buffer<uint>	MeshTriangleSamplerProbAliasBuffer_ ## NAME; \
	uint			MeshNumSamplingRegionTriangles_ ## NAME; \
	uint			MeshNumSamplingRegionVertices_ ## NAME; \
	Buffer<uint>	MeshSamplingRegionsProbAliasBuffer_ ## NAME; \
	Buffer<uint>	MeshSampleRegionsTriangleIndices_ ## NAME; \
	Buffer<uint>	MeshSampleRegionsVertices_ ## NAME; \
	Buffer<uint>	MeshTriangleMatricesOffsetBuffer_ ## NAME; \
	uint			MeshTriangleCount_ ## NAME; \
	uint			MeshVertexCount_ ## NAME; \
	uint			MeshWeightStride_ ## NAME; \
	uint			MeshSkinWeightIndexSize_ ## NAME; \
	uint			MeshNumTexCoord_ ## NAME; \
	uint			MeshNumWeights_ ## NAME; \
	int				NumBones_ ## NAME; \
	int				NumFilteredBones_ ## NAME; \
	int				NumUnfilteredBones_ ## NAME; \
	int				RandomMaxBone_ ## NAME; \
	int				ExcludeBoneIndex_ ## NAME; \
	Buffer<uint>	FilteredAndUnfilteredBones_ ## NAME; \
	int				NumFilteredSockets_ ## NAME; \
	int				FilteredSocketBoneOffset_ ## NAME; \
	Buffer<int>		UvMappingBuffer_ ## NAME; \
	uint			UvMappingBufferLength_ ## NAME; \
	uint			UvMappingSet_ ## NAME; \
	Buffer<uint>		ConnectivityBuffer_ ## NAME; \
	uint			ConnectivityBufferLength_ ## NAME; \
	uint			ConnectivityMaxAdjacentPerVertex_ ## NAME; \
	float4x4		InstanceTransform_ ## NAME; \
	float4x4		InstancePrevTransform_ ## NAME; \
	float4			InstanceRotation_ ## NAME; \
	float4			InstancePrevRotation_ ## NAME; \
	float			InstanceInvDeltaTime_ ## NAME; \
	uint			EnabledFeatures_ ## NAME; \

#define DISKELMESH_MAKE_CONTEXT(NAME) \
	FDISkelMeshContext	DIContext; \
	DIContext.MeshIndexBuffer = MeshIndexBuffer_ ## NAME; \
	DIContext.MeshVertexBuffer = MeshVertexBuffer_ ## NAME; \
	DIContext.MeshSkinWeightBuffer = MeshSkinWeightBuffer_ ## NAME; \
	DIContext.MeshSkinWeightLookupBuffer = MeshSkinWeightLookupBuffer_ ## NAME; \
	DIContext.MeshCurrBonesBuffer = MeshCurrBonesBuffer_ ## NAME; \
	DIContext.MeshPrevBonesBuffer = MeshPrevBonesBuffer_ ## NAME; \
	DIContext.MeshCurrSamplingBonesBuffer = MeshCurrSamplingBonesBuffer_ ## NAME; \
	DIContext.MeshPrevSamplingBonesBuffer = MeshPrevSamplingBonesBuffer_ ## NAME; \
	DIContext.MeshTangentBuffer = MeshTangentBuffer_ ## NAME; \
	DIContext.MeshTexCoordBuffer = MeshTexCoordBuffer_ ## NAME; \
	DIContext.MeshColorBuffer = MeshColorBuffer_ ## NAME; \
	DIContext.MeshTriangleSamplerProbAliasBuffer = MeshTriangleSamplerProbAliasBuffer_ ## NAME; \
	DIContext.MeshNumSamplingRegionTriangles = MeshNumSamplingRegionTriangles_ ## NAME; \
	DIContext.MeshNumSamplingRegionVertices = MeshNumSamplingRegionVertices_ ## NAME; \
	DIContext.MeshSamplingRegionsProbAliasBuffer = MeshSamplingRegionsProbAliasBuffer_ ## NAME; \
	DIContext.MeshSampleRegionsTriangleIndices = MeshSampleRegionsTriangleIndices_ ## NAME; \
	DIContext.MeshSampleRegionsVertices = MeshSampleRegionsVertices_ ## NAME; \
	DIContext.MeshTriangleMatricesOffsetBuffer = MeshTriangleMatricesOffsetBuffer_ ## NAME; \
	DIContext.MeshTriangleCount = MeshTriangleCount_ ## NAME; \
	DIContext.MeshVertexCount = MeshVertexCount_ ## NAME; \
	DIContext.MeshNumTexCoord = MeshNumTexCoord_ ## NAME; \
	DIContext.MeshNumWeights = MeshNumWeights_ ## NAME; \
	DIContext.NumBones = NumBones_ ## NAME; \
	DIContext.NumFilteredBones	= NumFilteredBones_ ## NAME; \
	DIContext.NumUnfilteredBones = NumUnfilteredBones_ ## NAME; \
	DIContext.RandomMaxBone = RandomMaxBone_ ## NAME; \
	DIContext.ExcludeBoneIndex = ExcludeBoneIndex_ ## NAME; \
	DIContext.FilteredAndUnfilteredBones	= FilteredAndUnfilteredBones_ ## NAME; \
	DIContext.NumFilteredSockets = NumFilteredSockets_ ## NAME; \
	DIContext.FilteredSocketBoneOffset = FilteredSocketBoneOffset_ ## NAME; \
	DIContext.UvMappingBuffer = UvMappingBuffer_ ## NAME; \
	DIContext.UvMappingBufferLength = UvMappingBufferLength_ ## NAME; \
	DIContext.UvMappingSet = UvMappingSet_ ## NAME; \
	DIContext.ConnectivityBuffer = ConnectivityBuffer_ ## NAME; \
	DIContext.ConnectivityBufferLength = ConnectivityBufferLength_ ## NAME; \
	DIContext.ConnectivityMaxAdjacentPerVertex = ConnectivityMaxAdjacentPerVertex_ ## NAME; \
	DIContext.MeshWeightStride = MeshWeightStride_ ## NAME; \
	DIContext.MeshSkinWeightIndexSize = MeshSkinWeightIndexSize_ ## NAME; \
	DIContext.InstanceTransform = InstanceTransform_ ## NAME; \
	DIContext.InstancePrevTransform = InstancePrevTransform_ ## NAME; \
	DIContext.InstanceRotation = InstanceRotation_ ## NAME; \
	DIContext.InstancePrevRotation = InstancePrevRotation_ ## NAME; \
	DIContext.InstanceInvDeltaTime = InstanceInvDeltaTime_ ## NAME; \
	DIContext.UniformTriangleSamplingEnable = EnabledFeatures_ ## NAME & 0x1; \
	DIContext.UniformSamplingRegionEnabled = EnabledFeatures_ ## NAME & 0x2; \
	DIContext.UnlimitedBoneInfluences = EnabledFeatures_ ## NAME & 0x4; \
