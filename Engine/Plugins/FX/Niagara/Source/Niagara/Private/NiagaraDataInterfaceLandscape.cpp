// Copyright Epic Games, Inc. All Rights Reserved.

#include "NiagaraDataInterfaceLandscape.h"

#include "Algo/RemoveIf.h"
#include "EngineModule.h"
#include "EngineUtils.h"
#include "Landscape.h"
#include "LandscapeHeightfieldCollisionComponent.h"
#include "LandscapeInfo.h"
#include "LandscapeProxy.h"
#include "NiagaraComponent.h"
#include "NiagaraShader.h"
#include "NiagaraStats.h"
#include "NiagaraWorldManager.h"
#include "PhysicalMaterials/PhysicalMaterial.h"
#include "ShaderParameterUtils.h"
#include "VT/RuntimeVirtualTexture.h"

#define LOCTEXT_NAMESPACE "UNiagaraDataInterfaceLandscape"

//////////////////////////////////////////////////////////////////////////
// remaining features
// -getting the albedo colour at a point
// -support for CPU

class FNDI_Landscape_SharedResource;
struct FNDILandscapeData_GameThread;

namespace NiagaraDataInterfaceLandscape
{
	enum Version
	{
		InitialVersion = 0,
		SupportVirtualTextures = 1,
		LWCPosition = 2,

		VersionPlusOne,
		LatestVersion = VersionPlusOne - 1
	};
}

const FName UNiagaraDataInterfaceLandscape::GetBaseColorName(TEXT("GetBaseColor"));
const FName UNiagaraDataInterfaceLandscape::GetHeightName(TEXT("GetHeight"));
const FName UNiagaraDataInterfaceLandscape::GetWorldNormalName(TEXT("GetWorldNormal"));
const FName UNiagaraDataInterfaceLandscape::GetPhysicalMaterialIndexName(TEXT("GetPhysicalMaterialIndex"));

// RenderResource used to hold textures generated by this DI, pulled from the collision geometry of the terrain
class FLandscapeTextureResource : public FRenderResource
{
public:
	FLandscapeTextureResource(const FIntPoint& CellCount);
	virtual ~FLandscapeTextureResource() = default;

	FLandscapeTextureResource() = delete;
	FLandscapeTextureResource(const FLandscapeTextureResource&) = delete;
	FLandscapeTextureResource(const FLandscapeTextureResource&&) = delete;

	virtual void InitRHI() override;
	virtual void ReleaseRHI() override;

	void ReleaseSourceData();

	FRHIShaderResourceView* GetHeightTexture() const { return HeightTexture.SRV; }
	FRHIShaderResourceView* GetPhysMatTexture() const { return PhysMatTexture.SRV; }
	FIntPoint GetDimensions() const { return CellCount; }

	TArray<float>& EditHeightValues(int32 SampleCount);
	TArray<uint8>& EditPhysMatValues(int32 SampleCount);

private:
	FTextureReadBuffer2D HeightTexture;
	FTextureReadBuffer2D PhysMatTexture;
	FIntPoint CellCount;

	TArray<float> HeightValues;
	TArray<uint8> PhysMatValues;

	struct FTextureBulkData : public FResourceBulkDataInterface
	{
		void Init(const void* InData, uint32 InDataSize) { Data = InData; DataSize = InDataSize; }
		void Clear() { Data = nullptr; DataSize = 0; }
		virtual const void* GetResourceBulkData() const override { return Data; }
		virtual uint32 GetResourceBulkDataSize() const override { return DataSize; }
		virtual void Discard() override { }
		const void* Data = nullptr;
		uint32 DataSize = 0;
	};

	FTextureBulkData* GetHeightBulkData() { return HeightBulkData.DataSize > 0 ? &HeightBulkData : nullptr; }
	FTextureBulkData* GetPhysMatBulkData() { return PhysMatBulkData.DataSize > 0 ? &PhysMatBulkData : nullptr; }

	FTextureBulkData HeightBulkData;
	FTextureBulkData PhysMatBulkData;

#if STATS
	int32 GpuMemoryUsage = 0;
#endif
};

// SharedResource that can be held by multiple system instances which manages the resources created by this DI
class FNDI_Landscape_SharedResource
{
public:
	struct FResourceKey
	{
		TWeakObjectPtr<const ALandscape> Source = nullptr;
		TArray<TWeakObjectPtr<const UPhysicalMaterial>> PhysicalMaterials;
		TArray<FIntPoint> CapturedRegions;
		FIntPoint MinCaptureRegion = FIntPoint(ForceInitToZero);
		FIntPoint MaxCaptureRegion = FIntPoint(ForceInitToZero);
		bool IncludesCachedHeight = false;
		bool IncludesCachedPhysMat = false;
	};

	FNDI_Landscape_SharedResource() = delete;
	FNDI_Landscape_SharedResource(const FNDI_Landscape_SharedResource&) = delete;
	FNDI_Landscape_SharedResource(const FResourceKey& InKey);

	bool IsUsed() const;
	bool CanBeDestroyed() const;
	bool CanRepresent(const FResourceKey& InKey) const;

	void RegisterUser(const FNDI_SharedResourceUsage& Usage, bool bNeedsDataImmediately);
	void UnregisterUser(const FNDI_SharedResourceUsage& Usage);

	void UpdateState(bool& LandscapeRemoved);
	void Release();

	TUniquePtr<FLandscapeTextureResource> LandscapeTextures;
	FMatrix ActorToWorldTransform = FMatrix::Identity;
	FMatrix WorldToActorTransform = FMatrix::Identity;
	FVector4 UvScaleBias = FVector4(1.0f, 1.0f, 0.0f, 0.0f);
	FIntPoint CellCount = FIntPoint(ForceInitToZero);
	FVector2D TextureWorldGridSize = FVector2D(1.0f, 1.0f);

private:
	enum class EResourceState : uint8
	{
		Uninitialized,
		Initialized,
		Released,
	};

	void Initialize();

	FResourceKey ResourceKey;

	std::atomic<int32> ShaderPhysicsDataUserCount{ 0 };

	EResourceState CurrentState = EResourceState::Uninitialized;
	EResourceState NextState = EResourceState::Uninitialized;
};

using FNDI_Landscape_SharedResourceHandle = FNDI_SharedResourceHandle<FNDI_Landscape_SharedResource, FNDI_SharedResourceUsage>;

// Landscape data used for the game thread
struct FNDILandscapeData_GameThread
{
	TWeakObjectPtr<ALandscape> Landscape;
	FNDI_Landscape_SharedResourceHandle SharedResourceHandle;
	bool BaseColorVirtualTextureSRGB = false;
	int32 BaseColorVirtualTextureIndex = INDEX_NONE;
	int32 HeightVirtualTextureIndex = INDEX_NONE;
	int32 NormalVirtualTextureIndex = INDEX_NONE;
	ERuntimeVirtualTextureMaterialType NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
	bool RequiresCollisionCacheCpu = false;
	bool RequiresCollisionCacheGpu = false;
	bool RequiresPhysMatCacheGpu = false;

	void Reset()
	{
		Landscape = nullptr;
		SharedResourceHandle = FNDI_Landscape_SharedResourceHandle();
		BaseColorVirtualTextureSRGB = false;
		BaseColorVirtualTextureIndex = INDEX_NONE;
		HeightVirtualTextureIndex = INDEX_NONE;
		NormalVirtualTextureIndex = INDEX_NONE;
		NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
		RequiresCollisionCacheCpu = false;
		RequiresCollisionCacheGpu = false;
		RequiresPhysMatCacheGpu = false;
	}
};

// Landscape data used on the render thread
struct FNDILandscapeData_RenderThread
{
	TWeakObjectPtr<const URuntimeVirtualTexture> BaseColorVirtualTexture;
	TWeakObjectPtr<const URuntimeVirtualTexture> HeightVirtualTexture;
	TWeakObjectPtr<const URuntimeVirtualTexture> NormalVirtualTexture;
	const FLandscapeTextureResource* TextureResources = nullptr;
	bool BaseColorVirtualTextureSRGB = false;
	FVector4 BaseColorVirtualTextureWorldToUvParameters[3];
	FVector4 HeightVirtualTextureWorldToUvParameters[4];
	FVector4 NormalVirtualTextureWorldToUvParameters[3];
	FMatrix CachedHeightTextureWorldToUvTransform = FMatrix::Identity;
	FMatrix CachedHeightTextureUvToWorldTransform = FMatrix::Identity;
	FVector4 CachedHeightTextureUvScaleBias = FVector4(ForceInitToZero);
	FVector2D CachedHeightTextureGridSize = FVector2D(1.0f, 1.0f);
	ERuntimeVirtualTextureMaterialType NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
};

class FNDI_Landscape_GeneratedData : public FNDI_GeneratedData
{
public:
	virtual ~FNDI_Landscape_GeneratedData();
	virtual void Tick(ETickingGroup TickGroup, float DeltaSeconds) override;

	static TypeHash GetTypeHash();

	FNDI_Landscape_SharedResourceHandle GetLandscapeData(const UNiagaraDataInterfaceLandscape& LandscapeDI, const FNiagaraSystemInstance& SystemInstance, const FNDILandscapeData_GameThread& InstanceData, FNDI_SharedResourceUsage Usage, bool bNeedsDataImmediately);

private:
	FRWLock LandscapeDataGuard;
	TArray<TSharedPtr<FNDI_Landscape_SharedResource>> LandscapeData;
	TArray<TSharedPtr<FNDI_Landscape_SharedResource>> ReleasedLandscapeData;
};

struct FNiagaraDataInterfaceProxyLandscape : public FNiagaraDataInterfaceProxy
{
	virtual void ConsumePerInstanceDataFromGameThread(void* PerInstanceData, const FNiagaraSystemInstanceID& Instance) override
	{
		const FNDILandscapeData_RenderThread& SourceData = *reinterpret_cast<const FNDILandscapeData_RenderThread*>(PerInstanceData);
		*SystemInstancesToProxyData_RT.Find(Instance) = SourceData;
	}

	virtual int32 PerInstanceDataPassedToRenderThreadSize() const override
	{
		return sizeof(FNDILandscapeData_RenderThread);
	}

	TMap<FNiagaraSystemInstanceID, FNDILandscapeData_RenderThread> SystemInstancesToProxyData_RT;
};

FLandscapeTextureResource::FLandscapeTextureResource(const FIntPoint& InCellCount)
: CellCount(InCellCount)
{
}

void FLandscapeTextureResource::InitRHI()
{
	if (HeightBulkData.DataSize > 0)
	{
		HeightTexture.Initialize(TEXT("FLandscapeTextureResource_HeightTexture"), sizeof(float), CellCount.X, CellCount.Y, EPixelFormat::PF_R32_FLOAT, FTextureReadBuffer2D::DefaultTextureInitFlag, &HeightBulkData);
	}

	if (PhysMatBulkData.DataSize > 0)
	{
		PhysMatTexture.Initialize(TEXT("FLandscapeTextureResource_PhysMatTexture"), sizeof(uint8), CellCount.X, CellCount.Y, EPixelFormat::PF_R8_UINT, FTextureReadBuffer2D::DefaultTextureInitFlag, &PhysMatBulkData);
	}

	ReleaseSourceData();

#if STATS
	check(GpuMemoryUsage == 0);
	GpuMemoryUsage = HeightTexture.NumBytes + PhysMatTexture.NumBytes;
	INC_MEMORY_STAT_BY(STAT_NiagaraGPUDataInterfaceMemory, GpuMemoryUsage);
#endif
}

void FLandscapeTextureResource::ReleaseRHI()
{
	HeightTexture.Release();
	PhysMatTexture.Release();

#if STATS
	INC_MEMORY_STAT_BY(STAT_NiagaraGPUDataInterfaceMemory, GpuMemoryUsage);
	GpuMemoryUsage = 0;
#endif
}

void FLandscapeTextureResource::ReleaseSourceData()
{
	HeightValues.Empty();
	PhysMatValues.Empty();
}

TArray<float>& FLandscapeTextureResource::EditHeightValues(int32 SampleCount)
{
	const float DefaultHeight = 0.0f;
	HeightValues.Reset(SampleCount);
	HeightValues.Init(DefaultHeight, SampleCount);
	HeightBulkData.Init(HeightValues.GetData(), HeightValues.Num() * HeightValues.GetTypeSize());

	return HeightValues;
}

TArray<uint8>& FLandscapeTextureResource::EditPhysMatValues(int32 SampleCount)
{
	const uint8 DefaultPhysMat = INDEX_NONE;
	PhysMatValues.Reset(SampleCount);
	PhysMatValues.Init(DefaultPhysMat, SampleCount);
	PhysMatBulkData.Init(PhysMatValues.GetData(), PhysMatValues.Num() * PhysMatValues.GetTypeSize());

	return PhysMatValues;
}

FNDI_Landscape_SharedResource::FNDI_Landscape_SharedResource(const FResourceKey& InKey)
: LandscapeTextures(nullptr)
, ResourceKey(InKey)
{
}

bool FNDI_Landscape_SharedResource::IsUsed() const
{
	return (ShaderPhysicsDataUserCount > 0) && CurrentState != EResourceState::Released;
}

bool FNDI_Landscape_SharedResource::CanBeDestroyed() const
{
	const bool ReadyForRemoval = !IsUsed();

	if (ReadyForRemoval && LandscapeTextures && LandscapeTextures->IsInitialized())
	{
		UE_LOG(LogNiagara, Error, TEXT("FNDI_Landscape_SharedResource::CanBeDestroyed returning true, but the LandscpaeTextures is still initialized! Source[%s] MinRegion[%d,%d] MaxRegion[%d,%d]"),
			*GetNameSafe(ResourceKey.Source.Get()), ResourceKey.MinCaptureRegion.X, ResourceKey.MinCaptureRegion.Y, ResourceKey.MaxCaptureRegion.X, ResourceKey.MaxCaptureRegion.Y);
	}

	return ReadyForRemoval;
}

bool FNDI_Landscape_SharedResource::CanRepresent(const FResourceKey& RequestKey) const
{
	if (CurrentState == EResourceState::Released)
	{
		return false;
	}

	if (ResourceKey.Source != RequestKey.Source)
	{
		return false;
	}

	if ((RequestKey.IncludesCachedHeight && !ResourceKey.IncludesCachedHeight)
		|| (RequestKey.IncludesCachedPhysMat && !ResourceKey.IncludesCachedPhysMat))
	{
		return false;
	}

	if (ResourceKey.MinCaptureRegion.X > RequestKey.MinCaptureRegion.X
		|| ResourceKey.MaxCaptureRegion.X < RequestKey.MaxCaptureRegion.X
		|| ResourceKey.MinCaptureRegion.Y > RequestKey.MinCaptureRegion.Y
		|| ResourceKey.MaxCaptureRegion.Y < RequestKey.MaxCaptureRegion.Y)
	{
		return false;
	}

	if (ResourceKey.PhysicalMaterials.Num() < RequestKey.PhysicalMaterials.Num())
	{
		return false;
	}

	for (int32 MaterialIt = 0; MaterialIt < RequestKey.PhysicalMaterials.Num(); ++MaterialIt)
	{
		if (ResourceKey.PhysicalMaterials[MaterialIt] != RequestKey.PhysicalMaterials[MaterialIt])
		{
			return false;
		}
	}

	const int32 CapturedRegionCount = ResourceKey.CapturedRegions.Num();
	int32 SearchIndex = 0;
	for (const FIntPoint& RequestRegion : RequestKey.CapturedRegions)
	{
		while (SearchIndex < CapturedRegionCount && ResourceKey.CapturedRegions[SearchIndex] != RequestRegion)
		{
			++SearchIndex;
		}
	}

	return SearchIndex < CapturedRegionCount;
}

void FNDI_Landscape_SharedResource::RegisterUser(const FNDI_SharedResourceUsage& Usage, bool bNeedsDataImmediately)
{
	check(Usage.RequiresCpuAccess == false);

	if (Usage.RequiresGpuAccess)
	{
		if (ShaderPhysicsDataUserCount++ == 0)
		{
			NextState = EResourceState::Initialized;
		}
	}
}

void FNDI_Landscape_SharedResource::UnregisterUser(const FNDI_SharedResourceUsage& Usage)
{
	check(Usage.RequiresCpuAccess == false);

	if (Usage.RequiresGpuAccess)
	{
		if (--ShaderPhysicsDataUserCount == 0)
		{
			NextState = EResourceState::Released;
		}
	}
}

void FNDI_Landscape_SharedResource::Initialize()
{
	if (const ULandscapeInfo* LandscapeInfo = ResourceKey.Source->GetLandscapeInfo())
	{
		const int32 ComponentQuadCount = ResourceKey.Source->ComponentSizeQuads;
		const FIntPoint RegionSpan = ResourceKey.MaxCaptureRegion - ResourceKey.MinCaptureRegion + FIntPoint(1, 1);
		const FIntPoint CaptureQuadSpan = RegionSpan * ComponentQuadCount;
		const FIntPoint CaptureVertexSpan = CaptureQuadSpan + FIntPoint(1, 1);
		const int32 SampleCount = CaptureVertexSpan.X * CaptureVertexSpan.Y;

		LandscapeTextures = MakeUnique<FLandscapeTextureResource>(CaptureVertexSpan);

		TArray<float>* HeightValues = ResourceKey.IncludesCachedHeight ? &LandscapeTextures->EditHeightValues(SampleCount) : nullptr;
		TArray<uint8>* PhysMatValues = ResourceKey.IncludesCachedPhysMat ? &LandscapeTextures->EditPhysMatValues(SampleCount) : nullptr;

		const FIntPoint RegionVertexBase = ResourceKey.MinCaptureRegion * ComponentQuadCount;

		for (const FIntPoint& Region : ResourceKey.CapturedRegions)
		{
			auto FoundCollisionComponent = LandscapeInfo->XYtoCollisionComponentMap.Find(Region);
			check(FoundCollisionComponent);

			if (FoundCollisionComponent)
			{
				if (const ULandscapeHeightfieldCollisionComponent* CollisionComponent = *FoundCollisionComponent)
				{
					if (HeightValues)
					{
						const FIntPoint SectionBase = (Region - ResourceKey.MinCaptureRegion) * ComponentQuadCount;
						CollisionComponent->FillHeightTile(*HeightValues, SectionBase.X + SectionBase.Y * CaptureVertexSpan.X, CaptureVertexSpan.X);
					}

					if (PhysMatValues)
					{
						const FIntPoint SectionBase = (Region - ResourceKey.MinCaptureRegion) * ComponentQuadCount;
						CollisionComponent->FillMaterialIndexTile(*PhysMatValues, SectionBase.X + SectionBase.Y * CaptureVertexSpan.X, CaptureVertexSpan.X);

						// remap the material index to the list we have on the DI
						TArray<uint8> PhysMatRemap;
						for (const UPhysicalMaterial* ComponentMaterial : CollisionComponent->CookedPhysicalMaterials)
						{
							PhysMatRemap.Emplace(ResourceKey.PhysicalMaterials.IndexOfByKey(ComponentMaterial));
						}

						for (int32 Y = 0; Y < ComponentQuadCount; ++Y)
						{
							for (int32 X = 0; X < ComponentQuadCount; ++X)
							{
								const int32 WriteIndex = SectionBase.X + X + (SectionBase.Y + Y) * CaptureVertexSpan.X;
								uint8& PhysMatIndex = (*PhysMatValues)[WriteIndex];
								PhysMatIndex = PhysMatRemap.IsValidIndex(PhysMatIndex) ? PhysMatRemap[PhysMatIndex] : INDEX_NONE;
							}
						}
					}
				}
			}
		}

		// number of cells that are represented in our heights array
		CellCount = CaptureVertexSpan;

		// mapping to get the UV from 'cell space' which is relative to the entire terrain (not just the captured regions)
		FVector2D UvScale(1.0f / CaptureVertexSpan.X, 1.0f / CaptureVertexSpan.Y);

		UvScaleBias = FVector4(
			UvScale.X,
			UvScale.Y,
			(0.5f - RegionVertexBase.X) * UvScale.X,
			(0.5f - RegionVertexBase.Y) * UvScale.Y);

		ActorToWorldTransform = ResourceKey.Source->GetTransform().ToMatrixWithScale();
		WorldToActorTransform = ActorToWorldTransform.Inverse();
		TextureWorldGridSize = FVector2D(ResourceKey.Source->GetTransform().GetScale3D());

		BeginInitResource(LandscapeTextures.Get());
	}
}

void FNDI_Landscape_SharedResource::Release()
{
	if (FLandscapeTextureResource* Resource = LandscapeTextures.Release())
	{
		ENQUEUE_RENDER_COMMAND(BeginDestroyCommand)([RT_Resource = Resource](FRHICommandListImmediate& RHICmdList)
		{
			RT_Resource->ReleaseResource();

			// On some RHIs textures will push data on the RHI thread
			// Therefore we are not 'released' until the RHI thread has processed all commands
			RHICmdList.EnqueueLambda([RT_Resource](FRHICommandListImmediate& RHICmdList)
				{
					delete RT_Resource;
				});
		});
	}
}

void FNDI_Landscape_SharedResource::UpdateState(bool& LandscapeReleased)
{
	const EResourceState RequestedState = NextState;

	LandscapeReleased = false;

	if (RequestedState == CurrentState)
	{
		return;
	}

	if (RequestedState == EResourceState::Initialized)
	{
		Initialize();
	}
	else if (RequestedState == EResourceState::Released)
	{
		Release();
		LandscapeReleased = true;
	}

	CurrentState = RequestedState;
}

FNDI_Landscape_GeneratedData::~FNDI_Landscape_GeneratedData()
{
	FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);

	for (TSharedPtr<FNDI_Landscape_SharedResource> Landscape : LandscapeData)
	{
		Landscape->Release();
	}
}

void FNDI_Landscape_GeneratedData::Tick(ETickingGroup TickGroup, float DeltaSeconds)
{
	FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);

	{ // handle any changes to the generated data
		TArray<int32, TInlineAllocator<32>> LandscapeToRemove;

		const int32 LandscapeCount = LandscapeData.Num();

		for (int32 LandscapeIt = 0; LandscapeIt < LandscapeCount; ++LandscapeIt)
		{
			TSharedPtr<FNDI_Landscape_SharedResource> Landscape = LandscapeData[LandscapeIt];

			bool LandscapeReleased = false;

			Landscape->UpdateState(LandscapeReleased);

			if (LandscapeReleased)
			{
				LandscapeToRemove.Add(LandscapeIt);
			}
		}

		while (LandscapeToRemove.Num())
		{
			const int32 LandscapeIt = LandscapeToRemove.Pop(false);

			TSharedPtr<FNDI_Landscape_SharedResource> Landscape = LandscapeData[LandscapeIt];
			LandscapeData.RemoveAtSwap(LandscapeIt);

			if (!Landscape->CanBeDestroyed())
			{
				ReleasedLandscapeData.Add(Landscape);
			}
		}
	}

	{ // check any shared resources that we've got pending release to see if they can now be destroyed
		ReleasedLandscapeData.SetNum(Algo::RemoveIf(ReleasedLandscapeData, [&](TSharedPtr<FNDI_Landscape_SharedResource>& Landscape)
		{
			return Landscape->CanBeDestroyed();
		}));
	}
}

FNDI_GeneratedData::TypeHash FNDI_Landscape_GeneratedData::GetTypeHash()
{
	static const TypeHash Hash = ::GetTypeHash(TEXT("FNDI_Landscape_GeneratedData"));
	return Hash;
}

FNDI_Landscape_SharedResourceHandle FNDI_Landscape_GeneratedData::GetLandscapeData(const UNiagaraDataInterfaceLandscape& LandscapeDI, const FNiagaraSystemInstance& SystemInstance, const FNDILandscapeData_GameThread& InstanceData, FNDI_SharedResourceUsage Usage, bool bNeedsDataImmediately)
{
	check(IsInGameThread());

	const ALandscape* Landscape = InstanceData.Landscape.Get();
	const ULandscapeInfo* LandscapeInfo = Landscape ? Landscape->GetLandscapeInfo() : nullptr;

	if (LandscapeInfo == nullptr)
	{
		return FNDI_Landscape_SharedResourceHandle();
	}

	// we want to use the bounds of the system to figure out which cells of the landscape that we need to handle
	const FBox SystemWorldBounds = SystemInstance.GetLocalBounds().TransformBy(SystemInstance.GetWorldTransform());
	const FTransform& LandscapeActorToWorld = Landscape->LandscapeActorToWorld();
	const FVector SystemMinInLandscape = LandscapeActorToWorld.InverseTransformPosition(SystemWorldBounds.Min);
	const FVector SystemMaxInLandscape = LandscapeActorToWorld.InverseTransformPosition(SystemWorldBounds.Max);

	const FBox SystemBoundsInLandscape(
		SystemMinInLandscape.ComponentMin(SystemMaxInLandscape),
		SystemMinInLandscape.ComponentMax(SystemMaxInLandscape));

	// at runtime we don't know the potential number of components in the landscape, so we can only clamp the values to start at 0.
	// Ideally, we'd be able to specify an upper bound as well to further refine the region of overlap.
	const FIntPoint MinBoundRegion = FIntPoint(SystemBoundsInLandscape.Min.X, SystemBoundsInLandscape.Min.Y).ComponentMax(FIntPoint(0, 0));
	const FIntPoint MaxBoundRegion = FIntPoint(SystemBoundsInLandscape.Max.X, SystemBoundsInLandscape.Max.Y).ComponentMax(FIntPoint(0, 0));

	const FIntRect SystemRect = FIntRect(MinBoundRegion, MaxBoundRegion).Scale(1.0f / Landscape->ComponentSizeQuads);

	FNDI_Landscape_SharedResource::FResourceKey Key;
	Key.Source = Landscape;
	Key.MinCaptureRegion = FIntPoint(TNumericLimits<int32>::Max(), TNumericLimits<int32>::Max());
	Key.MaxCaptureRegion = FIntPoint(TNumericLimits<int32>::Min(), TNumericLimits<int32>::Min());

	const int32 MaxSystemRegionCount = (SystemRect.Max.X - SystemRect.Min.X) * (SystemRect.Max.Y - SystemRect.Min.Y);
	const int32 MaxLandscapeRegionCount = LandscapeInfo->XYtoCollisionComponentMap.Num();

	Key.IncludesCachedHeight = InstanceData.RequiresCollisionCacheGpu;
	Key.IncludesCachedPhysMat = InstanceData.RequiresPhysMatCacheGpu;
	Key.PhysicalMaterials.Reserve(LandscapeDI.PhysicalMaterials.Num());
	for (const UPhysicalMaterial* Material : LandscapeDI.PhysicalMaterials)
	{
		Key.PhysicalMaterials.Emplace(Material);
	}

	auto AddRegion = [&](const FIntPoint& Region)
	{
		Key.CapturedRegions.Add(Region);
		Key.MinCaptureRegion = Key.MinCaptureRegion.ComponentMin(Region);
		Key.MaxCaptureRegion = Key.MaxCaptureRegion.ComponentMax(Region);
	};

	if (MaxSystemRegionCount > MaxLandscapeRegionCount)
	{
		Key.CapturedRegions.Reserve(MaxLandscapeRegionCount);

		for (const auto& LandscapeComponent : LandscapeInfo->XYtoCollisionComponentMap)
		{
			if (SystemRect.Contains(LandscapeComponent.Key))
			{
				AddRegion(LandscapeComponent.Key);
			}
		}
	}
	else
	{
		Key.CapturedRegions.Reserve(MaxSystemRegionCount);

		for (int32 GridY = SystemRect.Min.Y; GridY < SystemRect.Max.Y; ++GridY)
		{
			for (int32 GridX = SystemRect.Min.X; GridX < SystemRect.Max.X; ++GridX)
			{
				const FIntPoint CurrentRegion(GridX, GridY);
				if (LandscapeInfo->XYtoCollisionComponentMap.Contains(CurrentRegion))
				{
					AddRegion(CurrentRegion);
				}
			}
		}
	}

	if (!Key.CapturedRegions.Num())
	{
		return FNDI_Landscape_SharedResourceHandle();
	}

	// Attempt to Find data
	{
		FRWScopeLock ReadLock(LandscapeDataGuard, SLT_ReadOnly);
		TSharedPtr<FNDI_Landscape_SharedResource>* Existing = LandscapeData.FindByPredicate([&](const TSharedPtr<FNDI_Landscape_SharedResource>& LandscapeEntry)
		{
			return LandscapeEntry->CanRepresent(Key);
		});

		if (Existing)
		{
			return FNDI_Landscape_SharedResourceHandle(Usage, *Existing, bNeedsDataImmediately);
		}
	}

	// We need to add
	// Note we do not need to check for other threads adding here as it's only every done on the GameThread
	FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);
	return FNDI_Landscape_SharedResourceHandle(
		Usage,
		LandscapeData.Add_GetRef(MakeShared<FNDI_Landscape_SharedResource>(Key)),
		bNeedsDataImmediately);
}

UNiagaraDataInterfaceLandscape::UNiagaraDataInterfaceLandscape(FObjectInitializer const& ObjectInitializer)
	: Super(ObjectInitializer)		
{
	SourceLandscape = nullptr;
	Proxy.Reset(new FNiagaraDataInterfaceProxyLandscape());
}

void UNiagaraDataInterfaceLandscape::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject))
	{
		ENiagaraTypeRegistryFlags Flags = ENiagaraTypeRegistryFlags::AllowAnyVariable | ENiagaraTypeRegistryFlags::AllowParameter;
		FNiagaraTypeRegistry::Register(FNiagaraTypeDefinition(GetClass()), Flags);
	}	
}

bool UNiagaraDataInterfaceLandscape::CopyToInternal(UNiagaraDataInterface* Destination) const
{
	if (!Super::CopyToInternal(Destination))
	{
		return false;
	}
	UNiagaraDataInterfaceLandscape* DestinationLandscape = CastChecked<UNiagaraDataInterfaceLandscape>(Destination);
	DestinationLandscape->SourceLandscape = SourceLandscape;	
	DestinationLandscape->SourceMode = SourceMode;
	DestinationLandscape->PhysicalMaterials = PhysicalMaterials;

	return true;
}

bool UNiagaraDataInterfaceLandscape::Equals(const UNiagaraDataInterface* Other) const
{
	if (!Super::Equals(Other))
	{
		return false;
	}
	const UNiagaraDataInterfaceLandscape* OtherLandscape = CastChecked<const UNiagaraDataInterfaceLandscape>(Other);
	return OtherLandscape->SourceLandscape == SourceLandscape
		&& OtherLandscape->SourceMode == SourceMode
		&& OtherLandscape->PhysicalMaterials == PhysicalMaterials;
}

void UNiagaraDataInterfaceLandscape::GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions)
{
	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetBaseColorName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("Color")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetHeightName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetPositionDef(), TEXT("WorldPos")));		
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetFloatDef(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetWorldNormalName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetPositionDef(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetPhysicalMaterialIndexName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetPositionDef(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetIntDef(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

#if WITH_EDITORONLY_DATA
	for (FNiagaraFunctionSignature& Sig : OutFunctions)
	{
		Sig.FunctionVersion = NiagaraDataInterfaceLandscape::LatestVersion;
	}
#endif
}

#if WITH_EDITORONLY_DATA
bool UNiagaraDataInterfaceLandscape::UpgradeFunctionCall(FNiagaraFunctionSignature& FunctionSignature)
{
	// always upgrade to the latest version
	if (FunctionSignature.FunctionVersion < NiagaraDataInterfaceLandscape::LatestVersion)
	{
		TArray<FNiagaraFunctionSignature> AllFunctions;
		GetFunctions(AllFunctions);
		for (const FNiagaraFunctionSignature& Sig : AllFunctions)
		{
			if (FunctionSignature.Name == Sig.Name)
			{
				FunctionSignature = Sig;
				return true;
			}
		}
	}

	return false;
}
#endif

void UNiagaraDataInterfaceLandscape::ProvidePerInstanceDataForRenderThread(void* DataForRenderThread, void* PerInstanceData, const FNiagaraSystemInstanceID& SystemInstance)
{
	const FNDILandscapeData_GameThread& SourceData = *reinterpret_cast<const FNDILandscapeData_GameThread*>(PerInstanceData);
	FNDILandscapeData_RenderThread* TargetData = new(DataForRenderThread) FNDILandscapeData_RenderThread();

	if (SourceData.SharedResourceHandle)
	{
		const FNDI_Landscape_SharedResource& SourceResource = SourceData.SharedResourceHandle.ReadResource();

		TargetData->TextureResources = SourceResource.LandscapeTextures.Get();
		
		TargetData->CachedHeightTextureUvScaleBias = SourceResource.UvScaleBias;
		TargetData->CachedHeightTextureWorldToUvTransform = SourceResource.WorldToActorTransform;
		TargetData->CachedHeightTextureUvToWorldTransform = SourceResource.ActorToWorldTransform;
		TargetData->CachedHeightTextureGridSize = SourceResource.TextureWorldGridSize;
	}

	if (SourceData.BaseColorVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.BaseColorVirtualTextureIndex])
		{
			TargetData->BaseColorVirtualTexture = VirtualTexture;
			TargetData->BaseColorVirtualTextureSRGB = SourceData.BaseColorVirtualTextureSRGB;
			TargetData->BaseColorVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->BaseColorVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->BaseColorVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
		}
	}

	if (SourceData.HeightVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.HeightVirtualTextureIndex])
		{
			TargetData->HeightVirtualTexture = VirtualTexture;
			TargetData->HeightVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->HeightVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->HeightVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
			TargetData->HeightVirtualTextureWorldToUvParameters[3] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldHeightUnpack);
		}
	}

	if (SourceData.NormalVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.NormalVirtualTextureIndex])
		{
			TargetData->NormalVirtualTexture = VirtualTexture;
			TargetData->NormalVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->NormalVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->NormalVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
			TargetData->NormalVirtualTextureMode = SourceData.NormalVirtualTextureMode;
		}
	}
}

#if WITH_EDITORONLY_DATA
bool UNiagaraDataInterfaceLandscape::AppendCompileHash(FNiagaraCompileHashVisitor* InVisitor) const
{
	if (!Super::AppendCompileHash(InVisitor))
	{
		return false;
	}

	FSHAHash Hash = GetShaderFileHash((TEXT("/Plugin/FX/Niagara/Private/NiagaraDataInterfaceLandscape.ush")), EShaderPlatform::SP_PCD3D_SM5);
	InVisitor->UpdateString(TEXT("NiagaraDataInterfaceLandscapeHLSLSource"), Hash.ToString());

	return true;

}

void UNiagaraDataInterfaceLandscape::GetCommonHLSL(FString& OutHLSL)
{
	OutHLSL += TEXT("#include \"/Plugin/FX/Niagara/Private/NiagaraDataInterfaceLandscape.ush\"\n");
}

void UNiagaraDataInterfaceLandscape::GetParameterDefinitionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, FString& OutHLSL)
{
	Super::GetParameterDefinitionHLSL(ParamInfo, OutHLSL);

	OutHLSL += TEXT("NDILANDSCAPE_DECLARE_CONSTANTS(") + ParamInfo.DataInterfaceHLSLSymbol + TEXT(")\n");
}

bool UNiagaraDataInterfaceLandscape::GetFunctionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, const FNiagaraDataInterfaceGeneratedFunction& FunctionInfo, int FunctionInstanceIndex, FString& OutHLSL)
{
	TMap<FString, FStringFormatArg> ArgsSample =
	{
		{TEXT("InstanceFunctionName"), FunctionInfo.InstanceName},
		{TEXT("NDIGetContextName"), TEXT("NDILANDSCAPE_MAKE_CONTEXT(") + ParamInfo.DataInterfaceHLSLSymbol + TEXT(")")},
	};

	if (FunctionInfo.DefinitionName == GetBaseColorName)
	{
		static const TCHAR* FormatSample = TEXT("void {InstanceFunctionName}(in float3 InWorldPos, out float3 OutBaseColor, out bool OutIsValid) { {NDIGetContextName} NDILandscape_GetBaseColor(DIContext, InWorldPos, OutBaseColor, OutIsValid); }\n");
		OutHLSL += FString::Format(FormatSample, ArgsSample);
		return true;
	}
	else if (FunctionInfo.DefinitionName == GetHeightName)
	{
		static const TCHAR* FormatSample = TEXT("void {InstanceFunctionName}(in float3 InWorldPos, out float OutHeight, out bool OutIsValid) { {NDIGetContextName} NDILandscape_GetHeight(DIContext, InWorldPos, OutHeight, OutIsValid); }\n");
		OutHLSL += FString::Format(FormatSample, ArgsSample);
		return true;
	}
	else if (FunctionInfo.DefinitionName == GetWorldNormalName)
	{
		static const TCHAR* FormatSample = TEXT("void {InstanceFunctionName}(in float3 InWorldPos, out float3 OutWorldNormal, out bool OutIsValid) { {NDIGetContextName} NDILandscape_GetWorldNormal(DIContext, InWorldPos, OutWorldNormal, OutIsValid); }\n");
		OutHLSL += FString::Format(FormatSample, ArgsSample);
		return true;
	}
	else if (FunctionInfo.DefinitionName == GetPhysicalMaterialIndexName)
	{
		static const TCHAR* FormatSample = TEXT("void {InstanceFunctionName}(in float3 InWorldPos, out int OutIndex, out bool OutIsValid) { {NDIGetContextName} NDILandscape_GetPhysicalMaterialIndex(DIContext, InWorldPos, OutIndex, OutIsValid); }\n");
		OutHLSL += FString::Format(FormatSample, ArgsSample);
		return true;
	}

	return false;
}
#endif

bool UNiagaraDataInterfaceLandscape::InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
	FNDILandscapeData_GameThread* InstanceData = new(PerInstanceData) FNDILandscapeData_GameThread();
	ApplyLandscape(*SystemInstance, *InstanceData);

	FNiagaraDataInterfaceProxyLandscape* RT_Proxy = GetProxyAs<FNiagaraDataInterfaceProxyLandscape>();
	ENQUEUE_RENDER_COMMAND(FNiagaraDICreateProxy) (
		[RT_Proxy, InstanceID = SystemInstance->GetId()](FRHICommandListImmediate& CmdList)
	{
		check(!RT_Proxy->SystemInstancesToProxyData_RT.Contains(InstanceID));
		RT_Proxy->SystemInstancesToProxyData_RT.Add(InstanceID);
	});

	return true;
}

void UNiagaraDataInterfaceLandscape::DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
	if (FNDILandscapeData_GameThread* InstanceData = reinterpret_cast<FNDILandscapeData_GameThread*>(PerInstanceData))
	{
		InstanceData->~FNDILandscapeData_GameThread();

		FNiagaraDataInterfaceProxyLandscape* RT_Proxy = GetProxyAs<FNiagaraDataInterfaceProxyLandscape>();
		ENQUEUE_RENDER_COMMAND(FNiagaraDIDestroyProxy) (
			[RT_Proxy, InstanceID = SystemInstance->GetId()](FRHICommandListImmediate& CmdList)
		{
			RT_Proxy->SystemInstancesToProxyData_RT.Remove(InstanceID);
		});
	}
}

int32 UNiagaraDataInterfaceLandscape::PerInstanceDataSize() const
{
	return sizeof(FNDILandscapeData_GameThread);
}

bool UNiagaraDataInterfaceLandscape::PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds)
{
	bool ResetInstance = false;

	if (FNDILandscapeData_GameThread* InstanceData = reinterpret_cast<FNDILandscapeData_GameThread*>(PerInstanceData))
	{
		// todo - can we avoid checking this every tick?  currently it is required in case the landscape beneath us changes or new data
		// has stremaed in for the landscape and we need to update our capture of the data
		ApplyLandscape(*SystemInstance, *InstanceData);

		if (InstanceData->RequiresCollisionCacheGpu || InstanceData->RequiresPhysMatCacheGpu)
		{
			FNDI_Landscape_GeneratedData& GeneratedData = SystemInstance->GetWorldManager()->EditGeneratedData<FNDI_Landscape_GeneratedData>();
			InstanceData->SharedResourceHandle = GeneratedData.GetLandscapeData(*this, *SystemInstance, *InstanceData, FNDI_SharedResourceUsage(false, true), true);
		}
		else
		{
			InstanceData->SharedResourceHandle = FNDI_Landscape_SharedResourceHandle();
		}
	}

	return ResetInstance;
}

void UNiagaraDataInterfaceLandscape::ApplyLandscape(const FNiagaraSystemInstance& SystemInstance, FNDILandscapeData_GameThread& InstanceData) const
{
	ALandscape* Landscape = GetLandscape(SystemInstance, InstanceData.Landscape.Get());

	// when in editor the contents of the Landscape are volatile and so we'll make sure to
	// refresh our instance properties any time we apply
	#if !WITH_EDITOR
	if (InstanceData.Landscape == Landscape)
	{
		return;
	}
	#endif

	if (!Landscape)
	{
		InstanceData.Reset();
		return;
	}

	InstanceData.Landscape = Landscape;
	InstanceData.BaseColorVirtualTextureIndex = INDEX_NONE;
	InstanceData.HeightVirtualTextureIndex = INDEX_NONE;
	InstanceData.NormalVirtualTextureIndex = INDEX_NONE;

	// only worry about virtual textures if our current platform supports them
	if (UseVirtualTexturing(SystemInstance.GetFeatureLevel()))
	{
		const int32 RuntimeVirtualTextureCount = InstanceData.Landscape->RuntimeVirtualTextures.Num();
		for (int32 TextureIt = 0; TextureIt < RuntimeVirtualTextureCount; ++TextureIt)
		{
			if (const URuntimeVirtualTexture* Vt = InstanceData.Landscape->RuntimeVirtualTextures[TextureIt])
			{
				const ERuntimeVirtualTextureMaterialType VirtualMaterialType = Vt->GetMaterialType();

				switch (VirtualMaterialType)
				{
				case ERuntimeVirtualTextureMaterialType::BaseColor:
					if (InstanceData.BaseColorVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.BaseColorVirtualTextureIndex = TextureIt;
						InstanceData.BaseColorVirtualTextureSRGB = true;
					}
					break;
				case ERuntimeVirtualTextureMaterialType::WorldHeight:
					if (InstanceData.HeightVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.HeightVirtualTextureIndex = TextureIt;
					}
					break;
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Roughness:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_YCoCg:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_Mask_YCoCg:
					if (InstanceData.NormalVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.NormalVirtualTextureIndex = TextureIt;
						InstanceData.NormalVirtualTextureMode = VirtualMaterialType;
					}
					if (InstanceData.BaseColorVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.BaseColorVirtualTextureIndex = TextureIt;
						InstanceData.BaseColorVirtualTextureSRGB =
							(VirtualMaterialType == ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Roughness) ||
							(VirtualMaterialType == ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular);
					}
					break;
				}
			}
		}
	}

	bool SystemRequiresHeightsCpu = false;
	bool SystemRequiresHeightsGpu = false;
	SystemInstance.EvaluateBoundFunction(GetHeightName, SystemRequiresHeightsCpu, SystemRequiresHeightsGpu);

	bool SystemRequiresNormalsCpu = false;
	bool SystemRequiresNormalsGpu = false;
	SystemInstance.EvaluateBoundFunction(GetWorldNormalName, SystemRequiresNormalsCpu, SystemRequiresNormalsGpu);

	bool SystemRequiresPhysMatCpu = false;
	bool SystemRequiresPhysMatGpu = false;
	SystemInstance.EvaluateBoundFunction(GetPhysicalMaterialIndexName, SystemRequiresPhysMatCpu, SystemRequiresPhysMatGpu);

	bool SystemRequiresBaseColorCpu = false;
	bool SystemRequiresBaseColorGpu = false;
	SystemInstance.EvaluateBoundFunction(GetBaseColorName, SystemRequiresBaseColorCpu, SystemRequiresBaseColorGpu);

	// we need to create our own copy of the collision geometry if either the heights are needed, and they're not
	// provided by a virtual texture or if the normals are needed and they're not provided by a virtual texture
	InstanceData.RequiresCollisionCacheGpu =
		(SystemRequiresBaseColorGpu && InstanceData.BaseColorVirtualTextureIndex == INDEX_NONE) ||
		(SystemRequiresHeightsGpu && InstanceData.HeightVirtualTextureIndex == INDEX_NONE) ||
		(SystemRequiresNormalsGpu && InstanceData.NormalVirtualTextureIndex == INDEX_NONE);

	InstanceData.RequiresPhysMatCacheGpu = SystemRequiresPhysMatGpu;
}


// Users can supply a ALandscape actor
// if none is provided, then we use the World's LandscapeInfoMap to find an appropriate ALandscape actor
ALandscape* UNiagaraDataInterfaceLandscape::GetLandscape(const FNiagaraSystemInstance& SystemInstance, ALandscape* Hint) const
{
	if (ALandscape* Landscape = Cast<ALandscape>(SourceLandscape))
	{
		const bool HasValidSource = Landscape != nullptr;

		if (SourceMode == ENDILandscape_SourceMode::Source || (SourceMode == ENDILandscape_SourceMode::Default && HasValidSource))
		{
			return Landscape;
		}
	}

	const FBox WorldBounds = SystemInstance.GetLocalBounds().TransformBy(SystemInstance.GetWorldTransform());

	auto TestLandscape = [&](const ALandscape* InLandscape)
	{
		if (InLandscape->GetWorld() == SystemInstance.GetWorld())
		{
			if (const ULandscapeInfo* LandscapeInfo = InLandscape->GetLandscapeInfo())
			{
				for (const auto& ComponentIt : LandscapeInfo->XYtoCollisionComponentMap)
				{
					if (WorldBounds.IntersectXY(ComponentIt.Value->Bounds.GetBox()))
					{
						return true;
					}
				}
			}
		}

		return false;
	};

	if (Hint && TestLandscape(Hint))
	{
		return Hint;
	}

	for (TActorIterator<ALandscape> LandscapeIt(SystemInstance.GetWorld()); LandscapeIt; ++LandscapeIt)
	{
		if (ALandscape* Landscape = *LandscapeIt)
		{
			if (TestLandscape(Landscape))
			{
				return Landscape;
			}
		}
	}

	return nullptr;
}

struct FNiagaraDataInterfaceParametersCS_Landscape : public FNiagaraDataInterfaceParametersCS
{
	DECLARE_TYPE_LAYOUT(FNiagaraDataInterfaceParametersCS_Landscape, NonVirtual);

private:
	enum class ENormalUnpackType : int32
	{
		None = 0,
		BC3BC3,
		BC5BC1,
		B5G6R5
	};

public:
	void Bind(const FNiagaraDataInterfaceGPUParamInfo& ParameterInfo, const class FShaderParameterMap& ParameterMap)
	{
		BaseColorVirtualTextureParam.Bind(ParameterMap, *(BaseColorVirtualTextureName + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTexturePageTableParam.Bind(ParameterMap, *(BaseColorVirtualTexturePageTableName + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTextureSamplerParam.Bind(ParameterMap, *(BaseColorVirtualTextureSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTextureWorldToUvTransformParam.Bind(ParameterMap, *(BaseColorVirtualTextureWorldToUvTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTextureSRGBParam.Bind(ParameterMap, *(BaseColorVirtualTextureSRGBName + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTextureEnabledParam.Bind(ParameterMap, *(BaseColorVirtualTextureEnabledName + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTexturePageTableUniform0Param.Bind(ParameterMap, *(BaseColorVirtualTexturePageTableUniform0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTexturePageTableUniform1Param.Bind(ParameterMap, *(BaseColorVirtualTexturePageTableUniform1Name + ParameterInfo.DataInterfaceHLSLSymbol));
		BaseColorVirtualTextureUniformsParam.Bind(ParameterMap, *(BaseColorVirtualTextureUniformsName + ParameterInfo.DataInterfaceHLSLSymbol));

		HeightVirtualTextureParam.Bind(ParameterMap, *(HeightVirtualTextureName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTexturePageTableParam.Bind(ParameterMap, *(HeightVirtualTexturePageTableName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureSamplerParam.Bind(ParameterMap, *(HeightVirtualTextureSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureWorldToUvTransformParam.Bind(ParameterMap, *(HeightVirtualTextureWorldToUvTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureEnabledParam.Bind(ParameterMap, *(HeightVirtualTextureEnabledName + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTexturePageTableUniform0Param.Bind(ParameterMap, *(HeightVirtualTexturePageTableUniform0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTexturePageTableUniform1Param.Bind(ParameterMap, *(HeightVirtualTexturePageTableUniform1Name + ParameterInfo.DataInterfaceHLSLSymbol));
		HeightVirtualTextureUniformsParam.Bind(ParameterMap, *(HeightVirtualTextureUniformsName + ParameterInfo.DataInterfaceHLSLSymbol));

		NormalVirtualTexture0Param.Bind(ParameterMap, *(NormalVirtualTexture0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexture1Param.Bind(ParameterMap, *(NormalVirtualTexture1Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexturePageTableParam.Bind(ParameterMap, *(NormalVirtualTexturePageTableName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureSamplerParam.Bind(ParameterMap, *(NormalVirtualTextureSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureWorldToUvTransformParam.Bind(ParameterMap, *(NormalVirtualTextureWorldToUvTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureEnabledParam.Bind(ParameterMap, *(NormalVirtualTextureEnabledName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureUnpackModeParam.Bind(ParameterMap, *(NormalVirtualTextureUnpackModeName + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexturePageTableUniform0Param.Bind(ParameterMap, *(NormalVirtualTexturePageTableUniform0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTexturePageTableUniform1Param.Bind(ParameterMap, *(NormalVirtualTexturePageTableUniform1Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureUniforms0Param.Bind(ParameterMap, *(NormalVirtualTextureUniforms0Name + ParameterInfo.DataInterfaceHLSLSymbol));
		NormalVirtualTextureUniforms1Param.Bind(ParameterMap, *(NormalVirtualTextureUniforms1Name + ParameterInfo.DataInterfaceHLSLSymbol));

		CachedHeightTextureParam.Bind(ParameterMap, *(CachedHeightTextureName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureSamplerParam.Bind(ParameterMap, *(CachedHeightTextureSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureWorldToUvTransformParam.Bind(ParameterMap, *(CachedHeightTextureWorldToUvTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureUvToWorldTransformParam.Bind(ParameterMap, *(CachedHeightTextureUvToWorldTransformName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureUvScaleBiasParam.Bind(ParameterMap, *(CachedHeightTextureUvScaleBiasName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTexturEnabledParam.Bind(ParameterMap, *(CachedHeightTextureEnabledName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedHeightTextureGridSizeParam.Bind(ParameterMap, *(CachedHeightTextureGridSizeName + ParameterInfo.DataInterfaceHLSLSymbol));
		PointClampedSamplerParam.Bind(ParameterMap, *(PointClampedSamplerName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedPhysMatTextureParam.Bind(ParameterMap, *(CachedPhysMatTextureName + ParameterInfo.DataInterfaceHLSLSymbol));
		CachedPhysMatTextureDimensionParam.Bind(ParameterMap, *(CachedPhysMatTextureDimensionName + ParameterInfo.DataInterfaceHLSLSymbol));
		SystemLWCTileParam.Bind(ParameterMap, *(SystemLWCTileName + ParameterInfo.DataInterfaceHLSLSymbol));
	}

	bool SetBaseColorVirtualTextureParameters(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI, const FNDILandscapeData_RenderThread& ProxyData) const
	{
		const IAllocatedVirtualTexture* BaseColorAllocatedTexture = ProxyData.BaseColorVirtualTexture.IsValid()
			? ProxyData.BaseColorVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!BaseColorAllocatedTexture)
		{
			return false;
		}

		// todo - need to figure out a way to confirm that this is in fact the best/only option for the basecolor
		constexpr uint32 BaseColorVirtualTextureLayerIndex = 0;
		constexpr uint32 BaseColorVirtualTexturePageIndex = 0;
		constexpr bool BaseColorVirtualTextureSrgb = false;

		FRHIShaderResourceView* PhysicalTextureSrv = BaseColorAllocatedTexture->GetPhysicalTextureSRV(BaseColorVirtualTextureLayerIndex, BaseColorVirtualTextureSrgb);
		if (!PhysicalTextureSrv)
		{
			return false;
		}

		FRHITexture* PageTableTexture = nullptr;

		if (FRHITexture* PageTable = BaseColorAllocatedTexture->GetPageTableTexture(BaseColorVirtualTexturePageIndex))
		{
			if (FRHITextureReference* TextureReference = PageTable->GetTextureReference())
			{
				PageTableTexture = TextureReference->GetReferencedTexture();
			}
		}

		if (!PageTableTexture)
		{
			return false;
		}

		FMatrix44f WorldToUvTransform(
			FVector3f( (FVector4f)ProxyData.BaseColorVirtualTextureWorldToUvParameters[0]),
			FVector3f( (FVector4f)ProxyData.BaseColorVirtualTextureWorldToUvParameters[1]),
			FVector3f( (FVector4f)ProxyData.BaseColorVirtualTextureWorldToUvParameters[2]),
			FVector3f(0, 0, 0));

		SetSRVParameter(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureParam, PhysicalTextureSrv);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, BaseColorVirtualTexturePageTableParam, PageTableTexture);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureWorldToUvTransformParam, WorldToUvTransform);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureSRGBParam, ProxyData.BaseColorVirtualTextureSRGB ? 1 : 0);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureEnabledParam, 1 /* true */);

		FUintVector4 BaseColorVirtualTexturePageTableUniforms[2];
		FUintVector4 BaseColorVirtualTextureUniforms;

		BaseColorAllocatedTexture->GetPackedPageTableUniform(BaseColorVirtualTexturePageTableUniforms);
		BaseColorAllocatedTexture->GetPackedUniform(&BaseColorVirtualTextureUniforms, BaseColorVirtualTextureLayerIndex);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTexturePageTableUniform0Param, BaseColorVirtualTexturePageTableUniforms[0]);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTexturePageTableUniform1Param, BaseColorVirtualTexturePageTableUniforms[1]);

		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureUniformsParam, BaseColorVirtualTextureUniforms);

		return true;
	}

	void SetBaseColorVirtualTextureParameters_Default(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI) const
	{
		FUintVector4 DummyUint4(ForceInitToZero);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, BaseColorVirtualTexturePageTableParam, GBlackTexture->TextureRHI);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureWorldToUvTransformParam, FMatrix44f::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureSRGBParam, 0 /* false */);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureEnabledParam, 0 /* false */);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTexturePageTableUniform0Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTexturePageTableUniform1Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureUniformsParam, DummyUint4);
	}

	bool SetHeightVirtualTextureParameters(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI, const FNDILandscapeData_RenderThread& ProxyData) const
	{
		const IAllocatedVirtualTexture* HeightAllocatedTexture = ProxyData.HeightVirtualTexture.IsValid()
			? ProxyData.HeightVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!HeightAllocatedTexture)
		{
			return false;
		}

		// todo - need to figure out a way to confirm that this is in fact the best/only option for the height
		constexpr uint32 HeightVirtualTextureLayerIndex = 0;
		constexpr uint32 HeightVirtualTexturePageIndex = 0;
		constexpr bool HeightVirtualTextureSrgb = false;

		FRHIShaderResourceView* PhysicalTextureSrv = HeightAllocatedTexture->GetPhysicalTextureSRV(HeightVirtualTextureLayerIndex, HeightVirtualTextureSrgb);
		if (!PhysicalTextureSrv)
		{
			return false;
		}

		FRHITexture* PageTableTexture = nullptr;

		if (FRHITexture* PageTable = HeightAllocatedTexture->GetPageTableTexture(HeightVirtualTexturePageIndex))
		{
			if (FRHITextureReference* TextureReference = PageTable->GetTextureReference())
			{
				PageTableTexture = TextureReference->GetReferencedTexture();
			}
		}

		if (!PageTableTexture)
		{
			return false;
		}

		FMatrix44f WorldToUvTransform(
			FVector3f( (FVector4f)ProxyData.HeightVirtualTextureWorldToUvParameters[0]),
			FVector3f( (FVector4f)ProxyData.HeightVirtualTextureWorldToUvParameters[1]),
			FVector3f( (FVector4f)ProxyData.HeightVirtualTextureWorldToUvParameters[2]),
			FVector3f( (FVector4f)ProxyData.HeightVirtualTextureWorldToUvParameters[3]));

		SetSRVParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTextureParam, PhysicalTextureSrv);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableParam, PageTableTexture);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureWorldToUvTransformParam, WorldToUvTransform);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureEnabledParam, 1 /* true */);

		FUintVector4 HeightVirtualTexturePageTableUniforms[2];
		FUintVector4 HeightVirtualTextureUniforms;

		HeightAllocatedTexture->GetPackedPageTableUniform(HeightVirtualTexturePageTableUniforms);
		HeightAllocatedTexture->GetPackedUniform(&HeightVirtualTextureUniforms, HeightVirtualTextureLayerIndex);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform0Param, HeightVirtualTexturePageTableUniforms[0]);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform1Param, HeightVirtualTexturePageTableUniforms[1]);

		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureUniformsParam, HeightVirtualTextureUniforms);

		return true;
	}

	void SetHeightVirtualTextureParameters_Default(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI) const
	{
		FUintVector4 DummyUint4(ForceInitToZero);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableParam, GBlackTexture->TextureRHI);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureWorldToUvTransformParam, FMatrix44f::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureEnabledParam, 0 /* false */);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform0Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTexturePageTableUniform1Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, HeightVirtualTextureUniformsParam, DummyUint4);
	}

	bool SetNormalVirtualTextureParameters(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI, const FNDILandscapeData_RenderThread& ProxyData) const
	{
		const IAllocatedVirtualTexture* NormalAllocatedTexture = ProxyData.NormalVirtualTexture.IsValid()
			? ProxyData.NormalVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!NormalAllocatedTexture)
		{
			return false;
		}

		constexpr uint32 NormalVirtualTexturePageIndex = 0;

		FRHITexture* PageTableTexture = nullptr;

		if (FRHITexture* PageTable = NormalAllocatedTexture->GetPageTableTexture(NormalVirtualTexturePageIndex))
		{
			if (FRHITextureReference* TextureReference = PageTable->GetTextureReference())
			{
				PageTableTexture = TextureReference->GetReferencedTexture();
			}
		}

		if (!PageTableTexture)
		{
			return false;
		}

		FRHIShaderResourceView* PhysicalTextureSrv[2] = { GBlackTextureWithSRV->ShaderResourceViewRHI, GBlackTextureWithSRV->ShaderResourceViewRHI };
		FUintVector4 NormalVirtualTextureUniforms[2];

		switch (ProxyData.NormalVirtualTextureMode)
		{
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Roughness:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(0, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 0);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 1);

				SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUnpackModeParam, ENormalUnpackType::B5G6R5);
				break;
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(0, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 0);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 1);

				SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUnpackModeParam, ENormalUnpackType::BC3BC3);
				break;

			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_YCoCg:
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_Mask_YCoCg:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 1);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(2, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 2);

				SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUnpackModeParam, ENormalUnpackType::BC5BC1);
				break;

			default:
				return false;
		}

		FMatrix44f WorldToUvTransform(
			FPlane4f( (FVector4f)ProxyData.NormalVirtualTextureWorldToUvParameters[0]),
			FPlane4f( (FVector4f)ProxyData.NormalVirtualTextureWorldToUvParameters[1]),
			FPlane4f( (FVector4f)ProxyData.NormalVirtualTextureWorldToUvParameters[2]),
			FPlane4f(0.0f, 0.0f, 0.0f, 1.0f));

		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture0Param, PhysicalTextureSrv[0]);
		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture1Param, PhysicalTextureSrv[1]);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableParam, PageTableTexture);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureWorldToUvTransformParam, WorldToUvTransform);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureEnabledParam, 1 /* true */);

		FUintVector4 NormalVirtualTexturePageTableUniforms[2];
		NormalAllocatedTexture->GetPackedPageTableUniform(NormalVirtualTexturePageTableUniforms);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform0Param, NormalVirtualTexturePageTableUniforms[0]);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform1Param, NormalVirtualTexturePageTableUniforms[1]);

		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms0Param, NormalVirtualTextureUniforms[0]);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms1Param, NormalVirtualTextureUniforms[1]);

		return true;
	}

	void SetNormalVirtualTextureParameters_Default(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI) const
	{
		FUintVector4 DummyUint4(ForceInitToZero);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture0Param, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetSRVParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexture1Param, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetTextureParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableParam, GBlackTexture->TextureRHI);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureWorldToUvTransformParam, FMatrix44f::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureEnabledParam, 0 /* false */);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUnpackModeParam, ENormalUnpackType::None);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform0Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTexturePageTableUniform1Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms0Param, DummyUint4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, NormalVirtualTextureUniforms1Param, DummyUint4);
	}

	bool SetCachedHeightTextureParameters(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI, const FNDILandscapeData_RenderThread& ProxyData) const
	{
		if (ProxyData.TextureResources)
		{
			FRHIShaderResourceView* HeightTextureSrv = ProxyData.TextureResources->GetHeightTexture();
			FRHIShaderResourceView* PhysMatTextureSrv = ProxyData.TextureResources->GetPhysMatTexture();

			if (HeightTextureSrv || PhysMatTextureSrv)
			{
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureWorldToUvTransformParam, (FMatrix44f)ProxyData.CachedHeightTextureWorldToUvTransform);
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvToWorldTransformParam, (FMatrix44f)ProxyData.CachedHeightTextureUvToWorldTransform);
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvScaleBiasParam, (FVector4f)ProxyData.CachedHeightTextureUvScaleBias);
				SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureGridSizeParam, (FVector2f)ProxyData.CachedHeightTextureGridSize);

				if (HeightTextureSrv)
				{
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureParam, HeightTextureSrv);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTexturEnabledParam, 1 /* true */);
				}
				else
				{
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTexturEnabledParam, 0 /* true */);
				}

				if (PhysMatTextureSrv)
				{
					FIntPoint PhysMatDimensions(ProxyData.TextureResources->GetDimensions());
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureParam, PhysMatTextureSrv);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureDimensionParam, PhysMatDimensions);
				}
				else
				{
					FIntPoint PhysMatDimensions(ForceInitToZero);
					SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
					SetShaderValue(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureDimensionParam, PhysMatDimensions);
				}

				FRHISamplerState* PointClampedSampler = TStaticSamplerState<SF_Point, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();;
				SetSamplerParameter(RHICmdList, ComputeShaderRHI, PointClampedSamplerParam, PointClampedSampler);

				return true;
			}
		}

		return false;
	}

	void SetCachedHeightTextureParameters_Defaults(FRHICommandList& RHICmdList, FRHIComputeShader* ComputeShaderRHI) const
	{
		FVector4f DummyVector4(ForceInitToZero);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureWorldToUvTransformParam, FMatrix44f::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvToWorldTransformParam, FMatrix44f::Identity);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureUvScaleBiasParam, DummyVector4);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTextureGridSizeParam, 0.0f);
		SetShaderValue(RHICmdList, ComputeShaderRHI, CachedHeightTexturEnabledParam, 0 /* false */);

		SetSRVParameter(RHICmdList, ComputeShaderRHI, CachedPhysMatTextureParam, GBlackTextureWithSRV->ShaderResourceViewRHI);

		FRHISamplerState* PointClampedSampler = TStaticSamplerState<SF_Point, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();;
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, PointClampedSamplerParam, PointClampedSampler);
	}

	void Set(FRHICommandList& RHICmdList, const FNiagaraDataInterfaceSetArgs& Context) const
	{
		check(IsInRenderingThread());

		FRHIComputeShader* ComputeShaderRHI = Context.Shader.GetComputeShader();
		SetShaderValue(RHICmdList, ComputeShaderRHI, SystemLWCTileParam, Context.SystemLWCTile);

		FNiagaraDataInterfaceProxyLandscape* RT_Proxy = static_cast<FNiagaraDataInterfaceProxyLandscape*>(Context.DataInterface);
		FNDILandscapeData_RenderThread* ProxyData = RT_Proxy ? RT_Proxy->SystemInstancesToProxyData_RT.Find(Context.SystemInstanceID) : nullptr;

		// global samplers
		FRHISamplerState* BilinearSamplerState = TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, BaseColorVirtualTextureSamplerParam, BilinearSamplerState);
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, HeightVirtualTextureSamplerParam, BilinearSamplerState);
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, NormalVirtualTextureSamplerParam, BilinearSamplerState);
		SetSamplerParameter(RHICmdList, ComputeShaderRHI, CachedHeightTextureSamplerParam, BilinearSamplerState);

		bool ApplyBaseColorVirtualTextureDefaults = true;
		bool ApplyHeightVirtualTextureDefaults = true;
		bool ApplyNormalVirtualTextureDefaults = true;
		bool ApplyCachedHeightTextureDefaults = true;

		if (ProxyData)
		{
			if (SetBaseColorVirtualTextureParameters(RHICmdList, ComputeShaderRHI, *ProxyData))
			{
				ApplyBaseColorVirtualTextureDefaults = false;
			}

			if (SetHeightVirtualTextureParameters(RHICmdList, ComputeShaderRHI, *ProxyData))
			{
				ApplyHeightVirtualTextureDefaults = false;
			}

			if (SetNormalVirtualTextureParameters(RHICmdList, ComputeShaderRHI, *ProxyData))
			{
				ApplyNormalVirtualTextureDefaults = false;
			}

			if (SetCachedHeightTextureParameters(RHICmdList, ComputeShaderRHI, *ProxyData))
			{
				ApplyCachedHeightTextureDefaults = false;
			}
		}

		if (ApplyBaseColorVirtualTextureDefaults)
		{
			SetBaseColorVirtualTextureParameters_Default(RHICmdList, ComputeShaderRHI);
		}

		if (ApplyHeightVirtualTextureDefaults)
		{
			SetHeightVirtualTextureParameters_Default(RHICmdList, ComputeShaderRHI);
		}

		if (ApplyNormalVirtualTextureDefaults)
		{
			SetNormalVirtualTextureParameters_Default(RHICmdList, ComputeShaderRHI);
		}

		if (ApplyCachedHeightTextureDefaults)
		{
			SetCachedHeightTextureParameters_Defaults(RHICmdList, ComputeShaderRHI);
		}
	}

private:
	// virtual texture parameters - basecolor
	LAYOUT_FIELD(FShaderResourceParameter, BaseColorVirtualTextureParam);
	LAYOUT_FIELD(FShaderResourceParameter, BaseColorVirtualTexturePageTableParam);
	LAYOUT_FIELD(FShaderResourceParameter, BaseColorVirtualTextureSamplerParam);
	LAYOUT_FIELD(FShaderParameter, BaseColorVirtualTextureWorldToUvTransformParam);
	LAYOUT_FIELD(FShaderParameter, BaseColorVirtualTextureSRGBParam);
	LAYOUT_FIELD(FShaderParameter, BaseColorVirtualTextureEnabledParam);
	LAYOUT_FIELD(FShaderParameter, BaseColorVirtualTexturePageTableUniform0Param);
	LAYOUT_FIELD(FShaderParameter, BaseColorVirtualTexturePageTableUniform1Param);
	LAYOUT_FIELD(FShaderParameter, BaseColorVirtualTextureUniformsParam);

	// virtual texture parameters - height
	LAYOUT_FIELD(FShaderResourceParameter, HeightVirtualTextureParam);
	LAYOUT_FIELD(FShaderResourceParameter, HeightVirtualTexturePageTableParam);
	LAYOUT_FIELD(FShaderResourceParameter, HeightVirtualTextureSamplerParam);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTextureWorldToUvTransformParam);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTextureEnabledParam);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTexturePageTableUniform0Param);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTexturePageTableUniform1Param);
	LAYOUT_FIELD(FShaderParameter, HeightVirtualTextureUniformsParam);

	// virtual texture parameters - normal
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTexture0Param);
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTexture1Param);
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTexturePageTableParam);
	LAYOUT_FIELD(FShaderResourceParameter, NormalVirtualTextureSamplerParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureWorldToUvTransformParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureEnabledParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureUnpackModeParam);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTexturePageTableUniform0Param);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTexturePageTableUniform1Param);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureUniforms0Param);
	LAYOUT_FIELD(FShaderParameter, NormalVirtualTextureUniforms1Param);

	// cached texture parameters - height
	LAYOUT_FIELD(FShaderResourceParameter, CachedHeightTextureParam);
	LAYOUT_FIELD(FShaderResourceParameter, CachedHeightTextureSamplerParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureWorldToUvTransformParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureUvToWorldTransformParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureUvScaleBiasParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTexturEnabledParam);
	LAYOUT_FIELD(FShaderParameter, CachedHeightTextureGridSizeParam);
	LAYOUT_FIELD(FShaderResourceParameter, PointClampedSamplerParam);

	// cached texture parameters - phys mat
	LAYOUT_FIELD(FShaderResourceParameter, CachedPhysMatTextureParam);
	LAYOUT_FIELD(FShaderParameter, CachedPhysMatTextureDimensionParam);

	// LWC data
	LAYOUT_FIELD(FShaderParameter, SystemLWCTileParam);

	static const FString BaseColorVirtualTextureSRGBName;
	static const FString BaseColorVirtualTextureEnabledName;
	static const FString BaseColorVirtualTextureName;
	static const FString BaseColorVirtualTexturePageTableName;
	static const FString BaseColorVirtualTexturePageTableUniform0Name;
	static const FString BaseColorVirtualTexturePageTableUniform1Name;
	static const FString BaseColorVirtualTextureSamplerName;
	static const FString BaseColorVirtualTextureUniformsName;
	static const FString BaseColorVirtualTextureWorldToUvTransformName;

	static const FString HeightVirtualTextureEnabledName;
	static const FString HeightVirtualTextureName;
	static const FString HeightVirtualTexturePageTableName;
	static const FString HeightVirtualTexturePageTableUniform0Name;
	static const FString HeightVirtualTexturePageTableUniform1Name;
	static const FString HeightVirtualTextureSamplerName;
	static const FString HeightVirtualTextureUniformsName;
	static const FString HeightVirtualTextureWorldToUvTransformName;

	static const FString NormalVirtualTexture0Name;
	static const FString NormalVirtualTexture1Name;
	static const FString NormalVirtualTexturePageTableName;
	static const FString NormalVirtualTextureSamplerName;
	static const FString NormalVirtualTextureWorldToUvTransformName;
	static const FString NormalVirtualTextureEnabledName;
	static const FString NormalVirtualTextureUnpackModeName;
	static const FString NormalVirtualTexturePageTableUniform0Name;
	static const FString NormalVirtualTexturePageTableUniform1Name;
	static const FString NormalVirtualTextureUniforms0Name;
	static const FString NormalVirtualTextureUniforms1Name;

	static const FString CachedHeightTextureEnabledName;
	static const FString CachedHeightTextureName;
	static const FString CachedHeightTextureSamplerName;
	static const FString CachedHeightTextureUvScaleBiasName;
	static const FString CachedHeightTextureWorldToUvTransformName;
	static const FString CachedHeightTextureUvToWorldTransformName;
	static const FString CachedHeightTextureGridSizeName;
	static const FString PointClampedSamplerName;
	static const FString CachedPhysMatTextureName;
	static const FString CachedPhysMatTextureDimensionName;
	
	static const FString SystemLWCTileName;
};

// virtual texture parameters - basecolor
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTextureSRGBName(TEXT("BaseColorVirtualTextureSRGB_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTextureEnabledName(TEXT("BaseColorVirtualTextureEnabled_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTextureName(TEXT("BaseColorVirtualTexture_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTexturePageTableName(TEXT("BaseColorVirtualTexturePageTable_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTexturePageTableUniform0Name(TEXT("BaseColorVirtualTexturePackedUniform0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTexturePageTableUniform1Name(TEXT("BaseColorVirtualTexturePackedUniform1_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTextureSamplerName(TEXT("BaseColorVirtualTextureSampler_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTextureUniformsName(TEXT("BaseColorVirtualTextureUniforms_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::BaseColorVirtualTextureWorldToUvTransformName(TEXT("BaseColorVirtualTextureWorldToUvTransform_"));

// virtual texture parameters - height
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureEnabledName(TEXT("HeightVirtualTextureEnabled_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureName(TEXT("HeightVirtualTexture_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTexturePageTableName(TEXT("HeightVirtualTexturePageTable_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTexturePageTableUniform0Name(TEXT("HeightVirtualTexturePackedUniform0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTexturePageTableUniform1Name(TEXT("HeightVirtualTexturePackedUniform1_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureSamplerName(TEXT("HeightVirtualTextureSampler_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureUniformsName(TEXT("HeightVirtualTextureUniforms_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::HeightVirtualTextureWorldToUvTransformName(TEXT("HeightVirtualTextureWorldToUvTransform_"));

// virtual texture parameters - normal
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexture0Name(TEXT("NormalVirtualTexture0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexture1Name(TEXT("NormalVirtualTexture1_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexturePageTableName(TEXT("NormalVirtualTexturePageTable_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureSamplerName(TEXT("NormalVirtualTextureSampler_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureWorldToUvTransformName(TEXT("NormalVirtualTextureWorldToUvTransform_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureEnabledName(TEXT("NormalVirtualTextureEnabled_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureUnpackModeName(TEXT("NormalVirtualTextureUnpackMode_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexturePageTableUniform0Name(TEXT("NormalVirtualTexturePackedUniform0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTexturePageTableUniform1Name(TEXT("NormalVirtualTexturePackedUniform1_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureUniforms0Name(TEXT("NormalVirtualTextureUniforms0_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::NormalVirtualTextureUniforms1Name(TEXT("NormalVirtualTextureUniforms1_"));

// cached texture - height
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureEnabledName(TEXT("CachedHeightTextureEnabled_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureName(TEXT("CachedHeightTexture_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureSamplerName(TEXT("CachedHeightTextureSampler_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureUvScaleBiasName(TEXT("CachedHeightTextureUvScaleBias_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureWorldToUvTransformName(TEXT("CachedHeightTextureWorldToUvTransform_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureUvToWorldTransformName(TEXT("CachedHeightTextureUvToWorldTransform_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedHeightTextureGridSizeName(TEXT("CachedHeightTextureGridSize_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::PointClampedSamplerName(TEXT("PointClampedSampler_"));

// cached texture - physmat
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedPhysMatTextureName(TEXT("CachedPhysMatTexture_"));
const FString FNiagaraDataInterfaceParametersCS_Landscape::CachedPhysMatTextureDimensionName(TEXT("CachedPhysMatTextureDimension_"));

// LWC
const FString FNiagaraDataInterfaceParametersCS_Landscape::SystemLWCTileName(TEXT("SystemLWCTile_"));

IMPLEMENT_TYPE_LAYOUT(FNiagaraDataInterfaceParametersCS_Landscape);
IMPLEMENT_NIAGARA_DI_PARAMETER(UNiagaraDataInterfaceLandscape, FNiagaraDataInterfaceParametersCS_Landscape);

#undef LOCTEXT_NAMESPACE
