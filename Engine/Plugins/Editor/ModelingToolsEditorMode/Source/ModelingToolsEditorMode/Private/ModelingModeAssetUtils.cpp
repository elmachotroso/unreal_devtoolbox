// Copyright Epic Games, Inc. All Rights Reserved.

#include "ModelingModeAssetUtils.h"
#include "ModelingToolsEditorModeSettings.h"

#include "Engine/World.h"
#include "AssetRegistryModule.h"
#include "AssetToolsModule.h"
#include "FileHelpers.h"
#include "Misc/Paths.h"
#include "ModelingObjectsCreationAPI.h"

// for content-browser things
#include "ContentBrowserModule.h"
#include "IContentBrowserSingleton.h"


#define LOCTEXT_NAMESPACE "ModelingModeAssetUtils"

namespace UE
{
namespace Local
{

FString GetWorldRelativeAssetRootPath(const UWorld* World)
{
	if (ensure(World->GetOutermost() != nullptr) == false)
	{
		return TEXT("/Game/");
	}
	FString WorldPackageName = World->GetOutermost()->GetName();
	FString WorldPackageFolder = FPackageName::GetLongPackagePath(WorldPackageName);
	return WorldPackageFolder;
}


FString GetActiveAssetFolderPath()
{
	IContentBrowserSingleton& ContentBrowser = FModuleManager::LoadModuleChecked<FContentBrowserModule>("ContentBrowser").Get();
	const FContentBrowserItemPath CurrentPath = ContentBrowser.GetCurrentPath();
	return CurrentPath.HasInternalPath() ? CurrentPath.GetInternalPathString() : FString();
}


FString MakeUniqueAssetName(const FString& FolderPath, const FString& AssetBaseName)
{
	FString UniquePackageName, UniqueAssetName;
	FAssetToolsModule& AssetToolsModule = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools");
	AssetToolsModule.Get().CreateUniqueAssetName(
		FolderPath + TEXT("/") + AssetBaseName, TEXT(""), UniquePackageName, UniqueAssetName);
	return UniqueAssetName;
}


FString InteractiveSelectAssetPath(const FString& DefaultAssetName, const FText& DialogTitleMessage)
{
	IContentBrowserSingleton& ContentBrowser = FModuleManager::LoadModuleChecked<FContentBrowserModule>("ContentBrowser").Get();

	FString UseDefaultAssetName = DefaultAssetName;
	FString CurrentPath = GetActiveAssetFolderPath();
	if (CurrentPath.IsEmpty() == false)
	{
		UseDefaultAssetName = MakeUniqueAssetName(CurrentPath, DefaultAssetName);
	}

	FSaveAssetDialogConfig Config;
	Config.DefaultAssetName = UseDefaultAssetName;
	Config.DialogTitleOverride = DialogTitleMessage;
	Config.DefaultPath = CurrentPath;
	return ContentBrowser.CreateModalSaveAssetDialog(Config);
}



}
}






FString UE::Modeling::GetNewAssetPathName(const FString& BaseNameIn, const UWorld* TargetWorld, FString SuggestedFolder)
{
	const UModelingToolsEditorModeSettings* Settings = GetDefault<UModelingToolsEditorModeSettings>();
	EModelingModeAssetGenerationBehavior AutoGenMode = Settings->AssetGenerationMode;

	FString PackageFolderPath = TEXT("/Game/");

	if (SuggestedFolder.Len() > 0 && SuggestedFolder.StartsWith("/") )
	{
		// if we had a suggested folder, use it (todo: check that this folder exists? or can be created?)
		PackageFolderPath = SuggestedFolder;
	}
	else
	{
		// Figure out the appropriate root path to use. If the level is in a plugin, this should
		// be the plugin top-level path and not /Game.
		if (Settings->AssetGenerationLocation == EModelingModeAssetGenerationLocation::AutoGeneratedWorldRelativeAssetPath)
		{
			PackageFolderPath = UE::Local::GetWorldRelativeAssetRootPath(TargetWorld);
		}

		// If the level is unsaved, then GetWorldRelativeAssetRootPath will return "/Temp". This is an undesirable
		// place to even temporarily save assets because they must be manually moved elsewhere to save, and the /Temp folder 
		// is somewhat troublesome to get to in the Editor. So if the flag below is set, then we will fall back to /Game
		// instead. Projects with strict asset polices (due to P4/etc) may not want to allow this by default, so it is configurable.
		if (PackageFolderPath.StartsWith("/Temp") && Settings->bStoreUnsavedLevelAssetsInTopLevelGameFolder)
		{
			PackageFolderPath = TEXT("/Game/");
		}

		// combine with fixed AutoGen path name if it is not empty
		if (Settings->AutoGeneratedAssetPath.Len() > 0)
		{
			PackageFolderPath = FPaths::Combine(PackageFolderPath, Settings->AutoGeneratedAssetPath);
		}

		// append username-specific subfolder
		if (Settings->bUsePerUserAutogenSubfolder)
		{
			FString UsernameString = Settings->AutogenSubfolderUserNameOverride.TrimStartAndEnd();
			if (UsernameString.IsEmpty())
			{
				UsernameString = FPlatformProcess::UserName();
			}
			if (!UsernameString.IsEmpty())
			{
				PackageFolderPath = FPaths::Combine(PackageFolderPath, UsernameString);
			}
		}

		// if we want to use the currently-visible asset browser path, try to find one (this can fail if no asset browser is visible/etc)
		if (Settings->AssetGenerationLocation == EModelingModeAssetGenerationLocation::CurrentAssetBrowserPathIfAvailable)
		{
			FString CurrentAssetPath = UE::Local::GetActiveAssetFolderPath();
			if (CurrentAssetPath.IsEmpty() == false)
			{
				PackageFolderPath = CurrentAssetPath;
			}
		}
	}

	FString ObjectBaseName = BaseNameIn;

	// If we are in interactive mode, show the modal dialog and then get the path/name.
	// If the user cancels, we are going to discard the asset
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		FString SelectedPath = UE::Local::InteractiveSelectAssetPath(ObjectBaseName, LOCTEXT("GenerateStaticMeshActorPathDialogWarning", "Choose Folder Path and Name for New Asset. Cancel to Discard New Asset."));
		if (SelectedPath.IsEmpty() == false)
		{
			PackageFolderPath = FPaths::GetPath(SelectedPath);
			ObjectBaseName = FPaths::GetBaseFilename(SelectedPath, true);
		}
		else
		{
			return FString();
		}
	}

	FString UseBaseName = ObjectBaseName;
	if (Settings->bAppendRandomStringToName)
	{
		FString GuidString = UE::Modeling::GenerateRandomShortHexString();
		UseBaseName = FString::Printf(TEXT("%s_%s"), *UseBaseName, *GuidString);
	}


	FString PackageNameOut, AssetNameOut;
	FAssetToolsModule& AssetToolsModule = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools");
	AssetToolsModule.Get().CreateUniqueAssetName(
		FPaths::Combine(PackageFolderPath, UseBaseName), TEXT(""),
		PackageNameOut, AssetNameOut);

	return PackageNameOut;
}



bool UE::Modeling::AutoSaveAsset(UObject* Asset)
{
	UPackage* AssetPackage = Asset->GetPackage();
	if (ensure(AssetPackage) == false)
	{
		return false;
	}

	Asset->MarkPackageDirty();
	FAssetRegistryModule::AssetCreated(Asset);

	TArray<UPackage*> PackagesToSave;
	PackagesToSave.Add(AssetPackage);

	bool bCheckDirty = true;
	bool bPromptToSave = false;		// because we are autosaving
	FEditorFileUtils::EPromptReturnCode Result = FEditorFileUtils::PromptForCheckoutAndSave(PackagesToSave, bCheckDirty, bPromptToSave);
	ensure(Result == FEditorFileUtils::PR_Success);
	return (Result == FEditorFileUtils::PR_Success);
}





void UE::Modeling::OnNewAssetCreated(UObject* Asset)
{
	const UModelingToolsEditorModeSettings* Settings = GetDefault<UModelingToolsEditorModeSettings>();
	EModelingModeAssetGenerationBehavior AutoGenMode = Settings->AssetGenerationMode;

	// Auto-save the new asset if the user has requested this behavior, or if an interactive
	// save/path dialog was shown earlier in the process (InteractivePromptToSave mode)
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateAndAutosave
		 || AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		AutoSaveAsset(Asset);
	}
	else if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateButDoNotAutosave)
	{
		Asset->MarkPackageDirty();
		FAssetRegistryModule::AssetCreated(Asset);
	}
}


#undef LOCTEXT_NAMESPACE